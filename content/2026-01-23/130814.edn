[{:rule-id "rule-ai", :item {:feed-id "hn", :item-id "https://brennan.io/2026/01/23/claude-code/", :title "Why I Don't Have Fun With Claude Code", :link "https://brennan.io/2026/01/23/claude-code/", :published-at #inst "2026-01-23T10:12:08.000-00:00", :content "Comments"}, :excerpts [{:text "Why I Don't Have Fun With Claude Code", :matched-terms ["claude"], :source :title}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://flexiana.com/?p=17880", :title "Machine Learning with Clojure: Benefits &amp; Perspectives", :link "https://flexiana.com/machine-learning-architecture/machine-learning-with-clojure-benefits-perspectives", :published-at #inst "2026-01-23T10:11:16.000-00:00", :content "Why is Clojure starting to catch people’s attention for machine learning, even in a world where Python still dominates? It is 2026 the buzz around machine learning has died down a bit. People are no longer chasing the next big thing; they just want tools that work. Python is everywhere, sure, but Clojure machine learning has found its place, especially among developers who value immutability, robust concurrency, and the speed of running on the JVM. This guide explains what makes Clojure stand out for machine learning. It provides an overview of Clojure in this field, reviews commonly used ML libraries, and outlines how Clojure compares to Python. Benefits of Clojure for Machine Learning and Data Science Projects ❶ Immutable Data Structures Clojure works with immutable, persistent data structures. When a dataset is created, it does not change unless a new one is made. This is a key factor in machine learning, where we can train and test models multiple times. Immutability guarantees that data cannot be changed unexpectedly, eliminating a common source of experimental error. In contrast, Python lists and arrays are mutable, which can lead to accidental state changes. Clojure’s immutable data structures ensure consistency and reliability throughout machine learning workflows. ❷ Superior Concurrency Via core. async Working with big datasets requires real parallel processing. Clojure’s core.async library steps in here. It uses channels to pass data between tasks, so we can eliminate stress about race conditions, locks, or weird bugs in shared state. This allows full focus on building the pipeline. This becomes even more useful while training multiple models simultaneously or streaming live data. Clojure ML Libraries takes full advantage of multicore CPUs, while Python often gets stuck with the GIL (Global Interpreter Lock), slowing things down. ❸ REPL-Driven Development Clojure’s REPL (Read-Eval-Print Loop) provides a live playground where it allows to write code, run it, and see the results immediately. Forget about waiting for long compiles or restarting the app. It helps to try ideas instantly. This kind of feedback is a game-changer in machine learning and data science. Models always require some fine-tuning, and with the REPL, simply tweak a parameter, swap out an algorithm, or load a new dataset on the fly. The whole process stays quick and smooth. It is also perfect for exploring. It helps to prototype, test out theories, and nail down solutions without wasting time. Working this way brings people together, too. Teams swap code snippets, try things out side by side, and build trust in the models as they develop. While dealing with messy, complicated data pipelines, being able to experiment safely and efficiently matters a lot. ❹ Concise and Expressive Clojure keeps things simple. The syntax is clean and avoids the extra code, keeping focus on the real logic. Less code is written, and it is easier to keep track of everything. That simplicity really shines in data science and machine learning. It helps to transform data, filter values, or build full pipelines in just a handful of lines. Instead of getting stuck on repetitive chores, teams actually solve problems. Clojure’s data tools are strong, too. Lists, maps, sequences- they are all built in and easy to use. It helps to work with data in a way that feels natural, and the code stays short and clear. For organizations, projects run faster, and bugs are fewer. The codebase also stays easy to manage. ❺ JVM Performance Benchmarks vs Python scikit-learn Performance is another area where Clojure really shines. Since it runs on the JVM, it benefits from Just-In-Time compilation and smart memory management. In real benchmarks, Clojure machine learning pipelines can actually beat Python’s scikit-learn, especially while running at scale across a bunch of machines. Plus, the JVM integrates well with most enterprise systems, making deployment smoother. If a team already uses Java or Scala, switching to Clojure just feels natural- and helps to skip the dependency headaches that come with Python. Top Clojure ML Libraries in 2026 Library Key Features Use Case scicloj.ml Pipelines, transformers Supervised learning tech.ml.dataset Data processing, GPU support Big data preprocessing Deep Diamond Neural nets, CUDA integration Deep learning dragan scicloj.ml This library gives modular pipelines and transformers. It’s built for supervised learning tasks. It connects with Smile and Tribuo to access a wide range of algorithms right out of the box- no extra setup. tech.ml.dataset Think of this as a dataframe library, but with GPU support. It is designed to handle large datasets and preprocess them before diving into training. If there is a lot of data, this tool helps keep things under control. Deep Diamond This is a neural network library that works with CUDA. It helps to train deep learning models on GPUs directly from Clojure. While building complex neural nets, this one just makes sense. Clojure Machine Learning vs Python: Key Comparisons Concurrency Wins Clojure just handles concurrency better than Python. It is immutable data and core.async channels take many common issues out of running parallel tasks. Want to train big models or launch a bunch of experiments at once? Clojure handles it, and there is no need to worry about hidden side effects. Python, on the other hand, encounters problems with the Global Interpreter Lock (GIL). True parallel execution? Not really. People try to work around it with multiprocessing, but that just adds more complexity. With Clojure, concurrency feels clear and reliable. Ecosystem Gaps Python definitely dominates when it comes to machine learning libraries: TensorFlow, PyTorch, scikit-learn, and the list keeps going. Clojure’s ecosystem is smaller, but there is momentum. Projects like SciCloj and Uncomplicate are developing new tools for data and visualization, and even GPU support. Sure, Python still gives more options, but Clojure’s libraries stick to functional programming ideas, so they fit together nicely. The gap is real, but it helps with steady progress from the Clojure community. Production Deployment Ease Getting models into production is usually tougher than training them. Python projects often get messy due to dependency conflicts and version issues. Clojure runs on the JVM, which is everywhere in enterprise systems. That means deployment is smoother, especially if a team already uses Java or Scala. It helps integrate Clojure models into existing systems with minimal effort. For enterprise settings, this kind of compatibility is a real win over Python’s dependency-heavy stacks. Few Real-World Clojure ML Use Cases and Success Stories Nubank’s Model Deployment [https://bit.ly/49BXM2E] Nubank is the top digital bank in Latin America, and it uses machine learning to detect fraud and perform financial modeling. Their team chose Clojure’s portability because it runs on the JVM, so it fit right into all their existing systems without much effort. Plus, Clojure’s functional programming principles keep the code clean and easy to maintain, which matters while dealing with sensitive stuff like financial workflows. Thanks to this setup, they can deploy fraud-detection models quickly and with confidence. The code stays reliable, and the JVM keeps everything compatible. Clojure’s focus on immutability also means it can reproduce results- a big deal for banks that need everything traceable. Flexiana’s Clojure Expertise Flexiana knows Clojure inside and out. We are a global team, and we focus on functional programming because it works- it actually solves real problems. When teams need to design and launch systems that can handle scale or build robust machine learning pipelines, they come to us. We don’t just talk theory; we help bridge that awkward gap between research and real-world production. For teams adopting Clojure ML libraries, Flexiana provides hands‑on engineering support. We are also big on open source: we contribute, we share what we learn, and we work to make the whole Clojure community stronger. That helps companies bring Clojure into their business without all the usual headaches. What These Stories Show OTTO proves Clojure can handle the heavy lifting for e-commerce, keeping complex ML pipelines both flexible and strong. Nubank demonstrates how Clojure operates in high-stakes industries like finance, where reliable and transparent systems are essential from end to end. Flexiana, on the other hand, is not just another Clojure consulting company. We are deep in the community, building real-world systems and sharing what we know about functional programming. Future Perspectives of Machine Learning with Clojure 2026 GPU/AI Advancements Via Uncomplicate In the future, machine learning withClojure is starting to feel pretty exciting, especially with the Uncomplicate ecosystem. Libraries like Neanderthal and Deep Diamond are pushing things forward. Neanderthal takes care of fast linear algebra Deep Diamond brings neural network support with CUDA integration Put these together, and it helps to get a setup to train and run models directly on the GPU from Clojure. As GPUs get faster in 2026, these libraries are set to keep pace, making Clojure a strong choice for deep learning and large‑scale numerical work. SciCloj Ecosystem Growth The SciCloj community is steadily expanding its ecosystem for data science and machine learning. The ecosystem is no longer just about pipelines and data preprocessing. Now, there are new libraries for Bayesian computing Time series analysis Probabilistic programming This means people are not just sticking to the basics- they are building specialized tools for complex statistical problems and real-world data. The modular approach helps a lot, too, as it helps to combine and match what is needed without heavy overhead. As all these pieces come together, Clojure is turning into a much more practical option for advanced machine learning research and even production work. So, Why Does All This Matter? Uncomplicate shows that Clojure can remain competitive in the race for GPU-driven deep learning. SciCloj shows the community can fill the gaps in serious statistical and probabilistic modeling. It is a good time to keep an eye on Clojure as machine learning continues to evolve. Getting Started: Clojure ML Tutorial & Code Examples For those just diving into machine learning with Clojure, check out scicloj.ml library. It is a great starting point. It helps avoid a ton of boilerplate, which is common in other languages. Instead, it helps to build pipelines in a clean, functional style. The whole focus is on the immutability and composition, so the code stays simple and easy to test. Example: A Simple Supervised Learning Pipeline (ns ml-example.core\n  (:require [scicloj.ml.core :as ml]\n            [scicloj.ml.dataset :as ds]\n            [scicloj.ml.model-selection :as sel]))\n\n;; Step 1: Load a dataset\n(def iris\n  (ds/load-dataset :iris))\n\n;; Step 2: Define features and target\n(def features\n  [:sepal-length :sepal-width :petal-length :petal-width])\n\n(def target\n  :species)\n\n;; Step 3: Split into train/test sets\n(def split\n  (sel/train-test-split iris {:ratio 0.8}))\n\n(def train\n  (:train split))\n\n(def test\n  (:test split))\n\n;; Step 4: Choose a model (e.g., decision tree)\n(def model\n  (ml/model :classification :decision-tree))\n\n;; Step 5: Train the model\n(def trained\n  (ml/train model train features target))\n\n;; Step 6: Evaluate on test data\n(def results\n  (ml/evaluate trained test features target))\n\n(println results)\n What Is Happening Here? Dataset loading is straightforward thanks to the built-in helpers. It helps to split up features and targets right up front, so it is always clear what the model is actually learning. Splitting data into train and test sets? The library handles it. No more manual shuffling. Model training uses a simple, declarative call. Evaluation returns metrics that can be inspected right away. This little snippet shows just how much simpler things can be while using Clojure’s ML libraries. It helps to work with immutable data and small, predictable functions. No messy mutable states. No tangled class hierarchies. Just compose what is needed. That makes it easier to experiment and keeps production code more reliable. Clojure for Machine Learning: FAQs for Beginners ❶ Is Clojure good for ML? Absolutely. If developers are already familiar with functional programming, Clojure feels right at home for ML. Its focus on immutability and easy concurrency makes it great for building scalable machine learning projects. ❷ Which Clojure ML libraries should Try First? Start with scicloj.ml for building ML pipelines. For working with data, tech.ml.dataset is great. If developers want GPU-powered deep learning, check out Deep Diamond. ❸ How does Clojure compare to Python for ML? Python’s ML ecosystem is much bigger- libraries like TensorFlow and PyTorch lead the way. Clojure’s ecosystem is smaller but growing. The benefits of Clojure for ML are cleaner concurrency, its functional design, and its strong integration with the JVM. ❹ Is it possible to use Clojure ML libraries in the company’s systems? Yes, it is. Since Clojure runs on the JVM, it works smoothly with Java or Scala setups. That makes deployment in enterprise environments a lot simpler. ❺ Is Clojure a good choice while just starting with machine learning? If developers are already comfortable with Clojure and just new to ML, it will be fine. The ML libraries here are built to be composable and functional, so it helps to experiment and learn by building small, clear steps. ❻ What kind of ML tasks can I do with Clojure? Pretty much all the basics- classification, regression, clustering- plus deep learning. Scicloj.ml handles the standard stuff, and Deep Diamond handles the heavy neural networks. ❼ Does Clojure support GPU acceleration? Yes. The Uncomplicate library family (like Neanderthal and Deep Diamond) brings GPU power to numerical computing and deep learning. ❽ Where to find and learn more about Clojure ML resources? Check out the SciCloj community. It helps with tutorials, study groups, and open-source projects- it is a good place to meet others and get real examples. To Summing Up By 2026, Clojure had really stepped up as a great alternative to Python for large-scale machine learning projects in the enterprise. It’s got some real benefits of Clojure for ML– immutability, easy concurrency, and solid JVM performance- that make it a natural fit when workflows need to be reproducible and able to scale. Clojure’s machine learning libraries have not just appeared overnight; they have been growing steadily. It helps to get the full package, from simple models to advanced neural nets. And this is not just theory. Just look at the real-world use cases. All of them show that Clojure is not just for experiment or side projects- it is solid enough for big, serious production work. Looking forward, with its rock-solid language features, growing libraries, and active communities like SciCloj and Uncomplicate, Clojure’s future looks bright. It is not just following in Python’s footsteps; it is carving out its own path, focusing on clarity, modularity, and long-term stability. If a team cares about reproducible science and building reliable enterprise systems, it is time to give Clojure a real look. Ready to move beyond experiments? Flexiana supports real‑world Clojure ML projects at scale. The post Machine Learning with Clojure: Benefits & Perspectives appeared first on Flexiana."}, :excerpts [{:text "Machine Learning with Clojure: Benefits &amp; Perspectives", :matched-terms ["clojure"], :source :title} {:text "Why is Clojure starting to catch people’s attention for machine...", :matched-terms ["clojure"], :source :content} {:text "... tools that work. Python is everywhere, sure, but Clojure machine learning has found its place, especially...", :matched-terms ["clojure"], :source :content}]}]