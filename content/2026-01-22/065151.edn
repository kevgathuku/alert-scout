[{:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://clojure-diary.gitlab.io/2026/01/22/converting-map-keys-to-nested-namespace-keys", :title "Converting map keys to nested namespace keys", :link "https://clojure-diary.gitlab.io/2026/01/22/converting-map-keys-to-nested-namespace-keys.html", :published-at #inst "2026-01-22T04:39:00.000-00:00", :content "Code ;; namespaced_keys.clj\n\n(defn keyword-name [k]\n  (clojure.string/replace (str (str k)) \":\" \"\"))\n\n(defn name-space\n  ([nsp m]\n   (if (map? m)\n     (reduce\n      (fn [acc [k v]]\n        (assoc acc (keyword (keyword-name nsp) (keyword-name k)) v)) {} m)\n     {nsp m}))\n\n  ([m]\n   (if (map? m)\n     (let [map-keys (keys m)\n           map-vals (vals m)]\n       (apply merge (map name-space map-keys map-vals)))\n     m)))\n\n;; https://dnaeon.github.io/clojure-map-ks-paths/\n(defn keys-in\n  \"Returns a sequence of all key paths in a given map using DFS walk.\"\n  [m]\n  (letfn [(children [node]\n            (let [v (get-in m node)]\n              (if (map? v)\n                (map (fn [x] (conj node x)) (keys v))\n                [])))\n          (branch? [node] (-> (children node) seq boolean))]\n    (->> (keys m)\n         (map vector)\n         (mapcat #(tree-seq branch? children %)))))\n\n(defn map-depth [m]\n  (apply max (map count (keys-in m))))\n\n(defn deep-name-space\n  ([m depth]\n   (if (< depth 1)\n     m\n     (recur (name-space m) (dec depth))))\n\n  ([m]\n   (deep-name-space m (dec (map-depth m)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;\n;; Examples\n;;;;;;;;;;;;;;;;;;;;;;;;\n\n(keyword-name :user/a)\n;;=> \"user/a\"\n\n(name :user/a)\n;;=> \"a\"\n\n(defn some-fn [nsp acc k v]\n  (assoc acc (keyword (keyword-name nsp) (keyword-name k)) v))\n\n(some-fn :user {} :a 1)\n;;=> #:user{:a 1}\n\n(keys (some-fn :user {} :a 1))\n;;=> (:user/a)\n\n(defn some-fn-with-defaults [acc key-val]\n  (let [k (first (keys key-val))\n        v (first (vals key-val))]\n    (some-fn :user acc k v)))\n\n(some-fn-with-defaults {} {:a 1})\n;;=> #:user{:a 1}\n\n(reduce some-fn-with-defaults {} [{:a 1} {:b 2}])\n;;=> #:user{:a 1, :b 2}\n\n(name-space :user \"john\")\n;;=> {:user \"john\"}\n\n(name-space :user {:a 1})\n;;=> #:user{:a 1}\n\n(name-space :user {:a 1 :b 2})\n;;=> #:user{:a 1, :b 2}\n\n(name-space :user {:a 1 :b {:c 2}})\n;;=> #:user{:a 1, :b {:c 2}}\n\n(name-space\n (name-space :user {:a 1 :b {:c 2}}))\n;;=> {:user/a 1, :user/b/c 2}\n\n(deep-name-space {:user {:a 1 :b {:c 2}}} 1)\n;;=> #:user{:a 1, :b {:c 2}}\n\n(deep-name-space {:user {:a 1 :b {:c 2}}} 2)\n;;=> {:user/a 1, :user/b/c 2}\n\n(keys-in {:user {:a 1 :b {:c 2}}})\n;;=> ([:user] [:user :a] [:user :b] [:user :b :c])\n\n(map-depth {:user {:a 1 :b {:c 2}}})\n;;=> 3\n\n(deep-name-space {:user {:a 1 :b {:c 2}}})\n;;=> {:user/a 1, :user/b/c 2}\n\n\n(def deep-ns-map \n(deep-name-space {:user {:a 1 :b {:c 2}}}))\n\ndeep-ns-map\n;;=> {:user/a 1, :user/b/c 2}\n\n(last (keys deep-ns-map))\n;;=> :user/b/c\n\n(get deep-ns-map (last (keys deep-ns-map)))\n;;=> 2\n\n(:user/b/c deep-ns-map)\n;;=> nil\n\n(type :user/b/c)\n;;=> clojure.lang.Keyword\n\n(get deep-ns-map :user/b/c)\n;;=> nil\n\n(get deep-ns-map (keyword \"user/b/c\"))\n;;=> nil"}, :excerpts [{:text "... class=\"highlight\"><pre><code class=\"language-clojure\"><span class=\"c1\">;;...", :matched-terms ["clojure"], :source :content} {:text "...  </span><span class=\"p\">(</span><span class=\"nf\">clojure.string/replace</span><span class=\"w\"> </span><span...", :matched-terms ["clojure" "repl"], :source :content} {:text "... class=\"c1\">;; https://dnaeon.github.io/clojure-map-ks-paths/</span><span class=\"w\">\n</span><span...", :matched-terms ["clojure"], :source :content}]}]