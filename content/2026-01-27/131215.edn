[{:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://dev.to/dimension-zero/just-what-is-python-anyway-7ce", :title "Just what IS Python, anyway?", :link "https://dev.to/dimension-zero/just-what-is-python-anyway-7ce", :published-at #inst "2026-01-27T08:38:33.000-00:00", :content "A mental model for understanding Python‚Äôs role Anyone who started programming in the early 1980s might have started with Apple II BASIC, BBC BASIC or Sinclair BASIC (ZX-81 or ZX Spectrum) - and 6502 or Z80 assembler. Those early environments were all defined by immediacy. You typed something in; the machine did something. There was no ambiguity about what the language was for. Since then a professional programmer might have ventured through FORTRAN, C, C++, UNIX shell, Visual Basic, VBA, VB.NET, C#, F#, JavaScript and more recently Rust, Zig, Nim and Odin. Every one of those fits elegantly into a mental slot: Systems language, Application language, Functional language, Runtime language or Tooling language. Python, oddly, doesn‚Äôt. It can be tricky, for an experienced programmer, to grasp what it was and how it related to the other languages or which slot to put it in. Often, they will conclude \"I don't like Python\" and express confusion at its vast popularity - and even primacy - in the 2020s. A slippery language Traditionally we‚Äôre taught to classify languages along a few axes: compiled vs interpreted scripting vs ‚Äúreal‚Äù languages imperative vs OO vs functional Python fits poorly into all of them. It isn't a compiled language in the C or Rust sense: it doesn't result in a standalone executable. But it isn't purely interpreted either, since it must be processed before execution. It supports imperative, object-oriented and functional styles but isn‚Äôt optimized for any of them. It began as a scripting language, but today it‚Äôs used to build large, long-running systems. So just what IS Python? Python is not a binary-producing language The turning point is to realize that Python is not defined by the artefact it produces. C, C++, Rust, Zig and Fortran produce binaries that can be directly run. The output is the thing. Once compiled, the language more or less disappears. Python doesn‚Äôt work like that. Python source code is compiled to bytecode, and that bytecode is executed by a virtual machine. The VM, the object model, the garbage collector and the standard library are not incidental. They are Python. A Python program needs this ecosystem to run; it can't run standalone, unless they are all bundled in with it. In structural terms, Python sits alongside languages with runtimes and ecosystems: .NET (C#, F#, VB.NET) the JVM (Java, Scala, Kotlin, Clojure) In all three cases, the runtime is the unit of execution, not the compiled artefact. ‚ÄúInterpreted vs compiled‚Äù is therefore a false dichotomy. CPython parses Python source-code to an Abstract Syntax Tree (AST), compiles it to bytecode and then executes that bytecode on a VM. That‚Äôs not conceptually different from Java or .NET ‚Äî just simpler and often slower, while the runtime startup overhead persists. Python‚Äôs real role: orchestration The solution to the puzzle of \"What IS Python?\" is to realize that Python is a runtime-centric language, whereupon its real role becomes obvious. Python is not primarily about doing work. It‚Äôs about controlling work. It's exceptional good and for quickly lashing stuff together: like Lego, Meccano or snap-on tooling than traditional software construction. The most important Python libraries ‚Äî NumPy, SciPy, Pandas, PyTorch, TensorFlow ‚Äî are not written in Python in any meaningful sense. Python provides the API, the glue and the control flow. The heavy lifting happens in underlying libraries written in C, C++, Fortran or CUDA - anything that can expose a C ABI (Application Binary Interface). Python performs the same role over its libraries as: SQL over databases shell over Unix VBA over Office It is an orchestration language sitting above high-performance systems. That‚Äôs why it thrives in scientific computing, data pipelines and machine learning. It lets you build rapidly and easily, with simply syntax, whilst the underlying libraries deliver the performance. So long as orchestration overhead is low, Pythobn-based systems can scale surprisingly far. Why Python still feels slippery Even with this framing, Python can still feel oddly unsatisfying if you come from strongly structured languages. Compared with .NET or the JVM, Python has: weak static guarantees loose module boundaries a simpler, leakier object model If you‚Äôre used to the discipline of C#, F# or Rust, Python can feel vague. Things work ‚Äî until they don‚Äôt ‚Äî and the language often declines to help you reason about correctness ahead of time. It turns out that being able to throw things together quickly, in easy-to-understand code, and ecosystem breadth are far more important for mass adoption than type-safety, compilation, raw-performance or architectural rigidity. Make something easy, and more people will do it, more often. Python's winning formula is to lower the barrier-to-entry for proof-of-concept and prototype stage projects - much like Visual BASIC and VBA did in the 1990s - and can even get to MVP (Minimum Viable Product). You can always make it faster, later, by translating critical paths into a compiled language. Getting something working, at all and quickly, turns out to be hugely more important than getting it working fast or elegantly - something shell scripting showed us as far back as the 1970s. Clearing up potential misunderstandings Common misconceptions are worth addressing: ‚ÄúPython is slow‚Äù Python orchestrates underlying code. In most applications, performance-critical paths live in native libraries. Only in a small number of domains ‚Äî such as ultra-low-latency systems ‚Äî does Python itself become the limiting factor. ‚ÄúPython is a scripting language‚Äù Historically true, as that's how it originated, but it has evolved vastly since then. ‚ÄúPython is interpreted‚Äù Better to say it is pre-compiled to bytecode that is then executed by a virtual machine. A better language classification A proper taxonomy therefore looks like this: Standalone native languages C, C++, Rust, Zig, Fortran ‚Üí the binary is the product Runtime ecosystems Python, JVM languages, .NET languages ‚Üí the runtime is the product Host-bound scripting languages Bash, PowerShell, VBA ‚Üí the host environment is the product Python belongs firmly in the second group. A brief note for Rust and Go proponents A common challenge from Rust or Go developers is that Python‚Äôs role is better served by ‚Äúdoing it properly‚Äù in a compiled language from the start. That view makes sense ‚Äî if your problem is well-specified, stable, performance-critical, and worth committing to upfront architectural constraints. In those cases, Rust or Go are often excellent choices - although these languages are more specialized than, say, C#, F# or JavaScript. But many real-world problems do not start that way. They begin as ill-defined, exploratory or evolving systems: data pipelines, research code, internal tools, integration glue. A research-team needs to test an idea quickly in a small-scale way, rather than performantly on terabytes of data. A business-development team needs to solve a problem quickly and tactically, because the business needs a solution \"yesterday\". Some problems move to fast to wait for a strategic solution, or the cost of a strategic solution cannot yet be justified as too much is unknown. In those contexts, early commitment to strict typing, memory models or concurrency primitives can slow learning rather than accelerate it. Python‚Äôs advantage is not that it replaces C#, Java, Rust or Go. It is that it defers commitment. You can explore the problem space quickly, validate assumptions, and only later decide which parts deserve the cost of rewriting in a compiled language. Your Proof-of-Concept or Prototype written in Python becomes your teacher and learning exercise. In practice, Python and Rust and Go are not competitors but complements: Python for orchestration and discovery; Rust or Go for stabilised, performance-critical components where very specific issues need to be solved. Rust eliminates entire classes of bug to do with memory-management and threading; Go is superb at server-side services. These are not everyday programming needs. Summary Python isn‚Äôt confused, incoherent or a \"toy\" language. It simply departs from the mental models of earlier generations of languages and fulfills a unique role that no other language can quite match. Python is not any of compiled, interpreted or ‚Äújust a scripting language‚Äù. It's a runtime-centric orchestration layer and a complete ecosystem of its own. It's the Visual Basic and VBA of the internet era: ideal for rapid assembly, experimentation and leverage rather than purity or control. And that makes it incredibly useful - and wildly popular."}, :excerpts [{:text "... environments were all defined by immediacy. You typed something in; the machine did something. There...", :matched-terms ["typed"], :source :content} {:text "... UNIX shell, Visual Basic, VBA, VB.NET, C#, F#, JavaScript and more recently Rust, Zig, Nim and Odin....", :matched-terms ["java"], :source :content} {:text "... slot: Systems language, Application language, Functional language, Runtime language or Tooling language....", :matched-terms ["functional"], :source :content}]} {:rule-id "clojure-db", :item {:feed-id "planet-clojure", :item-id "https://gaiwan.co/blog/rss/6973519d39f35300895d0f19", :title "Gaiwan: Hire Us!", :link "https://gaiwan.co/blog/gaiwan-hire-us-2/", :published-at #inst "2026-01-27T09:13:48.000-00:00", :content "Hire Us! We are actively pursuing new work with clients old and new. We&aposre in the first place interested in Clojure/ClojureScript gigs, but happy to chat about any potential leads even if you yourself are not hiring. Things we can do for you: Long- or short-term team augmentation Programming new features Modernizing old codebases Clojure / Clojurescript coaching Make your team more productive by improving dev tooling Consulting on how to manage YOUR open source and community Feature work on OUR open source (all lambdaisland/Gaiwan libraries) Architecture review Cleaning up vibe-coded code bases that have become unmaintainable Mitesh Shah profile photo with wild hair and a blue suit. Our colleague Mitesh Shah is open to new work. He&aposs a talented engineer, practical and enterpreneurial with a lot of experience at startups. He knows how to ship, he&aposs a great communicator, and above all he&aposs a great person to work with. He&aposs truly full stack, from UI/UX to the database and back. Bettina Shzu-Juraschek, who covers legal, tax, HR, and operations at Gaiwan, can create financial overviews and close money leaks for small businesses. 2026 Conferences Preview This year we&aposre looking forward to attending the Babashka conference on May 8, 2026, and Dutch Clojure Days on May 9, 2026, in Amsterdam. It&aposs always great to get together with the Clojure community in real life! We&aposre booking a sailboat in Weesp with accommodations for up to 16 people; if you want to book a berth either in your own room or in a shared room, sign up here. Bettina will be at FOSS Backstage and FOSS Backstage Design in Berlin from March 16-18, 2026, to push forward our open source projects. Reach out if you want to connect there. #tea-break At Gaiwan we share interesting reads in our #tea-break channel. Here&aposs a selection: Why there‚Äôs no European Google? \"Can we just stop equating success with short-term economic growth? What if we used usefulness and longevity? What if we gave more value to the fundamental technological infrastructure instead of the shiny new marketing gimmick used to empty naive wallets?\" The Office according to \"The Office.\" by Ribbonfarm. An oldie but goodie. Are you a sociopath, a loser, or clueless? The Bitter Lesson by Rich Sutton. In the long run, general-purpose methods that leverage massive computation‚Äîspecifically search and learning‚Äîconsistently outperform specialized systems built on human domain expertise. Yayyay events shares the financial statements from their events. \"Organizing Lambda World this year came with a price tag of ‚Ç¨52,000,...with a ‚Ç¨4,000 deficit.\" If we had included the costs of our salaries in the budget for the Heart of Clojure conference we organized in 2024, we would have also been 5 figures in the red. üôÅ What are you reading these days?"}, :excerpts [{:text "... new. We&aposre in the first place interested in Clojure/ClojureScript gigs, but happy to chat about any potential...", :matched-terms ["clojure"], :source :content} {:text "... new features Modernizing old codebases Clojure / Clojurescript coaching Make your team more productive by...", :matched-terms ["clojure"], :source :content} {:text "... Babashka conference on May 8, 2026, and Dutch Clojure Days on May 9, 2026, in Amsterdam. It&aposs always great to get together with the Clojure community in real life! We&aposre booking a...", :matched-terms ["clojure"], :source :content}]}]