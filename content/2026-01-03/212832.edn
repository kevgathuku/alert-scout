[{:rule-id "rule-ai", :item {:feed-id "hn-frontpage", :item-id "https://news.ycombinator.com/item?id=46480677", :title "Show HN: Vibe Coding a static site on a $25 Walmart Phone", :link "https://stetsonblake.com/%2425+Walmart+Phone+for+Hackers", :published-at #inst "2026-01-03T19:39:46.000-00:00", :content "Hi! I took a cheap $25 walmart phone and put a static server on it? Why? Just for a fun weekend project. I used Claude Code for most of the setup. I had a blast. It's running termux, andronix, nginx, cloudflared and even a prometheus node exporter. Here's the site: https://walmartphone.stetsonblake.com/ Comments URL: https://news.ycombinator.com/item?id=46480677 Points: 7 # Comments: 0"}, :excerpts [{:text "... Why? Just for a fun weekend project. I used Claude Code for most of the setup. I had a blast. It's...", :matched-terms ["claude"], :source :content}]} {:rule-id "rule-ai", :item {:feed-id "planet-clojure", :item-id "https://spool-five.com/posts/2025-12-18_2025_review/", :title "2025 Highlights", :link "https://spool-five.com/posts/2025-12-18_2025_review/", :published-at #inst "2025-12-23T00:00:00.000-00:00", :content "Some notes on the year. Movies/TV Lots of TV shows this year. These are some of the ones that stood out. Great Andor Adolescence The Rehearsal - Season 2 The Pitt (probably my favourite of the year) The Chair Company Squid Game Season 3 (might be controversial to have this here, but I enjoyed it) (movie) Jia Zhangkeâ€™s â€œCaught by the Tidesâ€. Deeply moving meditation on time, love, displacement and process. Long Story Short (movie) No Other Choice The Studio I also went to a screening of Kwaiden (1964) this year and it was incredible. Hounorable Mentions The Eternaut Pachinko - Season 2 Severance - Season 2 Foundation - Season 3 Dept Q. Alice in Borderland - Season 3 Slow Horses Disappointments The Last of Us - Season 2 (movie) One Battle After Another - had its good points definitely, but I always have very high expectations for PTA and the last two let me down. Alien: Earth - I did really enjoy this, but a lot of problems with it too (as an â€˜Alienâ€™ installment) Books Not too much reading this year, but my favourite was definitely â€œEvery Living Thingâ€ (Jason Roberts). I also enjoyed: Solaris Pachinko Drive Your Plough Over the Bones of the Dead Delta V Travel Some for work, some for pleasure: Japan (I visited many places in this wonderful country! Highlights - Kyoto, Naoshima Island) Seattle Baku Programming Continuing to learn more about clojure. I program purely as a hobby. I participated in the first Scinoj Lite conference, which had some great talks. My project looked at ways of evaluating LLMs (from a very basic, almost â€™naiveâ€™, perspective). Write-up of my LLM evaluation project Played around with the new clojure â€˜flowâ€™ libary. Clojure Flow Blog Post Clojure Flow project I started a webscraping project that is trying to map Irish-language content on the .ie domain. Irish language webscraping project I also enjoyed this yearâ€™s advent of code. Advent of Code (clojure)"}, :excerpts [{:text "... lot of problems with it too (as an â€˜Alienâ€™ installment) Books Not...", :matched-terms ["llm"], :source :content} {:text "... talks. My project looked at ways of evaluating LLMs (from a very basic, almost â€™naiveâ€™,...", :matched-terms ["llm"], :source :content} {:text "... Write-up of my LLM evaluation project Played around with...", :matched-terms ["llm"], :source :content}]} {:rule-id "rule-ai", :item {:feed-id "planet-clojure", :item-id "https://clojure.org/news/2025/12/23/deref", :title "Clojure Deref (Dec 23, 2025)", :link "https://clojure.org/news/2025/12/23/deref", :published-at #inst "2025-12-23T00:00:00.000-00:00", :content "Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed: RSS). The annual Clojure surveys are live Help shape the future of Clojure! Whether you use Clojure, ClojureScript, Babashka, or any other Clojure dialect, please fill out the 2025 State of Clojure Survey and spread the word on social media. This survey gives us the best snapshot of the Clojure community, so help us get as many participants as possible. If you use ClojureScript or dialects like Squint, Cherry, nbb, and such, please fill out the 2025 State of ClojureScript Survey and share it with others. Thank you for your help! Upcoming Events Clojure real-world-data 38: Dec 26 Scicloj AI Meetup: Agent-o-rama: Jan 17 Clojure Jam 2026: Apr 18-19 & 25-26. Online & free! CFP is open until Jan 31st. Babashka Conf: May 8. Amsterdam, NL. Free registration, but tickets are limited! Dutch Clojure Days 2026: May 9th. Amsterdam, NL. Join the waitlist, or the CFP is open until Jan 15th. Podcasts, videos, and media One year of building my own IDE in clojure - phronmophobic Event-sourcing with projections in Clojure and PostgreSQL - Andrey Fadeev Announcing Multi REPL Sessions in Calva - CalvaTV Clojure/Conj 2025 Photos A Decade on Datomic - Davis Shepherd & Jonathan Indig (Netflix) - ClojureTV UnifyBio: Power Tools for Translational Data Science - Benjamin Kamphaus - ClojureTV Cats, Dogs, and Python - Paula Gearon - ClojureTV Agent-o-rama: Scalable, Traceable, Stateful AI agents in Pure Clojure or Java - Nathan Marz - ClojureTV Clojure South 2025 Construindo aplicaÃ§Ãµes web elegantes com ClojureScript, React e UIx! | Clojure South 2025 - Building Nubank Fail fast, fix faster: Injecting failures on integration tests | Clojure South 2025 - Building Nubank Clojure to Elixir: Functional Programming for Scalable & Sustainable Apps | Clojure South 2025 - Building Nubank Clojure e IA: Construindo Agentes Inteligentes sem Reinventar a Roda | Clojure South 2025 - Building Nubank Introduzindo programaÃ§Ã£o funcional na Carteira Digital de TrÃ¢nsito | Clojure South 2025 - Building Nubank NuFileBox Reverse: GestÃ£o segura de arquivos com Clojure | Clojure South 2025 - Building Nubank Uma estratÃ©gia incremental com apoio IA para testes unitÃ¡rios em Clojure | Clojure South 2025 - Building Nubank Betting on open source: Adventures with Datahike | Clojure South 2025 - Building Nubank 12 years of Component | Clojure South 2025 - Building Nubank Blogs, articles, and news A Christmas Present in Clojure â€“ Metosin - Joel Kaasinen Clerk notebooks with solutions for Advent of Code 2025 - Miran Clojurists Together 2026 Annual Funding Announcement - Kathy Davis Announcing Oak 1.0 - Arne Brasseur Easel Turns One! - Adrian Smith (recur thoughts \"Nullable pattern: Experience report\") - Emil Bengtsson Machine Learning in Clojure with libpython-clj: Bridging Functional Elegance and Pythonâ€™s ML Power [Series 1] - Flexiana - Jiri Knesl The Best Things and Stuff of 2025 - Michael Fogus An incremental strategy with AI support for unit testing in Clojure - Building Nubank - Nubank Editorial How NuFilebox Reverse strengthens file security at Nubank - Building Nubank - Nubank Editorial 12 years of Component: A decade of interactive development - Building Nubank - Nubank Editorial Building elegant interfaces with ClojureScript, React, and UIx - Building Nubank - Nubank Editorial Libraries and Tools Debut release cljs-uix-electron - Uix + Electron starter cljs-uix-wails - Wails + ClojureScript starter Oak - Oak is a Free and Open Source Identity Provider that you can host yourself immersa - Open Source Web-based 3D Presentation Tool bb-timemachine - Run code back in Git-time. solid-cljs - ClojureScript bindings to Solid clojars-download-stats - An always up-to-date, complete SQL export of artifacts daily downloads since November 2012 malt - Malli-Typed interfaces for Clojure distributed-scope - Run one lexical scope across distributed peers. Updates repath-studio 0.4.11 - A local web-based vector graphics editor that combines procedural tooling with traditional design workflows. dtype-next 10.000-beta-11 - A Clojure library designed to aid in the implementation of high performance algorithms and systems. repl-mcp d00f661 - Model Context Protocol Clojure support including REPL integration with development tools. virtuoso 0.1.2 - A number of trivial wrappers on top of virtual threads bbin 0.2.5 - Install any Babashka script or project with one command stripe-clojure 2.1.0 - Clojure SDK for the Stripe API. muutos 2025-12-18 - Muutos is a zero-dependency Clojure library for reacting to changes in a PostgreSQL database. cherry 0.5.34 - Experimental ClojureScript to ES6 module compiler nbb 1.3.205 - Scripting in Clojure on Node.js using SCI replicant 2025.12.1 - A data-driven rendering library for Clojure(Script) that renders hiccup to DOM or to strings. joyride 0.0.72 - Making VS Code Hackable like Emacs since 2022 process 0.6.25 - Clojure library for shelling out / spawning sub-processes fireworks 0.19.0 - Fireworks is a themeable tapping library for Clojure, ClojureScript, and Babashka. bling 0.9.2 - Rich text console printing for Clojure, ClojureScript, and Babashka. clj-kondo 2025.12.23 - Static analyzer and linter for Clojure code that sparks joy calva 2.0.543 - Clojure & ClojureScript Interactive Programming for VS Code sci 0.11.50 - Configurable Clojure/Script interpreter suitable for scripting and Clojure DSLs scittle 0.7.30 - Execute Clojure(Script) directly from browser script tags via SCI partial-cps 0.1.42 - A lean and efficient continuation passing style transform, includes async-await support."}, :excerpts []} {:rule-id "rule-ai", :item {:feed-id "planet-clojure", :item-id "https://blog.parenstech.com/2025-12-28-heretic-mutation-testing.html", :title "Heretic: Mutation Testing in Clojure", :link "https://blog.parenstech.com/2025-12-28-heretic-mutation-testing.html", :published-at #inst "2025-12-28T23:59:59.000-00:00", :content "Your tests pass. Your coverage is high. You deploy. Three days later, a bug surfaces in a function your tests definitely executed. The coverage report confirms it: that line is green. Your test ran the code. So how did a bug slip through? Because coverage measures execution, not verification. (defn apply-discount [price user] (if (:premium user) (* price 0.8) price)) (deftest apply-discount-test (is (number? (apply-discount 100 {:premium true}))) (is (number? (apply-discount 100 {:premium false})))) Coverage: 100%. Every branch executed. Tests: green. But swap 0.8 for 1.2? Tests pass. Change * to /? Tests pass. Flip (:premium user) to (not (:premium user))? Tests pass. The tests prove some number comes back. They say nothing about whether it&aposs the right number. The Question Nobody&aposs Asking Mutation testing asks a harder question: if I introduced a bug, would any test notice? The technique is simple. Take your code, introduce a small change (a \"mutant\"), and run your tests. If a test fails, the mutant is \"killed\" - your tests caught the bug. If all tests pass, the mutant \"survived\" - you&aposve found a gap in your verification. This isn&apost new. PIT does it for Java. Stryker does it for JavaScript. cargo-mutants does it for Rust. Clojure hasn&apost had a practical option. The only dedicated tool, jstepien/mutant, was archived this year as \"wildly experimental.\" You can run PIT on Clojure bytecode, but bytecode mutations bear no relationship to mistakes Clojure developers actually make. You&aposll get mutations like \"swap IADD for ISUB\" when what you want is \"swap -> for ->> \" or \"change :user-id to :userId.\" Why Clojure Makes This Hard Mutation testing has a performance problem everywhere. Run 500 mutations, execute your full test suite for each one, and you&aposre measuring build times in hours. Most developers try it once, watch the clock, and never run it again. But Clojure adds unique challenges: Homoiconicity cuts both ways. Code-as-data makes programmatic transformation elegant, but distinguishing \"meaningful mutation\" from \"syntactic noise\" gets subtle when everything is just nested lists. Macros muddy the waters. A mutation to macro input might not change the expanded code. A mutation inside a macro definition might break in ways that have nothing to do with your production logic. The bugs we make are language-specific. Threading macro confusion, nil punning traps, destructuring gotchas from JSON interop, keyword naming collisions - these aren&apost + becoming -. They&aposre mistakes that come from thinking in Clojure. What If It Could Be Fast? The insight that makes Heretic practical: most mutations only need 2-3 tests. When you mutate a single expression, you don&apost need your entire test suite. You need only the tests that exercise that expression. Usually that&aposs a handful of tests, not hundreds. The challenge is knowing which ones. Not just which functions they call, but which subexpressions they touch. The + inside (if condition (+ a b) (* a b)) might be covered by different tests than the *. Heretic builds this map using ClojureStorm, the instrumented compiler behind FlowStorm. Run your tests once under instrumentation. From then on, each mutation runs only the tests that actually touch that code. Instead of running 200 tests per mutation, we run 2. Instead of hours, seconds. What If It Understood Clojure? Generic operators miss the bugs we actually make: ;; The mutation you want: threading macro confusion (-> data (get :users) first) ; Original (->> data (get :users) first) ; Mutant: wrong arg position, wrong result ;; The mutation you want: nil punning trap (when (seq users) (map :name users)) ; Original (handles empty) (when users (map :name users)) ; Mutant (breaks on empty list) ;; The mutation you want: destructuring gotcha {:keys [user-id name]} ; Original (kebab-case) {:keys [userId name]} ; Mutant (camelCase from JSON) Heretic has 65+ mutation operators designed for Clojure idioms. Swap first for last. Change rest to next. Replace -> with some->. Mutate qualified keywords. The mutations you see will be the bugs you recognize. What If It Could Think? Here&aposs a finding that should worry anyone relying on traditional mutation testing: research shows that nearly half of real-world faults have no strongly coupled traditional mutant. The bugs that escape to production aren&apost the ones that flip operators. They&aposre the ones that invert business logic. ;; Traditional mutation: swap * for / (* price 0.8) --> (/ price 0.8) ; Absurd. Nobody writes this bug. ;; Semantic mutation: invert the discount (* price 0.8) --> (* price 1.2) ; Premium users pay MORE. Plausible bug. A function called apply-discount should never increase the price. That&aposs the invariant tests should verify. An AI can read function names, docstrings, and context to generate the mutations that test whether your tests understand the code&aposs purpose. This hybrid approach - fast deterministic mutations for the common cases, intelligent semantic mutations for the subtle ones - is where Heretic is heading. Meta&aposs ACH system proved the pattern works at industrial scale. Why \"Heretic\"? Clojure discourages mutation. Values are immutable. State changes through controlled transitions. The design philosophy is that uncontrolled mutation leads to bugs. So there&aposs something a bit ironic about a tool that deliberately introduces mutations to find those bugs. We mutate your code to prove your tests would catch it if it happened accidentally - to verify that the discipline holds. This is the first in a series on building Heretic. Upcoming posts will cover how ClojureStorm enables expression-level coverage mapping, how we use rewrite-clj and clj-reload for hot-swapping mutants, and the optimization techniques that make this practical for real codebases. If your coverage is high but bugs still slip through, you&aposre measuring the wrong thing."}, :excerpts []} {:rule-id "rule-ai", :item {:feed-id "planet-clojure", :item-id "https://clojure.org/news/2025/12/30/deref", :title "Clojure Deref (Dec 30, 2025)", :link "https://clojure.org/news/2025/12/30/deref", :published-at #inst "2025-12-30T00:00:00.000-00:00", :content "Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed: RSS). Last chance for the annual Clojure surveys! Time is running out to take the Clojure surveys! Please help spread the word, and take a moment to fill them out if you havenâ€™t already. Fill out the 2025 State of Clojure Survey if you use any version or dialect of Clojure in any capacity. Fill out the 2025 State of ClojureScript Survey and if you use ClojureScript or dialects like Squint, Cherry, nbb, and such. Thank you for your help! Upcoming Events Clojure real-world-data 39: Jan 2 Scicloj AI Meetup: Agent-o-rama: Jan 17 Clojure Jam 2026: Apr 18-19 & 25-26. Online & free! CFP is open until Jan 31st. Babashka Conf: May 8. Amsterdam, NL. Free registration, but tickets are limited! Dutch Clojure Days 2026: May 9th. Amsterdam, NL. Join the waitlist, or the CFP is open until Jan 15th. Podcasts, videos, and media Browser Jack-in â€“ Connect your Clojure editor to any web page - CalvaTV Clojure/Conj 2025 Rich Hickeyâ€™s opening remarks from Clojure/Conj 2025 - ClojureTV 12 Years of Component - Alessandra Sierra - ClojureTV Blogs, articles, and news Mixing Swift and Clojure in Your iOS App - Scittle - Rod Schmidt Tetris-playing AI the Polylith way - Part 1 - Joakim Tengstrand Implementing the Algebra of Graphics in Clojure - Part 1 â€“ Clojure Civitas - Daniel Slutsky Machine Learning in Clojure with libpythonâ€‘clj: Using Bayesian Networks for Smarter, Interpretable AI [Series 2] - Flexiana - Jiri Knesl Machine Learning in Clojure with libpythonâ€‘clj: Unlocking Causal Insights Using Microsoftâ€™s EconML [Series 3] - Flexiana - Jiri Knesl One csv parser to rule them all - Kasim Tuman Heretic: Mutation Testing in Clojure - Eric Dvorsak Building Heretic: From ClojureStorm to Mutant Schemata - Eric Dvorsak Thanks AI! - Rich Hickey Libraries and Tools Debut release crabjure - A fast static analyzer for Clojure and ClojureScript, written in Rust. browser-jack-in - A web browser extension that letâ€™s you inject a Scittle REPL server into any browser page. clamav-clj - An idiomatic, modern Clojure wrapper for ClamAV. heretic - Mutation testing for Clojure - fast, practical, and integrated Updates Many Clojure contrib libs were updated to move the Clojure dependency to 1.11.4, which is past the CVE fixed in 1.11.2. partial-cps 0.1.50 - A lean and efficient continuation passing style transform, includes async-await support. csvx 68fd22c - A zero dependencies tool that enables you to control how to tokenize, transform and handle files with char(s) separated values in Clojure and ClojureScript. recife 0.22.0 - A Clojure model checker (using the TLA+/TLC engine) polylith 0.3.32 - A tool used to develop Polylith based architectures in Clojure. nrepl 1.5.2 - A Clojure network REPL that provides a server and client, along with some common APIs of use to IDEs and other tools that may need to evaluate Clojure code in remote environments. manifold 0.5.0 - A compatibility layer for event-driven abstractions"}, :excerpts [{:text "... Learning in Clojure with libpythonâ€‘clj: Using Bayesian...", :matched-terms ["machine learning"], :source :content} {:text "... Learning in Clojure with libpythonâ€‘clj: Unlocking Causal...", :matched-terms ["machine learning"], :source :content}]} {:rule-id "rule-ai", :item {:feed-id "planet-clojure", :item-id "https://blog.parenstech.com/2025-12-30-building-heretic.html", :title "Building Heretic: From ClojureStorm to Mutant Schemata", :link "https://blog.parenstech.com/2025-12-30-building-heretic.html", :published-at #inst "2025-12-30T23:59:59.000-00:00", :content "This is Part 2 of a series on mutation testing in Clojure. Part 1 introduced the concept and why Clojure needed a purpose-built tool. The previous post made a claim: mutation testing can be fast if you know which tests to run. This post shows how Heretic makes that happen. We&aposll walk through the three core phases: collecting expression-level coverage with ClojureStorm, transforming source code with rewrite-clj, and the optimization techniques that keep mutation counts manageable. Phase 1: Coverage Collection Traditional coverage tools track lines. Heretic tracks expressions. The difference matters. Consider: (defn process-order [order] (if (> (:quantity order) 10) (* (:price order) 0.9) ;; <- Line 3: bulk discount (:price order))) Line-level coverage would show line 3 as \"covered\" if any test enters the bulk discount branch. But expression-level coverage distinguishes between tests that evaluate *, (:price order), and 0.9. When we later mutate 0.9 to 1.1, we can run only the tests that actually touched that specific literal - not every test that happened to call process-order. ClojureStorm&aposs Instrumented Compiler ClojureStorm is a fork of the Clojure compiler that instruments every expression during compilation. Created by Juan Monetta for the FlowStorm debugger, it provides exactly the hooks Heretic needs. (Thanks to Juan for building such a solid foundation - Heretic would not exist without ClojureStorm.) The integration is surprisingly minimal: (ns heretic.tracer (:import [clojure.storm Emitter Tracer])) (def ^:private current-coverage \"Atom of {form-id #{coords}} for the currently running test.\" (atom {})) (defn record-hit! [form-id coord] (swap! current-coverage update form-id (fnil conj #{}) coord)) (defn init! [] ;; Configure what gets instrumented (Emitter/setInstrumentationEnable true) (Emitter/setFnReturnInstrumentationEnable true) (Emitter/setExprInstrumentationEnable true) ;; Set up callbacks (Tracer/setTraceFnsCallbacks {:trace-expr-fn (fn [_ _ coord form-id] (record-hit! form-id coord)) :trace-fn-return-fn (fn [_ _ coord form-id] (record-hit! form-id coord))})) When any instrumented expression evaluates, ClojureStorm calls our callback with two pieces of information: form-id: A unique identifier for the top-level form (e.g., an entire defn) coord: A path into the form&aposs AST, like \"3,2,1\" meaning \"third child, second child, first child\" Together, [form-id coord] pinpoints exactly which subexpression executed. This is the key that unlocks targeted test selection. The Coordinate System To connect a mutation in the source code to the coverage data, we need a way to uniquely address any subexpression. Think of it as a postal address for code - we need to say \"the a inside the + call inside the function body\" in a format that both the coverage tracer and mutation engine can agree on. ClojureStorm addresses this with a path-based coordinate system. Consider this function as a tree: (defn foo [a b] (+ a b)) â”‚ â”œâ”€[0] defn â”œâ”€[1] foo â”œâ”€[2] [a b] â””â”€[3] (+ a b) â”‚ â”œâ”€[3,0] + â”œâ”€[3,1] a â””â”€[3,2] b Each number represents which child to pick at each level. The coordinate \"3,2\" means \"go to child 3 (the function body), then child 2 (the second argument to +)\". That gives us the b symbol. This works cleanly for ordered structures like lists and vectors, where children have stable positions. But maps are unordered - {:name \"Alice\" :age 30} and {:age 30 :name \"Alice\"} are the same value, so numeric indices would be unstable. ClojureStorm solves this by hashing the printed representation of map keys. Instead of \"0\" for the first entry, a key like :name gets addressed as \"K-1925180523\": {:name \"Alice\" :age 30} â”‚ â”œâ”€[K-1925180523] :name â”œâ”€[V-1925180523] \"Alice\" â”œâ”€[K-1524292809] :age â””â”€[V-1524292809] 30 The hash ensures stable addressing regardless of iteration order. With this addressing scheme, we can say \"test X touched coordinate 3,1 in form 12345\" and later ask \"which tests touched the expression we&aposre about to mutate?\" The Form-Location Bridge Here&aposs a problem we discovered during implementation: how do we connect the mutation engine to the coverage data? The mutation engine uses rewrite-clj to parse and transform source files. It finds a mutation site at, say, line 42 of src/my/app.clj. But the coverage data is indexed by ClojureStorm&aposs form-id - an opaque identifier assigned during compilation. We need to translate \"file + line\" into \"form-id\". Fortunately, ClojureStorm&aposs FormRegistry stores the source file and starting line for each compiled form. We build a lookup index: (defn build-form-location-index [forms source-paths] (into {} (for [[form-id {:keys [form/file form/line]}] forms :when (and file line) :let [abs-path (resolve-path source-paths file)] :when abs-path] [[abs-path line] form-id]))) When the mutation engine finds a site at line 42, it searches for the form whose start line is the largest value less than or equal to 42 - that is, the innermost containing form. This gives us the ClojureStorm form-id, which we use to look up which tests touched that form. This bridging layer is what allows Heretic to connect source transformations to runtime coverage, enabling targeted test execution. Collection Workflow Coverage collection runs each test individually and captures what it touches: (defn run-test-with-coverage [test-var] (tracer/reset-current-coverage!) (try (test-var) (catch Throwable t (println \"Test threw exception:\" (.getMessage t)))) {(symbol test-var) (tracer/get-current-coverage)}) The result is a map from test symbol to coverage data: {my.app-test/test-addition {12345 #{\"3\" \"3,1\" \"3,2\"} ;; form-id -> coords touched 12346 #{\"1\" \"2,1\"}} my.app-test/test-subtraction {12345 #{\"3\" \"4\"} 12347 #{\"1\"}}} This gets persisted to .heretic/coverage/ with one file per test namespace, enabling incremental updates. Change a test file? Only that namespace gets recollected. At this point we have a complete map: for every test, we know exactly which [form-id coord] pairs it touched. Now we need to generate mutations and look up which tests are relevant for each one. Phase 2: The Mutation Engine With coverage data in hand, we need to actually mutate the code. This means: Parsing Clojure source into a navigable structure Finding locations where operators apply Transforming the source Hot-swapping the modified code into the running JVM Parsing with rewrite-clj rewrite-clj gives us a zipper over Clojure source that preserves whitespace and comments - essential for producing readable diffs: (defn parse-file [path] (z/of-file path {:track-position? true})) (defn find-mutation-sites [zloc] (->> (walk-form zloc) (remove in-quoted-form?) ;; Skip &apos(...) and `(...) (mapcat (fn [z] (let [applicable (ops/applicable-operators z)] (map #(make-mutation-site z %) applicable)))))) The walk-form function traverses the zipper depth-first. At each node, we check which operators match. An operator is a data map with a matcher predicate: (def swap-plus-minus {:id :swap-plus-minus :original &apos+ :replacement &apos- :description \"Replace + with -\" :matcher (fn [zloc] (and (= :token (z/tag zloc)) (symbol? (z/sexpr zloc)) (= &apos+ (z/sexpr zloc))))}) Each mutation site captures the file, line, column, operator, and - critically - the coordinate path within the form. This coordinate is what connects a mutation to the coverage data from Phase 1. Coordinate Mapping The tricky part is converting between rewrite-clj&aposs zipper positions and ClojureStorm&aposs coordinate strings. We need bidirectional conversion for the round-trip: (defn coord->zloc [zloc coord] (let [parts (parse-coord coord)] ;; \"3,2,1\" -> [3 2 1] (reduce (fn [z part] (when z (if (string? part) ;; Hash-based for maps/sets (find-by-hash z part) (nth-child z part)))) ;; Integer index for lists/vectors zloc parts))) (defn zloc->coord [zloc] (loop [z zloc coord []] (cond (root-form? z) (vec coord) (z/up z) (let [part (if (is-unordered-collection? z) (compute-hash-coord z) (child-index z))] (recur (z/up z) (cons part coord))) :else (vec coord)))) The validation requirement is that these must be inverses: (= coord (zloc->coord (coord->zloc zloc coord))) With correct coordinate mapping, we can take a mutation at a known location and ask \"which tests touched this exact spot?\" That query is what makes targeted test execution possible. Applying Mutations Once we find a mutation site and can navigate to it, the actual transformation is straightforward: (defn apply-mutation! [mutation] (let [{:keys [file form-id coord operator]} mutation operator-def (get ops/operators-by-id operator) original-content (slurp file) zloc (z/of-string original-content {:track-position? true}) form-zloc (find-form-by-id zloc form-id) target-zloc (coord/coord->zloc form-zloc coord) replacement-str (ops/apply-operator operator-def target-zloc) modified-zloc (z/replace target-zloc (n/token-node (symbol replacement-str))) modified-content (z/root-string modified-zloc)] (spit file modified-content) (assoc mutation :backup original-content))) Hot-Swapping with clj-reload After modifying the source file, we need the JVM to see the change. clj-reload handles this correctly: (ns heretic.reloader (:require [clj-reload.core :as reload])) (defn init! [source-paths] (reload/init {:dirs source-paths})) (defn reload-after-mutation! [] (reload/reload {:throw false})) Why clj-reload specifically? It solves problems that require :reload doesn&apost: Proper unloading: Calls remove-ns before reloading, preventing protocol/multimethod accumulation Dependency ordering: Topologically sorts namespaces, unloading dependents first Transitive closure: Automatically reloads namespaces that depend on the changed one The mutation workflow becomes: (with-mutation [m mutation] (reloader/reload-after-mutation!) (run-relevant-tests m)) ;; Mutation automatically reverted in finally block At this point we have the full pipeline: parse source, find mutation sites, apply a mutation, hot-reload, run targeted tests, restore. But running this once per mutation is still slow for large codebases. Phase 3 addresses that. 80+ Clojure-Specific Operators The operator library is where Heretic&aposs Clojure focus shows. Beyond the standard arithmetic and comparison swaps, we have: Threading operators - catch ->/->> confusion: (-> data (get :users) first) ;; Original (->> data (get :users) first) ;; Mutant: wrong arg position Nil-handling operators - expose nil punning mistakes: (when (seq users) ...) ;; Original: handles empty list (when users ...) ;; Mutant: breaks on empty list (truthy) Lazy/eager operators - catch chunking and realization bugs: (map process items) ;; Original: lazy (mapv process items) ;; Mutant: eager, different memory profile Destructuring operators - expose JSON interop issues: {:keys [user-id]} ;; Original: kebab-case {:keys [userId]} ;; Mutant: camelCase from JSON The full set includes first/last, rest/next, filter/remove, conj/disj, some->/->, and qualified keyword mutations. These are the mistakes Clojure developers actually make. With 80+ operators applied to a real codebase, mutation counts grow quickly. The next phase makes this tractable. Phase 3: Optimization Techniques With 80+ operators and a real codebase, mutation counts get large fast. A 1000-line project might generate 5000 mutations. Running the full test suite 5000 times is not practical. Heretic uses several techniques to make this manageable. Targeted Test Execution This is the big one, enabled by Phase 1. Instead of running all tests for every mutation, we query the coverage index: (defn tests-for-mutation [coverage-map mutation] (let [form-id (resolve-form-id (:form-location-index coverage-map) mutation) coord (:coord mutation)] (get-in coverage-map [:coord-to-tests [form-id coord]] #{}))) A mutation at (+ a b) might only be covered by 2 tests out of 200. We run those 2 tests in milliseconds instead of the full suite in seconds. This is where the Phase 1 coverage investment pays off. But we can go further by reducing the number of mutations we generate in the first place. Equivalent Mutation Detection Some mutations produce semantically identical code. Detecting these upfront avoids wasted test runs: ;; (* x 0) -> (/ x 0) is NOT equivalent (divide by zero) ;; (* x 1) -> (/ x 1) IS equivalent (both return x) (def equivalent-patterns [{:operator :swap-mult-div :context (fn [zloc] (some #(= 1 %) (rest (z/child-sexprs (z/up zloc))))) :reason \"Multiplying or dividing by one has no effect\"} {:operator :swap-lt-lte :context (fn [zloc] (let [[_ left right] (z/child-sexprs (z/up zloc))] (and (= 0 right) (non-negative-fn? (first left))))) :reason \"(< (count x) 0) is always false\"}]) The patterns cover boundary comparisons ((>= (count x) 0) is always true), function contracts ((nil? (str x)) is always false), and lazy/eager equivalences ((vec (map f xs)) equals (vec (mapv f xs))). Filtering equivalent mutations prevents false \"survived\" reports. But we can also skip mutations that would be redundant to test. Subsumption Analysis Subsumption identifies when killing one mutation implies another would also be killed. If swapping < to <= is caught by a test, then swapping < to > would likely be caught too. Based on the RORG (Relational Operator Replacement with Guard) research, we define subsumption relationships: (def relational-operator-subsumption {&apos< [:swap-lt-lte :swap-lt-neq :replace-comparison-false] &apos> [:swap-gt-gte :swap-gt-neq :replace-comparison-false] &apos<= [:swap-lte-lt :swap-lte-eq :replace-comparison-true] ;; ... }) For each comparison operator, we only need to test the minimal set. The research shows this achieves roughly the same fault detection with 40% fewer mutations. The subsumption graph also enables intelligent mutation selection: (defn minimal-operator-set [operators] (set/difference operators ;; Remove any operator dominated by another in the set (reduce (fn [dominated op] (into dominated (set/intersection (dominated-operators op) operators))) #{} operators))) These techniques reduce mutation count. The final optimization reduces the cost of each mutation. Mutant Schemata: Compile Once, Select at Runtime The most sophisticated optimization is mutant schemata. Instead of applying one mutation, reloading, testing, reverting, reloading for each mutation, we embed multiple mutations into a single compilation: ;; Original (defn calculate [x] (+ x 1)) ;; Schematized (with 3 mutations) (defn calculate [x] (case heretic.schemata/*active-mutant* :mut-42-5-plus-minus (- x 1) :mut-42-5-1-to-0 (+ x 0) :mut-42-5-1-to-2 (+ x 2) (+ x 1))) ;; original (default) We reload once, then switch between mutations by binding a dynamic var: (def ^:dynamic *active-mutant* nil) (defmacro with-mutant [mutation-id & body] `(binding [*active-mutant* ~mutation-id] ~@body)) The workflow becomes: (defn run-mutation-batch [file mutations test-fn] (let [schemata-info (schematize-file! file mutations)] (try (reload!) ;; Once! (doseq [[id mutation] (:mutation-map schemata-info)] (with-mutant id (test-fn id mutation))) (finally (restore-file! schemata-info) (reload!))))) ;; Once! For a file with 50 mutations, this means 2 reloads instead of 100. The overhead of case dispatch at runtime is negligible compared to compilation cost. Operator Presets Finally, we offer presets that trade thoroughness for speed: (def presets {:fast #{:swap-plus-minus :swap-minus-plus :swap-lt-gt :swap-gt-lt :swap-and-or :swap-or-and :swap-nil-some :swap-some-nil} :minimal minimal-preset-operators ;; Subsumption-aware :standard #{;; :fast plus... :swap-first-last :swap-rest-next :swap-thread-first-last} :comprehensive (set (map :id all-operators))}) The :fast preset uses ~15 operators that research shows catch roughly 99% of bugs. The :minimal preset uses subsumption analysis to eliminate redundant mutations. Both run much faster than :comprehensive while maintaining detection power. Putting It Together A mutation testing run with Heretic looks like: Collect coverage (once, cached): Run tests under ClojureStorm instrumentation, build expression-level coverage map Generate mutations: Parse source files, find all applicable operator sites Filter: Remove equivalent mutations, apply subsumption to reduce set Group by file: Prepare for schemata optimization For each file: Build schematized source with all mutations Reload once For each mutation: bind *active-mutant*, run targeted tests Restore and reload Report: Mutation score, surviving mutations, test effectiveness The result is mutation testing that runs in seconds for typical projects instead of hours. This covers the core implementation. A future post will explore Phase 4: AI-powered semantic mutations and hybrid equivalent detection - using LLMs to generate the subtle, domain-aware mutations that traditional operators miss. Previously: Part 1 - Heretic: Mutation Testing in Clojure"}, :excerpts []} {:rule-id "editor-wars", :item {:feed-id "planet-clojure", :item-id "https://clojure.org/news/2025/12/23/deref", :title "Clojure Deref (Dec 23, 2025)", :link "https://clojure.org/news/2025/12/23/deref", :published-at #inst "2025-12-23T00:00:00.000-00:00", :content "Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed: RSS). The annual Clojure surveys are live Help shape the future of Clojure! Whether you use Clojure, ClojureScript, Babashka, or any other Clojure dialect, please fill out the 2025 State of Clojure Survey and spread the word on social media. This survey gives us the best snapshot of the Clojure community, so help us get as many participants as possible. If you use ClojureScript or dialects like Squint, Cherry, nbb, and such, please fill out the 2025 State of ClojureScript Survey and share it with others. Thank you for your help! Upcoming Events Clojure real-world-data 38: Dec 26 Scicloj AI Meetup: Agent-o-rama: Jan 17 Clojure Jam 2026: Apr 18-19 & 25-26. Online & free! CFP is open until Jan 31st. Babashka Conf: May 8. Amsterdam, NL. Free registration, but tickets are limited! Dutch Clojure Days 2026: May 9th. Amsterdam, NL. Join the waitlist, or the CFP is open until Jan 15th. Podcasts, videos, and media One year of building my own IDE in clojure - phronmophobic Event-sourcing with projections in Clojure and PostgreSQL - Andrey Fadeev Announcing Multi REPL Sessions in Calva - CalvaTV Clojure/Conj 2025 Photos A Decade on Datomic - Davis Shepherd & Jonathan Indig (Netflix) - ClojureTV UnifyBio: Power Tools for Translational Data Science - Benjamin Kamphaus - ClojureTV Cats, Dogs, and Python - Paula Gearon - ClojureTV Agent-o-rama: Scalable, Traceable, Stateful AI agents in Pure Clojure or Java - Nathan Marz - ClojureTV Clojure South 2025 Construindo aplicaÃ§Ãµes web elegantes com ClojureScript, React e UIx! | Clojure South 2025 - Building Nubank Fail fast, fix faster: Injecting failures on integration tests | Clojure South 2025 - Building Nubank Clojure to Elixir: Functional Programming for Scalable & Sustainable Apps | Clojure South 2025 - Building Nubank Clojure e IA: Construindo Agentes Inteligentes sem Reinventar a Roda | Clojure South 2025 - Building Nubank Introduzindo programaÃ§Ã£o funcional na Carteira Digital de TrÃ¢nsito | Clojure South 2025 - Building Nubank NuFileBox Reverse: GestÃ£o segura de arquivos com Clojure | Clojure South 2025 - Building Nubank Uma estratÃ©gia incremental com apoio IA para testes unitÃ¡rios em Clojure | Clojure South 2025 - Building Nubank Betting on open source: Adventures with Datahike | Clojure South 2025 - Building Nubank 12 years of Component | Clojure South 2025 - Building Nubank Blogs, articles, and news A Christmas Present in Clojure â€“ Metosin - Joel Kaasinen Clerk notebooks with solutions for Advent of Code 2025 - Miran Clojurists Together 2026 Annual Funding Announcement - Kathy Davis Announcing Oak 1.0 - Arne Brasseur Easel Turns One! - Adrian Smith (recur thoughts \"Nullable pattern: Experience report\") - Emil Bengtsson Machine Learning in Clojure with libpython-clj: Bridging Functional Elegance and Pythonâ€™s ML Power [Series 1] - Flexiana - Jiri Knesl The Best Things and Stuff of 2025 - Michael Fogus An incremental strategy with AI support for unit testing in Clojure - Building Nubank - Nubank Editorial How NuFilebox Reverse strengthens file security at Nubank - Building Nubank - Nubank Editorial 12 years of Component: A decade of interactive development - Building Nubank - Nubank Editorial Building elegant interfaces with ClojureScript, React, and UIx - Building Nubank - Nubank Editorial Libraries and Tools Debut release cljs-uix-electron - Uix + Electron starter cljs-uix-wails - Wails + ClojureScript starter Oak - Oak is a Free and Open Source Identity Provider that you can host yourself immersa - Open Source Web-based 3D Presentation Tool bb-timemachine - Run code back in Git-time. solid-cljs - ClojureScript bindings to Solid clojars-download-stats - An always up-to-date, complete SQL export of artifacts daily downloads since November 2012 malt - Malli-Typed interfaces for Clojure distributed-scope - Run one lexical scope across distributed peers. Updates repath-studio 0.4.11 - A local web-based vector graphics editor that combines procedural tooling with traditional design workflows. dtype-next 10.000-beta-11 - A Clojure library designed to aid in the implementation of high performance algorithms and systems. repl-mcp d00f661 - Model Context Protocol Clojure support including REPL integration with development tools. virtuoso 0.1.2 - A number of trivial wrappers on top of virtual threads bbin 0.2.5 - Install any Babashka script or project with one command stripe-clojure 2.1.0 - Clojure SDK for the Stripe API. muutos 2025-12-18 - Muutos is a zero-dependency Clojure library for reacting to changes in a PostgreSQL database. cherry 0.5.34 - Experimental ClojureScript to ES6 module compiler nbb 1.3.205 - Scripting in Clojure on Node.js using SCI replicant 2025.12.1 - A data-driven rendering library for Clojure(Script) that renders hiccup to DOM or to strings. joyride 0.0.72 - Making VS Code Hackable like Emacs since 2022 process 0.6.25 - Clojure library for shelling out / spawning sub-processes fireworks 0.19.0 - Fireworks is a themeable tapping library for Clojure, ClojureScript, and Babashka. bling 0.9.2 - Rich text console printing for Clojure, ClojureScript, and Babashka. clj-kondo 2025.12.23 - Static analyzer and linter for Clojure code that sparks joy calva 2.0.543 - Clojure & ClojureScript Interactive Programming for VS Code sci 0.11.50 - Configurable Clojure/Script interpreter suitable for scripting and Clojure DSLs scittle 0.7.30 - Execute Clojure(Script) directly from browser script tags via SCI partial-cps 0.1.42 - A lean and efficient continuation passing style transform, includes async-await support."}, :excerpts []} {:rule-id "editor-wars", :item {:feed-id "planet-clojure", :item-id "tag:blogger.com,1999:blog-1409352204799783992.post-1198041635414991858", :title "Joyful Python with the REPL", :link "https://davidvujic.blogspot.com/2022/08/joyful-python-with-repl.html", :published-at #inst "2026-01-03T20:25:31.000-00:00", :content "REPL Driven Development is a workflow that makes coding both joyful and interactive. The feedback loop from the REPL is a great thing to have at your fingertips. \"If you can improve just one thing in your software development, make it getting faster feedback.\" Dave Farley Just like Test Driven Development (TDD), it will help you write testable code. I have also noticed a nice side effect from this workflow: REPL Driven Development encourages a functional programming style. REPL Driven Development is an everyday thing among Clojure developers and doable in Python, but far less known here. I'm working on making it an everyday thing in Python development too. But what is REPL Driven Development? What is it? You evaluate variables, code blocks, functions - or an entire module - and get instant feedback, just by a hitting a key combination in your favorite code editor. There's no reason to leave the IDE for a less featured shell to accomplish all of that. You already have autocomplete, syntax highlighting and the color theme set up in your editor. Why not use that, instead of a shell? Evaluate code and get feedback, without leaving the code editor. Ideally, the result of an evaluation pops up right next to the cursor, so you don't have to do any context switches or lose focus. It can also be printed out in a separate frame right next to the code. This means that testing the code you currently write is at your fingertips. Easy setup With some help from IPython, it is possible to write, modify & evaluate Python code in a REPL Driven way. I would recommend to install IPython globally, to make it accessible from anywhere on your machine. pip install ipython Configure IPython to make it ready for REPL Driven Development: c.InteractiveShellApp.exec_lines = [\"%autoreload 2\"] c.InteractiveShellApp.extensions = [\"autoreload\"] c.TerminalInteractiveShell.confirm_exit = False You will probably find the configuration file here: ~/.ipython/profile_default/ipython_config.py You are almost all set. Emacs setup Emacs is my favorite editor. I'm using a couple of Python specific packages to make life as a Python developer in general better, such as elpy. The auto-virtualenv package will also help out making REPL Driven Developer easier. It will find local virtual environments automatically and you can start coding without any python-path quirks. Most importantly, set IPython as the default shell in Emacs. Have a look at my Emacs setup for the details. VS Code setup I am not a VS Code user. But I wanted to learn how well supported REPL Driven Development is in VS Code, so I added these extensions: You would probably want to add keyboard shortcuts to get the true interactive feel of it. Here, I'm just trying things out by selecting code, right clicking and running it in an interactive window. It seems to work pretty well! I haven't figured out if the interactive window is picking up the global IPython config yet, or if it already refreshes a submodule when updated. Evaluating code in the editor with fast feedback loops. It would be great to have keyboard commands here, though. Current limitations In Clojure, you connect to & modify an actually running program by re-evaluating the source code. That is a wonderful thing for the developer experience in general. I haven't been able to do that with Python, and believe Python would need something equivalent to NRepl to get that kind of magic powers. Better than TDD I practice REPL Driven Development in my daily Python work. For me, it has become a way to quickly verify if the code I currently write is working as expected. I usually think of this REPL driven thing as Test Driven Development Deluxe. Besides just evaluating the code, I often write short-lived code snippets to test out some functionality. By doing that, I can write code and test it interactively. Sometimes, these code snippets are converted permanent unit tests. For a live demo, have a look at my five minute lightning talk from PyCon Sweden about REPL Driven Development in Python. Never too late to learn I remember it took me almost a year learning & developing Clojure before I actually \"got it\". Before that, I sometimes copied some code and pasted it into a REPL and then ran it. But that didn't give me a nice developer experience at all. Copy-pasting code is cumbersome and will often fail because of missing variables, functions or imports. Don't do that. I remember the feeling when figuring out the REPL Driven Development workflow, I finally had understood how software development should be done. It took me about 20 years to get there. It is never too late to learn new things. ðŸ˜ Top photo by ckturistando on Unsplash"}, :excerpts [{:text "... hitting a key combination in your favorite code editor. There's no reason to leave the IDE for a less...", :matched-terms ["editor"], :source :content} {:text "... highlighting and the color theme set up in your editor. Why not use that, instead of a shell? ...", :matched-terms ["editor"], :source :content} {:text "... code and get feedback, without leaving the code editor. Ideally, the result of...", :matched-terms ["editor"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://clojure-diary.gitlab.io/2026/01/01/rswan-1-1-0-and-other-clojure-updates", :title "rswan 1.1.0, and other Clojure updates", :link "https://clojure-diary.gitlab.io/2026/01/01/rswan-1-1-0-and-other-clojure-updates.html", :published-at #inst "2026-01-01T12:50:00.000-00:00", :content "Notes rswam 1.1.0-PRE https://codeberg.org/mindaslab/rswan About setting repo :repositories [[\"clojars\" {:url \"https://clojars.org/org.clojars.mindaslab.rswan\" :sign-releases false}] caused to due Java + Clojure upgrade, which resulted in diff nrepl versions Try rswan - demo Why clj is not recognized as Clojure in Logseq? job Weird $0 Some equity if things go right not sure Anyone wants any Clojure help? Want to learn more Need not be paid If paid, will be really happy"}, :excerpts [{:text "rswan 1.1.0, and other Clojure updates", :matched-terms ["clojure"], :source :title} {:text "...", :matched-terms ["clojure"], :source :content} {:text "... caused to due Java + Clojure upgrade, which resulted in diff nrepl versions", :matched-terms ["java" "clojure" "repl"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://blog.michielborkent.nl/oss-updates-nov-dec-2025.html", :title "OSS updates November and December 2025", :link "https://blog.michielborkent.nl/oss-updates-nov-dec-2025.html", :published-at #inst "2026-01-01T23:59:59.000-00:00", :content "In this post I&aposll give updates about open source I worked on during November and December 2025. To see previous OSS updates, go here. Sponsors I&aposd like to thank all the sponsors and contributors that make this work possible. Without you, the below projects would not be as mature or wouldn&apost exist or be maintained at all! So a sincere thank you to everyone who contributes to the sustainability of these projects. Current top tier sponsors: Clojurists Together Roam Research Nextjournal Nubank Open the details section for more info about sponsoring. Sponsor info If you want to ensure that the projects I work on are sustainably maintained, you can sponsor this work in the following ways. Thank you! Github Sponsors The Babashka or Clj-kondo OpenCollective Ko-fi Patreon Clojurists Together Updates Clojure Conj 2025 Last November I had the honor and pleasure to visit the Clojure Conj 2025. I met a host of wonderful and interesting long-time and new Clojurians, many that I&aposve known online for a long time and now met for the first time. It was especially exciting to finally meet Rich Hickey and talk to him during a meeting about Clojure dialects and Clojure tooling. The talk that I gave there: \"Making tools developers actually use\" will come online soon. Babashka conf and Dutch Clojure Days 2026 In 2026 I&aposm organizing Babashka Conf 2026. It will be an afternoon event (13:00-17:00) hosted in the Forum hall of the beautiful public library of Amsterdam. More information here. Get your ticket via Meetup.com (currently there&aposs a waiting list, but more places will come available once speakers are confirmed). CfP will open mid January. The day after babashka conf, Dutch Clojure Days 2026 will be happening. It&aposs not too late to get your talk proposal in. More info here. Projects Here are updates about the projects/libraries I&aposve worked on in the last two months in detail. babashka: native, fast starting Clojure interpreter for scripting. Bump process to 0.6.25 Bump deps.clj Fix #1901: add java.security.DigestOutputStream Redefining namespace with ns should override metadata Bump nextjournal.markdown to 0.7.222 Bump edamame to 1.5.37 Fix #1899: with-meta followed by dissoc on records no longer works Bump fs to 0.5.30 Bump nextjournal.markdown to 0.7.213 Fix #1882: support for reifying java.time.temporal.TemporalField (@EvenMoreIrrelevance) Bump Selmer to 1.12.65 SCI: sci.impl.Reflector was rewritten into Clojure dissoc on record with non-record field should return map instead of record Bump edamame to 1.5.35 Bump core.rrb-vector to 0.2.0 Migrate detecting of executable name for self-executing uberjar executable from ProcessHandle to to native image ProcessInfo to avoid sandbox errors Bump cli to 0.8.67 Bump fs to 0.5.29 Bump nextjournal.markdown to 0.7.201 SCI: Configurable Clojure/Script interpreter suitable for scripting Add support for :refer-global and :require-global Add println-str Fix #997: Var is mistaken for local when used under the same name in a let body Fix #1001: JS interop with reserved js keyword fails (regression of #987) sci.impl.Reflector was rewritten into Clojure Fix babashka/babashka#1886: Return a map when dissociating a record basis field. Fix #1011: reset ns metadata when evaluating ns form multiple times Fix for https://github.com/babashka/babashka/issues/1899 Fix #1010: add js-in in CLJS Add array-seq clj-kondo: static analyzer and linter for Clojure code that sparks joy. #2600: NEW linter: unused-excluded-var to warn on unused vars in :refer-clojure :exclude (@jramosg) #2459: NEW linter: :destructured-or-always-evaluates to warn on s-expressions in :or defaults in map destructuring (@jramosg) Add type checking support for sorted-map-by, sorted-set, and sorted-set-by functions (@jramosg) Add new type array and type checking support for the next functions: to-array, alength, aget, aset and aclone (@jramosg) Fix #2695: false positive :unquote-not-syntax-quoted in leiningen&aposs defproject Leiningen&aposs defproject behavior can now be configured using leiningen.core.project/defproject Fix #2699: fix false positive unresolved string var with extend-type on CLJS Rename :refer-clojure-exclude-unresolved-var linter to unresolved-excluded-var for consistency v2025.12.23 #2654: NEW linter: redundant-let-binding, defaults to :off (@tomdl89) #2653: NEW linter: :unquote-not-syntax-quoted to warn on ~ and ~@ usage outside syntax-quote (`) (@jramosg) #2613: NEW linter: :refer-clojure-exclude-unresolved-var to warn on non-existing vars in :refer-clojure :exclude (@jramosg) #2668: Lint & syntax errors in let bindings and lint for trailing & (@tomdl89) #2590: duplicate-key-in-assoc changed to duplicate-key-args, and now lints dissoc, assoc! and dissoc! too (@tomdl89) #2651: resume linting after paren mismatches clojure-lsp#2651: Fix inner class name for java-class-definitions. clojure-lsp#2651: Include inner class java-class-definition analysis. Bump babashka/fs #2532: Disable :duplicate-require in require + :reload / :reload-all #2432: Don&apost warn for :redundant-fn-wrapper in case of inlined function #2599: detect invalid arity for invoking collection as higher order function #2661: Fix false positive :unexpected-recur when recur is used inside clojure.core.match/match (@jramosg) #2617: Add types for repeatedly (@jramosg) Add :ratio type support for numerator and denominator functions (@jramosg) #2676: Report unresolved namespace for namespaced maps with unknown aliases (@jramosg) #2683: data argument of ex-info may be nil since clojure 1.12 Bump built-in ClojureScript analysis info Fix #2687: support new :refer-global and :require-global ns options in CLJS Fix #2554: support inline configs in .cljc files edamame: configurable EDN and Clojure parser with location metadata and more Edamame: configurable EDN and Clojure parser with location metadata and more Minor: leave out :edamame/read-cond-splicing when not splicing Allow :read-cond function to override :edamame/read-cond-splicing value The result from :read-cond with a function should be spliced. This behavior differs from :read-cond + :preserve which always returns a reader conditional object which cannot be spliced. Support function for :features option to just select the first feature that occurs squint: CLJS syntax to JS compiler Allow macro namespaces to load \"node:fs\", etc. to read config files for conditional compilation Don&apost emit IIFE for top-level let so you can write let over defn to capture values. Fix js-yield and js-yield* in expression position Implement some? as macro Fix #758: volatile!, vswap!, vreset! pr-str, prn etc now print EDN (with the idea that you can paste it back into your program) new #js/Map reader that reads a JavaScript Map from a Clojure map (maps are printed like this with pr-str too) Support passing keyword to mapv #759: doseq can&apost be used in expression context Fix #753: optimize output of dotimes alength as macro reagami: A minimal zero-deps Reagent-like for Squint and CLJS Performance enhancements treat innerHTML as a property rather than an attribute Drop support for camelCased properties / (css) attributes Fix :default-value in input range Support data param in :on-render Support default values for uncontrolled components Fix child count mismatch Fix re-rendering/patching of subroots Add :on-render hook for mounting/updating/unmounting third part JS components NEW: parmezan: fixes unbalanced or unexpected parens or other delimiters in Clojure files CLI: Turn Clojure functions into CLIs! #126: - value accidentally parsed as option, e.g. --file - #124: Specifying exec fn that starts with hyphen is treated as option Drop Clojure 1.9 support. Minimum Clojure version is now 1.10.3. clerk: Moldable Live Programming for Clojure always analyze doc (but not deps) when no-cache is set (#786) add option to disable inline formulas in markdown (#780) scittle: Execute Clojure(Script) directly from browser script tags via SCI #114: Enable source maps (@jeroenvandijk) #140: Enable customizing the nrepl websocket port (@PEZ) Bump shadow-cljs and SCI Nextjournal Markdown Add config option to avoid TeX formulas API improvements for passing options cherry: Experimental ClojureScript to ES6 module compiler Fix cherry compile CLI command not receiving file arguments Bump shadow-cljs to 3.3.4 Fix #163: Add assert to macros (@willcohen) Fix #165: Fix ClojureScript protocol dispatch functions (@willcohen) Fix #167: Protocol dispatch functions inside IIFEs; bump squint accordingly Fix #169: fix extend-type on Object Fix #171: Add satisfies? macro (@willcohen) deps.clj: A faithful port of the clojure CLI bash script to Clojure Released several versions catching up with the clojure CLI quickdoc: Quick and minimal API doc generation for Clojure Fix extra newline in codeblock quickblog: light-weight static blog engine for Clojure and babashka Add support for a blog contained within another website; see Serving an alternate content root in README. (@jmglov) Upgrade babashka/http-server to 0.1.14 Fix :blog-image-alt option being ignored when using CLI (bb quickblog render) nbb: Scripting in Clojure on Node.js using SCI #395: fix vim-fireplace infinite loop on nREPL session close. Add ILookup and Cons Add abs nREPL: support \"completions\" op neil: A CLI to add common aliases and features to deps.edn-based projects. neil.el - a hook that runs after finding a package (@agzam) neil.el - adds a function for injecting a found package into current CIDER session (@agzam) #245: neil.el - neil-executable-path now can be set to clj -M:neil #251: Upgrade library deps-new to 0.10.3 #255: update maven search URL fs - File system utility library for Clojure #154 reflect in directory check and docs that move never follows symbolic links (@lread) #181 delete-tree now deletes broken symbolic link root (@lread) #193 create-dirs now recognizes sym-linked dirs on JDK 11 (@lread) #184: new check in copy-tree for copying to self too rigid #165: zip now excludes zip-file from zip-file (@lread) #167: add root fn which exposes Path getRoot (@lread) #166: copy-tree now fails fast on attempt to copy parent to child (@lread) #152: an empty-string path \"\" is now (typically) understood to be the current working directory (as per underlying JDK file APIs) (@lread) #155: fs/with-temp-dir clj-kondo linting refinements (@lread) #162: unixify no longer expands into absolute path on Windows (potentially BREAKING) Add return type hint to read-all-bytes process: Clojure library for shelling out / spawning sub-processes #181: support :discard or ProcessBuilder$Redirect as :out and :err options Contributions to third party projects: ClojureScript CLJS-3466: support qualified method in return position CLJS-3468: :refer-global should not make unrenamed object available Other projects These are (some of the) other projects I&aposm involved with but little to no activity happened in the past month. Click for more details - [pod-babashka-go-sqlite3](https://github.com/babashka/pod-babashka-go-sqlite3): A babashka pod for interacting with sqlite3 - [unused-deps](https://github.com/borkdude/unused-deps): Find unused deps in a clojure project - [pod-babashka-fswatcher](https://github.com/babashka/pod-babashka-fswatcher): babashka filewatcher pod - [sci.nrepl](https://github.com/babashka/sci.nrepl): nREPL server for SCI projects that run in the browser - [babashka.nrepl-client](https://github.com/babashka/nrepl-client) - [http-server](https://github.com/babashka/http-server): serve static assets - [nbb](https://github.com/babashka/nbb): Scripting in Clojure on Node.js using SCI - [sci.configs](https://github.com/babashka/sci.configs): A collection of ready to be used SCI configs. - [http-client](https://github.com/babashka/http-client): babashka's http-client - [html](https://github.com/borkdude/html): Html generation library inspired by squint's html tag - [instaparse-bb](https://github.com/babashka/instaparse-bb): Use instaparse from babashka - [sql pods](https://github.com/babashka/babashka-sql-pods): babashka pods for SQL databases - [rewrite-edn](https://github.com/borkdude/rewrite-edn): Utility lib on top of - [rewrite-clj](https://github.com/clj-commons/rewrite-clj): Rewrite Clojure code and edn - [tools-deps-native](https://github.com/babashka/tools-deps-native) and [tools.bbuild](https://github.com/babashka/tools.bbuild): use tools.deps directly from babashka - [bbin](https://github.com/babashka/bbin): Install any Babashka script or project with one command - [qualify-methods](https://github.com/borkdude/qualify-methods) - Initial release of experimental tool to rewrite instance calls to use fully qualified methods (Clojure 1.12 only) - [tools](https://github.com/borkdude/tools): a set of [bbin](https://github.com/babashka/bbin/) installable scripts - [babashka.json](https://github.com/babashka/json): babashka JSON library/adapter - [speculative](https://github.com/borkdude/speculative) - [squint-macros](https://github.com/squint-cljs/squint-macros): a couple of macros that stand-in for [applied-science/js-interop](https://github.com/applied-science/js-interop) and [promesa](https://github.com/funcool/promesa) to make CLJS projects compatible with squint and/or cherry. - [grasp](https://github.com/borkdude/grasp): Grep Clojure code using clojure.spec regexes - [lein-clj-kondo](https://github.com/clj-kondo/lein-clj-kondo): a leiningen plugin for clj-kondo - [http-kit](https://github.com/http-kit/http-kit): Simple, high-performance event-driven HTTP client+server for Clojure. - [babashka.nrepl](https://github.com/babashka/babashka.nrepl): The nREPL server from babashka as a library, so it can be used from other SCI-based CLIs - [jet](https://github.com/borkdude/jet): CLI to transform between JSON, EDN, YAML and Transit using Clojure - [lein2deps](https://github.com/borkdude/lein2deps): leiningen to deps.edn converter - [cljs-showcase](https://github.com/borkdude/cljs-showcase): Showcase CLJS libs using SCI - [babashka.book](https://github.com/babashka/book): Babashka manual - [pod-babashka-buddy](https://github.com/babashka/pod-babashka-buddy): A pod around buddy core (Cryptographic Api for Clojure). - [gh-release-artifact](https://github.com/borkdude/gh-release-artifact): Upload artifacts to Github releases idempotently - [carve](https://github.com/borkdude/carve) - Remove unused Clojure vars - [4ever-clojure](https://github.com/oxalorg/4ever-clojure) - Pure CLJS version of 4clojure, meant to run forever! - [pod-babashka-lanterna](https://github.com/babashka/pod-babashka-lanterna): Interact with clojure-lanterna from babashka - [joyride](https://github.com/BetterThanTomorrow/joyride): VSCode CLJS scripting and REPL (via [SCI](https://github.com/babashka/sci)) - [clj2el](https://borkdude.github.io/clj2el/): transpile Clojure to elisp - [deflet](https://github.com/borkdude/deflet): make let-expressions REPL-friendly! - [deps.add-lib](https://github.com/borkdude/deps.add-lib): Clojure 1.12's add-lib feature for leiningen and/or other environments without a specific version of the clojure CLI"}, :excerpts [{:text "... id=\"updates\">Updates Clojure Conj 2025 Last November I had the honor and pleasure to visit the Clojure Conj 2025. I met a host of wonderful and...", :matched-terms ["clojure"], :source :content} {:text "... Hickey and talk to him during a meeting about Clojure dialects and Clojure tooling. The talk that I gave there: \"Making...", :matched-terms ["clojure"], :source :content} {:text "... align=\"center\" alt=\"presentation at Dutch Clojure meetup\"...", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://tengstrand.github.io/blog/2025-12-28-tetris-playing-ai-the-polylith-way-1.html", :title "Tetris-playing AI the Polylith way - Part 1", :link "https://tengstrand.github.io/blog/2025-12-28-tetris-playing-ai-the-polylith-way-1.html", :published-at #inst "2025-12-28T23:59:59.000-00:00", :content "In this blog series, I will show how to work with the Polylith architecture and how organizing code into components helps create a good structure for high-level functional style programming. You might feel that organizing into components is unnecessary, and yes, for a tiny codebase like this I would agree. It&aposs still easy to reason about the code and keep everything in mind, but as the codebase grows, so does the value of this structure, in terms of better overview, clearer system boundaries, and increased flexibility in how these building blocks can be combined into various systems. We will get familiar with this by implementing a self-playing Tetris program in Clojure and Python while reflecting on the differences between the two languages. The goal The task for this first post is to place a T piece on a Tetris board (represented by a two-dimensional array): [[0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,T,0,0,0] [0,0,0,0,0,T,T,T,0,0]] We will put the code in the piece and board components in a Polylith workspace (output from the info command): This will not be a complete guide to Polylith, Clojure, or Python, but I will explain the most important parts and refer to relevant documentation when needed. The resulting source code from this first blog post in the series can be found here: The Clojure workspace The Python workspace Workspace We begin by installing the poly command line tool for Clojure, which we will use when working with the Polylith codebase: brew install polyfy/polylith/poly The next step is to create a Polylith workspace: poly create workspace name:tetris-polylith top-ns:tetrisanalyzer We now have a standard Polylith workspace for Clojure in place: â–¾ tetris-polylith â–¸ bases â–¸ components â–¸ development â–¸ projects deps.edn workspace.edn Python We will use uv as package manager for Python (see setup for other alternatives). First we install uv: curl -LsSf https://astral.sh/uv/install.sh | sh Then we create the tetris-polylith-uv workspace directory, by executing: uv init tetris-polylith-uv cd tetris-polylith-uv uv add polylith-cli --dev uv sync which creates: README.md main.py pyproject.toml uv.lock Finally we create the standard Polylith workspace structure: uv run poly create workspace --name tetrisanalyzer --theme loose which adds: â–¾ tetris-polylith-uv â–¸ bases â–¸ components â–¸ development â–¸ projects workspace.toml The workspace requires some additional manual steps, documented here. The piece component Now we are ready to create our first component for the Clojure codebase: poly create component name:piece This adds the piece component to the workspace structure: â–¾ components â–¾ piece â–¾ src â–¾ tetrisanalyzer â–¾ piece interface.clj core.clj â–¾ test â–¾ tetrisanalyzer â–¾ piece interface-test.clj If you have used Polylith with Clojure before, you know that you also need to manually add piece to deps.edn, which is described here. Python Let&aposs do the same for Python: uv run poly create component --name piece This adds the piece component to the structure: â–¾ components â–¾ tetrisanalyzer â–¾ piece __init__.py core.py â–¾ test â–¾ components â–¾ tetrisanalyzer â–¾ piece __init__.py test_core.py Piece shapes In Tetris, there are 7 different pieces that can be rotated, summing up to 19 shapes: Here we will store them in a multi-dimensional array where each possible piece shape is made up of four [x,y] cells, with [0,0] representing the upper left corner. For example the Z piece in its inital position (rotation 0) consists of the cells [0,0] [1,0] [1,1] [2,1]: This is how it looks like in Clojure (commas are treated as white spaces in Clojure and are often omitted): (ns tetrisanalyzer.piece.piece) (def pieces [nil ;; I (1) [[[0 0] [1 0] [2 0] [3 0]] [[0 0] [0 1] [0 2] [0 3]]] ;; Z (2) [[[0 0] [1 0] [1 1] [2 1]] [[1 0] [0 1] [1 1] [0 2]]] ;; S (3) [[[1 0] [2 0] [0 1] [1 1]] [[0 0] [0 1] [1 1] [1 2]]] ;; J (4) [[[0 0] [1 0] [2 0] [2 1]] [[0 0] [1 0] [0 1] [0 2]] [[0 0] [0 1] [1 1] [2 1]] [[1 0] [1 1] [0 2] [1 2]]] ;; L (5) [[[0 0] [1 0] [2 0] [0 1]] [[0 0] [0 1] [0 2] [1 2]] [[2 0] [0 1] [1 1] [2 1]] [[0 0] [1 0] [1 1] [1 2]]] ;; T (6) [[[0 0] [1 0] [2 0] [1 1]] [[0 0] [0 1] [1 1] [0 2]] [[1 0] [0 1] [1 1] [2 1]] [[1 0] [0 1] [1 1] [1 2]]] ;; O (7) [[[0 0] [1 0] [0 1] [1 1]]]]) Python Here is how it looks in Python: pieces = [None, # I (1) [[[0, 0], [1, 0], [2, 0], [3, 0]], [[0, 0], [0, 1], [0, 2], [0, 3]]], # Z (2) [[[0, 0], [1, 0], [1, 1], [2, 1]], [[1, 0], [0, 1], [1, 1], [0, 2]]], # S (3) [[[1, 0], [2, 0], [0, 1], [1, 1]], [[0, 0], [0, 1], [1, 1], [1, 2]]], # J (4) [[[0, 0], [1, 0], [2, 0], [2, 1]], [[0, 0], [1, 0], [0, 1], [0, 2]], [[0, 0], [0, 1], [1, 1], [2, 1]], [[1, 0], [1, 1], [0, 2], [1, 2]]], # L (5) [[[0, 0], [1, 0], [2, 0], [0, 1]], [[0, 0], [0, 1], [0, 2], [1, 2]], [[2, 0], [0, 1], [1, 1], [2, 1]], [[0, 0], [1, 0], [1, 1], [1, 2]]], # T (6) [[[0, 0], [1, 0], [2, 0], [1, 1]], [[0, 0], [0, 1], [1, 1], [0, 2]], [[1, 0], [0, 1], [1, 1], [2, 1]], [[1, 0], [0, 1], [1, 1], [1, 2]]], # O (7) [[[0, 0], [1, 0], [0, 1], [1, 1]]]] In Clojure we had to specify the namespace at the top of the file, but in Python, the namespace is implicitly given based on the directory hierarchy. Here we put the above code in shape.py, and it will therefore automatically belong to the tetrisanalyzer.piece.shape module: â–¾ tetris-polylith-uv â–¾ components â–¾ tetrisanalyzer â–¾ piece __init__.py shape.py Interface In Polylith, only what&aposs in the component&aposs interface is exposed to the rest of the codebase. In Python, we can optionally control what gets exposed in wildcard imports (from module import *) by defining the __all__ variable in the __init__.py module. However, even without __all__, all public names (those not starting with _) are still accessible through explicit imports. This is how the piece interface in __init__.py looks like: from tetrisanalyzer.piece.core import I, Z, S, J, L, T, O, piece __all__ = [\"I\", \"Z\", \"S\", \"J\", \"L\", \"T\", \"O\", \"piece\"] We could have put all the code directly in __init__.py, but it&aposs a common pattern in Python to keep this module clean by delegating to implementation modules like core.py: from tetrisanalyzer.piece import shape I = 1 Z = 2 S = 3 J = 4 L = 5 T = 6 O = 7 def piece(p, rotation): return shape.pieces[p][rotation] The piece component now has these files: â–¾ tetris-polylith-uv â–¾ components â–¾ tetrisanalyzer â–¾ piece __init__.py core.py shape.py Clojure In Clojure, the interface is often just a single namespace with the name interface: â–¾ components â–¾ piece â–¾ src â–¾ tetrisanalyzer â–¾ piece interface.clj Implemented like this: (ns tetrisanalyzer.piece.interface (:require [tetrisanalyzer.piece.shape :as shape])) (def I 1) (def Z 2) (def S 3) (def J 4) (def L 5) (def T 6) (def O 7) (defn piece [p rotation] (get-in shape/pieces [p rotation])) A language comparision Let&aposs see what differences there are in the two languages: ;; Clojure (defn piece [p rotation] (get-in shape/pieces [p rotation])) # Python def piece(p, rotation): return shape.pieces[p][rotation] An obvious difference here is that Clojure is a Lisp dialect, while Python uses a more traditional syntax. This means that if you want anything to happen in Clojure, you put it first in a list: (defn piece ...) is a macro that expands to (def piece (fn ...)) which defines the function piece (get-in shape/pieces [p rotation]) is a call to the function clojure.core/get-in, where: The first argument shape/pieces refers to the pieces vector in the shape namespace The second argument creates the vector [p rotation] with two arguments: p is a value between 1 and 7, representing one of the pieces: I, Z, S, J, L, T, and O rotation is a value between 0 and 3, representing the number of 90-degree rotations Another significant difference is that data is immutable in Clojure, while in Python it&aposs mutable (like the pieces data structure). However, a similarity is that both languages are dynamically typed, but uses concrete types in the compiled code: ;; Clojure (class \\Z) ;; Returns java.lang.Character (class 2) ;; Returns java.lang.Long (class Z) ;; Returns java.lang.Long (since Z is bound to 2) # Python type(&aposZ&apos) # Returns (characters are strings in Python) type(2) # Returns type(Z) # Returns (since Z is bound to 2) The languages also share another feature: type information can be added optionally. In Clojure, this is done using type hints for Java interop and performance optimization. In Python, type hints (introduced in Python 3.5) can be added using the typing module, though they are not enforced at runtime and are primarily used for static type checking with tools like mypy. The board component Now let&aposs continue by creating a board component: poly create component name:board Which adds the board component to the workspace: â–¾ tetris-polylith â–¸ bases â–¾ components â–¸ board â–¸ piece â–¸ development â–¸ projects And this is how we create a board component in Python: uv run poly create component --name board This adds the board component to the workspace: â–¾ components â–¾ tetrisanalyzer â–¸ board â–¸ piece â–¾ test â–¾ components â–¾ tetrisanalyzer â–¸ board â–¸ piece The Clojure code that places a piece on the board is implemented like this: (ns tetrisanalyzer.board.core) (defn empty-board [width height] (vec (repeat height (vec (repeat width 0))))) (defn set-cell [board p x y [cx cy]] (assoc-in board [(+ y cy) (+ x cx)] p)) (defn set-piece [board p x y piece] (reduce (fn [board cell] (set-cell board p x y cell)) board piece)) In Python (which uses two blank lines between functions by default): def empty_board(width, height): return [[0] * width for _ in range(height)] def set_cell(board, p, x, y, cell): cx, cy = cell board[y + cy][x + cx] = p def set_piece(board, p, x, y, piece): for cell in piece: set_cell(board, p, x, y, cell) return board Let&aposs go through these functions. empty-board (defn empty-board [width height] (vec (repeat height (vec (repeat width 0))))) To explain this function, we can break it down into smaller statements: (defn empty-board [width height] ;; [4 2] (let [row-list (repeat width 0) ;; (0 0 0 0) row (vec row-list) ;; [0 0 0 0] rows (repeat height row) ;; ([0 0 0 0] [0 0 0 0]) board (vec rows)] ;; [[0 0 0 0] [0 0 0 0]] board)) We convert the lists to vectors using the vec function, so that we (later) can access it via index. Note that it is the last value in the function (board) that is returned. empty_board def empty_board(width, height): return [[0] * width for _ in range(height)] This can be rewritten as: def empty_board(width, height): # width = 4, height = 2 row = [0] * width # row = [0, 0, 0, 0] rows = range(height) # rows = lazy sequence with the length of 2 board = [row for _ in rows] # board = [[0, 0, 0, 0], [0, 0, 0, 0]] return board The [row for _ in rows] statement is a list comprehension and is a way to create data structures in Python by looping. We loop twice through range(height), which yields the values 0 and 1, but we&aposre not interested in these values, so we use the _ placeholder. set-cell (defn set-cell [board p x y [cx cy]] (assoc-in board [(+ y cy) (+ x cx)] p)) Let&aposs break it down into an alternative implementation and call it with: board = [[0 0 0 0] [0 0 0 0]] p = 6, x = 2, y = 0, cell = [0 1]) (defn set-cell [board p x y cell] (let [[cx cy] cell ;; Destructures [0 1] into cx = 0, cy = 1 xx (+ x cx) ;; xx = 2 + 0 = 2 yy (+ y cy)] ;; yy = 0 + 1 = 1 (assoc-in board [yy xx] p))) ;; [[0 0 0 0] [0 0 6 0]] In the original version, destructuring of [cx cy] happens directly in the function&aposs parameter list. The assoc-in function works like board[y][x] in Python in this example, with the difference that it doesn&apost mutate, but instead returns a new immutable board. set_cell def set_cell(board, p, x, y, cell): cx, cy = cell board[y + cy][x + cx] = p # [[0,0,0,0] [0,0,6,0]] As mentioned earlier, this code mutates the two-dimensional list in place. It doesn&apost return anything, which differs from the Clojure version that returns a new board with one cell changed. set-piece (defn set-piece [board p x y piece] (reduce (fn [board cell] (set-cell board p x y cell)) board ;; An empty board as initial value piece)) ;; cells: [[1 0] [0 1] [1 1] [2 1]] If you are new to reduce, think of it as a recursive function that processes each element in a collection, accumulating a result as it goes. The initial call to set-cell will use an empty board and the first [1 0] cell from piece, then use the returned board from set-cell and the second cell [0 1] from piece to call set-cell again, and continue like that until it has applied all cells in piece, where it returns a new board. set_piece def set_piece(board, p, x, y, piece): for cell in piece: set_cell(board, p, x, y, cell) return board The Python version is pretty straight forward, with a for loop that mutates the board. We choose to return the board to make the function more flexible, allowing it to be used in expressions and enabling method chaining, which is a common Python pattern, even though the board is already mutated in place. Test The test looks like this in Clojure: (ns tetrisanalyzer.board.core-test (:require [clojure.test :refer :all] [tetrisanalyzer.piece.interface :as piece] [tetrisanalyzer.board.core :as board])) (def empty-board [[0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0]]) (deftest empty-board-test (is (= empty-board (board/empty-board 10 15)))) (deftest set-piece-test (let [T piece/T rotate-two-times 2 piece-t (piece/piece T rotate-two-times) x 5 y 13] (is (= [[0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 T 0 0 0] [0 0 0 0 0 T T T 0 0]] (board/set-piece empty-board T x y piece-t))))) Let&aposs execute the tests to check that everything works as expected: poly test :dev The tests passed! Python Now, let&aposs add a Python test for the board: from tetrisanalyzer import board, piece empty_board = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ] def test_empty_board(): assert empty_board == board.empty_board(10, 15) def test_set_piece(): T = piece.T rotate_two_times = 2 piece_t = piece.piece(T, rotate_two_times) x = 5 y = 13 expected = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, T, 0, 0, 0], [0, 0, 0, 0, 0, T, T, T, 0, 0], ] assert expected == board.set_piece(empty_board, T, x, y, piece_t) Let&aposs install and run the tests using pytest: uv add pytest --dev And run the tests: uv run pytest With that, we have finished the first post in this blog series! If you&aposre eager to see a self-playing Tetris program, I happen to have made a couple in other languages that you can watch here. Happy Coding!"}, :excerpts [{:text "... helps create a good structure for high-level functional style programming. You might feel that...", :matched-terms ["functional"], :source :content} {:text "... in Clojure and", :matched-terms ["clojure"], :source :content} {:text "... array): [[0,0,0,0,0,0,0,0,0,0]\n [0,0,0,0,0,0,0,0,0,0]\n...", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://blog.parenstech.com/2025-12-30-building-heretic.html", :title "Building Heretic: From ClojureStorm to Mutant Schemata", :link "https://blog.parenstech.com/2025-12-30-building-heretic.html", :published-at #inst "2025-12-30T23:59:59.000-00:00", :content "This is Part 2 of a series on mutation testing in Clojure. Part 1 introduced the concept and why Clojure needed a purpose-built tool. The previous post made a claim: mutation testing can be fast if you know which tests to run. This post shows how Heretic makes that happen. We&aposll walk through the three core phases: collecting expression-level coverage with ClojureStorm, transforming source code with rewrite-clj, and the optimization techniques that keep mutation counts manageable. Phase 1: Coverage Collection Traditional coverage tools track lines. Heretic tracks expressions. The difference matters. Consider: (defn process-order [order] (if (> (:quantity order) 10) (* (:price order) 0.9) ;; <- Line 3: bulk discount (:price order))) Line-level coverage would show line 3 as \"covered\" if any test enters the bulk discount branch. But expression-level coverage distinguishes between tests that evaluate *, (:price order), and 0.9. When we later mutate 0.9 to 1.1, we can run only the tests that actually touched that specific literal - not every test that happened to call process-order. ClojureStorm&aposs Instrumented Compiler ClojureStorm is a fork of the Clojure compiler that instruments every expression during compilation. Created by Juan Monetta for the FlowStorm debugger, it provides exactly the hooks Heretic needs. (Thanks to Juan for building such a solid foundation - Heretic would not exist without ClojureStorm.) The integration is surprisingly minimal: (ns heretic.tracer (:import [clojure.storm Emitter Tracer])) (def ^:private current-coverage \"Atom of {form-id #{coords}} for the currently running test.\" (atom {})) (defn record-hit! [form-id coord] (swap! current-coverage update form-id (fnil conj #{}) coord)) (defn init! [] ;; Configure what gets instrumented (Emitter/setInstrumentationEnable true) (Emitter/setFnReturnInstrumentationEnable true) (Emitter/setExprInstrumentationEnable true) ;; Set up callbacks (Tracer/setTraceFnsCallbacks {:trace-expr-fn (fn [_ _ coord form-id] (record-hit! form-id coord)) :trace-fn-return-fn (fn [_ _ coord form-id] (record-hit! form-id coord))})) When any instrumented expression evaluates, ClojureStorm calls our callback with two pieces of information: form-id: A unique identifier for the top-level form (e.g., an entire defn) coord: A path into the form&aposs AST, like \"3,2,1\" meaning \"third child, second child, first child\" Together, [form-id coord] pinpoints exactly which subexpression executed. This is the key that unlocks targeted test selection. The Coordinate System To connect a mutation in the source code to the coverage data, we need a way to uniquely address any subexpression. Think of it as a postal address for code - we need to say \"the a inside the + call inside the function body\" in a format that both the coverage tracer and mutation engine can agree on. ClojureStorm addresses this with a path-based coordinate system. Consider this function as a tree: (defn foo [a b] (+ a b)) â”‚ â”œâ”€[0] defn â”œâ”€[1] foo â”œâ”€[2] [a b] â””â”€[3] (+ a b) â”‚ â”œâ”€[3,0] + â”œâ”€[3,1] a â””â”€[3,2] b Each number represents which child to pick at each level. The coordinate \"3,2\" means \"go to child 3 (the function body), then child 2 (the second argument to +)\". That gives us the b symbol. This works cleanly for ordered structures like lists and vectors, where children have stable positions. But maps are unordered - {:name \"Alice\" :age 30} and {:age 30 :name \"Alice\"} are the same value, so numeric indices would be unstable. ClojureStorm solves this by hashing the printed representation of map keys. Instead of \"0\" for the first entry, a key like :name gets addressed as \"K-1925180523\": {:name \"Alice\" :age 30} â”‚ â”œâ”€[K-1925180523] :name â”œâ”€[V-1925180523] \"Alice\" â”œâ”€[K-1524292809] :age â””â”€[V-1524292809] 30 The hash ensures stable addressing regardless of iteration order. With this addressing scheme, we can say \"test X touched coordinate 3,1 in form 12345\" and later ask \"which tests touched the expression we&aposre about to mutate?\" The Form-Location Bridge Here&aposs a problem we discovered during implementation: how do we connect the mutation engine to the coverage data? The mutation engine uses rewrite-clj to parse and transform source files. It finds a mutation site at, say, line 42 of src/my/app.clj. But the coverage data is indexed by ClojureStorm&aposs form-id - an opaque identifier assigned during compilation. We need to translate \"file + line\" into \"form-id\". Fortunately, ClojureStorm&aposs FormRegistry stores the source file and starting line for each compiled form. We build a lookup index: (defn build-form-location-index [forms source-paths] (into {} (for [[form-id {:keys [form/file form/line]}] forms :when (and file line) :let [abs-path (resolve-path source-paths file)] :when abs-path] [[abs-path line] form-id]))) When the mutation engine finds a site at line 42, it searches for the form whose start line is the largest value less than or equal to 42 - that is, the innermost containing form. This gives us the ClojureStorm form-id, which we use to look up which tests touched that form. This bridging layer is what allows Heretic to connect source transformations to runtime coverage, enabling targeted test execution. Collection Workflow Coverage collection runs each test individually and captures what it touches: (defn run-test-with-coverage [test-var] (tracer/reset-current-coverage!) (try (test-var) (catch Throwable t (println \"Test threw exception:\" (.getMessage t)))) {(symbol test-var) (tracer/get-current-coverage)}) The result is a map from test symbol to coverage data: {my.app-test/test-addition {12345 #{\"3\" \"3,1\" \"3,2\"} ;; form-id -> coords touched 12346 #{\"1\" \"2,1\"}} my.app-test/test-subtraction {12345 #{\"3\" \"4\"} 12347 #{\"1\"}}} This gets persisted to .heretic/coverage/ with one file per test namespace, enabling incremental updates. Change a test file? Only that namespace gets recollected. At this point we have a complete map: for every test, we know exactly which [form-id coord] pairs it touched. Now we need to generate mutations and look up which tests are relevant for each one. Phase 2: The Mutation Engine With coverage data in hand, we need to actually mutate the code. This means: Parsing Clojure source into a navigable structure Finding locations where operators apply Transforming the source Hot-swapping the modified code into the running JVM Parsing with rewrite-clj rewrite-clj gives us a zipper over Clojure source that preserves whitespace and comments - essential for producing readable diffs: (defn parse-file [path] (z/of-file path {:track-position? true})) (defn find-mutation-sites [zloc] (->> (walk-form zloc) (remove in-quoted-form?) ;; Skip &apos(...) and `(...) (mapcat (fn [z] (let [applicable (ops/applicable-operators z)] (map #(make-mutation-site z %) applicable)))))) The walk-form function traverses the zipper depth-first. At each node, we check which operators match. An operator is a data map with a matcher predicate: (def swap-plus-minus {:id :swap-plus-minus :original &apos+ :replacement &apos- :description \"Replace + with -\" :matcher (fn [zloc] (and (= :token (z/tag zloc)) (symbol? (z/sexpr zloc)) (= &apos+ (z/sexpr zloc))))}) Each mutation site captures the file, line, column, operator, and - critically - the coordinate path within the form. This coordinate is what connects a mutation to the coverage data from Phase 1. Coordinate Mapping The tricky part is converting between rewrite-clj&aposs zipper positions and ClojureStorm&aposs coordinate strings. We need bidirectional conversion for the round-trip: (defn coord->zloc [zloc coord] (let [parts (parse-coord coord)] ;; \"3,2,1\" -> [3 2 1] (reduce (fn [z part] (when z (if (string? part) ;; Hash-based for maps/sets (find-by-hash z part) (nth-child z part)))) ;; Integer index for lists/vectors zloc parts))) (defn zloc->coord [zloc] (loop [z zloc coord []] (cond (root-form? z) (vec coord) (z/up z) (let [part (if (is-unordered-collection? z) (compute-hash-coord z) (child-index z))] (recur (z/up z) (cons part coord))) :else (vec coord)))) The validation requirement is that these must be inverses: (= coord (zloc->coord (coord->zloc zloc coord))) With correct coordinate mapping, we can take a mutation at a known location and ask \"which tests touched this exact spot?\" That query is what makes targeted test execution possible. Applying Mutations Once we find a mutation site and can navigate to it, the actual transformation is straightforward: (defn apply-mutation! [mutation] (let [{:keys [file form-id coord operator]} mutation operator-def (get ops/operators-by-id operator) original-content (slurp file) zloc (z/of-string original-content {:track-position? true}) form-zloc (find-form-by-id zloc form-id) target-zloc (coord/coord->zloc form-zloc coord) replacement-str (ops/apply-operator operator-def target-zloc) modified-zloc (z/replace target-zloc (n/token-node (symbol replacement-str))) modified-content (z/root-string modified-zloc)] (spit file modified-content) (assoc mutation :backup original-content))) Hot-Swapping with clj-reload After modifying the source file, we need the JVM to see the change. clj-reload handles this correctly: (ns heretic.reloader (:require [clj-reload.core :as reload])) (defn init! [source-paths] (reload/init {:dirs source-paths})) (defn reload-after-mutation! [] (reload/reload {:throw false})) Why clj-reload specifically? It solves problems that require :reload doesn&apost: Proper unloading: Calls remove-ns before reloading, preventing protocol/multimethod accumulation Dependency ordering: Topologically sorts namespaces, unloading dependents first Transitive closure: Automatically reloads namespaces that depend on the changed one The mutation workflow becomes: (with-mutation [m mutation] (reloader/reload-after-mutation!) (run-relevant-tests m)) ;; Mutation automatically reverted in finally block At this point we have the full pipeline: parse source, find mutation sites, apply a mutation, hot-reload, run targeted tests, restore. But running this once per mutation is still slow for large codebases. Phase 3 addresses that. 80+ Clojure-Specific Operators The operator library is where Heretic&aposs Clojure focus shows. Beyond the standard arithmetic and comparison swaps, we have: Threading operators - catch ->/->> confusion: (-> data (get :users) first) ;; Original (->> data (get :users) first) ;; Mutant: wrong arg position Nil-handling operators - expose nil punning mistakes: (when (seq users) ...) ;; Original: handles empty list (when users ...) ;; Mutant: breaks on empty list (truthy) Lazy/eager operators - catch chunking and realization bugs: (map process items) ;; Original: lazy (mapv process items) ;; Mutant: eager, different memory profile Destructuring operators - expose JSON interop issues: {:keys [user-id]} ;; Original: kebab-case {:keys [userId]} ;; Mutant: camelCase from JSON The full set includes first/last, rest/next, filter/remove, conj/disj, some->/->, and qualified keyword mutations. These are the mistakes Clojure developers actually make. With 80+ operators applied to a real codebase, mutation counts grow quickly. The next phase makes this tractable. Phase 3: Optimization Techniques With 80+ operators and a real codebase, mutation counts get large fast. A 1000-line project might generate 5000 mutations. Running the full test suite 5000 times is not practical. Heretic uses several techniques to make this manageable. Targeted Test Execution This is the big one, enabled by Phase 1. Instead of running all tests for every mutation, we query the coverage index: (defn tests-for-mutation [coverage-map mutation] (let [form-id (resolve-form-id (:form-location-index coverage-map) mutation) coord (:coord mutation)] (get-in coverage-map [:coord-to-tests [form-id coord]] #{}))) A mutation at (+ a b) might only be covered by 2 tests out of 200. We run those 2 tests in milliseconds instead of the full suite in seconds. This is where the Phase 1 coverage investment pays off. But we can go further by reducing the number of mutations we generate in the first place. Equivalent Mutation Detection Some mutations produce semantically identical code. Detecting these upfront avoids wasted test runs: ;; (* x 0) -> (/ x 0) is NOT equivalent (divide by zero) ;; (* x 1) -> (/ x 1) IS equivalent (both return x) (def equivalent-patterns [{:operator :swap-mult-div :context (fn [zloc] (some #(= 1 %) (rest (z/child-sexprs (z/up zloc))))) :reason \"Multiplying or dividing by one has no effect\"} {:operator :swap-lt-lte :context (fn [zloc] (let [[_ left right] (z/child-sexprs (z/up zloc))] (and (= 0 right) (non-negative-fn? (first left))))) :reason \"(< (count x) 0) is always false\"}]) The patterns cover boundary comparisons ((>= (count x) 0) is always true), function contracts ((nil? (str x)) is always false), and lazy/eager equivalences ((vec (map f xs)) equals (vec (mapv f xs))). Filtering equivalent mutations prevents false \"survived\" reports. But we can also skip mutations that would be redundant to test. Subsumption Analysis Subsumption identifies when killing one mutation implies another would also be killed. If swapping < to <= is caught by a test, then swapping < to > would likely be caught too. Based on the RORG (Relational Operator Replacement with Guard) research, we define subsumption relationships: (def relational-operator-subsumption {&apos< [:swap-lt-lte :swap-lt-neq :replace-comparison-false] &apos> [:swap-gt-gte :swap-gt-neq :replace-comparison-false] &apos<= [:swap-lte-lt :swap-lte-eq :replace-comparison-true] ;; ... }) For each comparison operator, we only need to test the minimal set. The research shows this achieves roughly the same fault detection with 40% fewer mutations. The subsumption graph also enables intelligent mutation selection: (defn minimal-operator-set [operators] (set/difference operators ;; Remove any operator dominated by another in the set (reduce (fn [dominated op] (into dominated (set/intersection (dominated-operators op) operators))) #{} operators))) These techniques reduce mutation count. The final optimization reduces the cost of each mutation. Mutant Schemata: Compile Once, Select at Runtime The most sophisticated optimization is mutant schemata. Instead of applying one mutation, reloading, testing, reverting, reloading for each mutation, we embed multiple mutations into a single compilation: ;; Original (defn calculate [x] (+ x 1)) ;; Schematized (with 3 mutations) (defn calculate [x] (case heretic.schemata/*active-mutant* :mut-42-5-plus-minus (- x 1) :mut-42-5-1-to-0 (+ x 0) :mut-42-5-1-to-2 (+ x 2) (+ x 1))) ;; original (default) We reload once, then switch between mutations by binding a dynamic var: (def ^:dynamic *active-mutant* nil) (defmacro with-mutant [mutation-id & body] `(binding [*active-mutant* ~mutation-id] ~@body)) The workflow becomes: (defn run-mutation-batch [file mutations test-fn] (let [schemata-info (schematize-file! file mutations)] (try (reload!) ;; Once! (doseq [[id mutation] (:mutation-map schemata-info)] (with-mutant id (test-fn id mutation))) (finally (restore-file! schemata-info) (reload!))))) ;; Once! For a file with 50 mutations, this means 2 reloads instead of 100. The overhead of case dispatch at runtime is negligible compared to compilation cost. Operator Presets Finally, we offer presets that trade thoroughness for speed: (def presets {:fast #{:swap-plus-minus :swap-minus-plus :swap-lt-gt :swap-gt-lt :swap-and-or :swap-or-and :swap-nil-some :swap-some-nil} :minimal minimal-preset-operators ;; Subsumption-aware :standard #{;; :fast plus... :swap-first-last :swap-rest-next :swap-thread-first-last} :comprehensive (set (map :id all-operators))}) The :fast preset uses ~15 operators that research shows catch roughly 99% of bugs. The :minimal preset uses subsumption analysis to eliminate redundant mutations. Both run much faster than :comprehensive while maintaining detection power. Putting It Together A mutation testing run with Heretic looks like: Collect coverage (once, cached): Run tests under ClojureStorm instrumentation, build expression-level coverage map Generate mutations: Parse source files, find all applicable operator sites Filter: Remove equivalent mutations, apply subsumption to reduce set Group by file: Prepare for schemata optimization For each file: Build schematized source with all mutations Reload once For each mutation: bind *active-mutant*, run targeted tests Restore and reload Report: Mutation score, surviving mutations, test effectiveness The result is mutation testing that runs in seconds for typical projects instead of hours. This covers the core implementation. A future post will explore Phase 4: AI-powered semantic mutations and hybrid equivalent detection - using LLMs to generate the subtle, domain-aware mutations that traditional operators miss. Previously: Part 1 - Heretic: Mutation Testing in Clojure"}, :excerpts [{:text "Building Heretic: From ClojureStorm to Mutant Schemata", :matched-terms ["clojure"], :source :title} {:text "... is Part 2 of a series on mutation testing in Clojure.", :matched-terms ["clojure"], :source :content} {:text "... 1 introduced the concept and why Clojure needed a purpose-built tool. The...", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "tag:blogger.com,1999:blog-1409352204799783992.post-1198041635414991858", :title "Joyful Python with the REPL", :link "https://davidvujic.blogspot.com/2022/08/joyful-python-with-repl.html", :published-at #inst "2026-01-03T20:25:31.000-00:00", :content "REPL Driven Development is a workflow that makes coding both joyful and interactive. The feedback loop from the REPL is a great thing to have at your fingertips. \"If you can improve just one thing in your software development, make it getting faster feedback.\" Dave Farley Just like Test Driven Development (TDD), it will help you write testable code. I have also noticed a nice side effect from this workflow: REPL Driven Development encourages a functional programming style. REPL Driven Development is an everyday thing among Clojure developers and doable in Python, but far less known here. I'm working on making it an everyday thing in Python development too. But what is REPL Driven Development? What is it? You evaluate variables, code blocks, functions - or an entire module - and get instant feedback, just by a hitting a key combination in your favorite code editor. There's no reason to leave the IDE for a less featured shell to accomplish all of that. You already have autocomplete, syntax highlighting and the color theme set up in your editor. Why not use that, instead of a shell? Evaluate code and get feedback, without leaving the code editor. Ideally, the result of an evaluation pops up right next to the cursor, so you don't have to do any context switches or lose focus. It can also be printed out in a separate frame right next to the code. This means that testing the code you currently write is at your fingertips. Easy setup With some help from IPython, it is possible to write, modify & evaluate Python code in a REPL Driven way. I would recommend to install IPython globally, to make it accessible from anywhere on your machine. pip install ipython Configure IPython to make it ready for REPL Driven Development: c.InteractiveShellApp.exec_lines = [\"%autoreload 2\"] c.InteractiveShellApp.extensions = [\"autoreload\"] c.TerminalInteractiveShell.confirm_exit = False You will probably find the configuration file here: ~/.ipython/profile_default/ipython_config.py You are almost all set. Emacs setup Emacs is my favorite editor. I'm using a couple of Python specific packages to make life as a Python developer in general better, such as elpy. The auto-virtualenv package will also help out making REPL Driven Developer easier. It will find local virtual environments automatically and you can start coding without any python-path quirks. Most importantly, set IPython as the default shell in Emacs. Have a look at my Emacs setup for the details. VS Code setup I am not a VS Code user. But I wanted to learn how well supported REPL Driven Development is in VS Code, so I added these extensions: You would probably want to add keyboard shortcuts to get the true interactive feel of it. Here, I'm just trying things out by selecting code, right clicking and running it in an interactive window. It seems to work pretty well! I haven't figured out if the interactive window is picking up the global IPython config yet, or if it already refreshes a submodule when updated. Evaluating code in the editor with fast feedback loops. It would be great to have keyboard commands here, though. Current limitations In Clojure, you connect to & modify an actually running program by re-evaluating the source code. That is a wonderful thing for the developer experience in general. I haven't been able to do that with Python, and believe Python would need something equivalent to NRepl to get that kind of magic powers. Better than TDD I practice REPL Driven Development in my daily Python work. For me, it has become a way to quickly verify if the code I currently write is working as expected. I usually think of this REPL driven thing as Test Driven Development Deluxe. Besides just evaluating the code, I often write short-lived code snippets to test out some functionality. By doing that, I can write code and test it interactively. Sometimes, these code snippets are converted permanent unit tests. For a live demo, have a look at my five minute lightning talk from PyCon Sweden about REPL Driven Development in Python. Never too late to learn I remember it took me almost a year learning & developing Clojure before I actually \"got it\". Before that, I sometimes copied some code and pasted it into a REPL and then ran it. But that didn't give me a nice developer experience at all. Copy-pasting code is cumbersome and will often fail because of missing variables, functions or imports. Don't do that. I remember the feeling when figuring out the REPL Driven Development workflow, I finally had understood how software development should be done. It took me about 20 years to get there. It is never too late to learn new things. ðŸ˜ Top photo by ckturistando on Unsplash"}, :excerpts [{:text "Joyful Python with the REPL", :matched-terms ["repl"], :source :title} {:text "... width=\"400\" /> REPL Driven Development is a workflow that makes coding both joyful and interactive. The feedback loop from the REPL is a great thing to have at your fingertips. ...", :matched-terms ["repl"], :source :content} {:text "... noticed a nice side effect from this workflow: REPL Driven Development encourages a functional programming style. REPL Driven Development is an everyday thing among Clojure developers and doable in Python, but far less...", :matched-terms ["repl" "functional" "clojure"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://blog.parenstech.com/2025-12-28-heretic-mutation-testing.html", :title "Heretic: Mutation Testing in Clojure", :link "https://blog.parenstech.com/2025-12-28-heretic-mutation-testing.html", :published-at #inst "2025-12-28T23:59:59.000-00:00", :content "Your tests pass. Your coverage is high. You deploy. Three days later, a bug surfaces in a function your tests definitely executed. The coverage report confirms it: that line is green. Your test ran the code. So how did a bug slip through? Because coverage measures execution, not verification. (defn apply-discount [price user] (if (:premium user) (* price 0.8) price)) (deftest apply-discount-test (is (number? (apply-discount 100 {:premium true}))) (is (number? (apply-discount 100 {:premium false})))) Coverage: 100%. Every branch executed. Tests: green. But swap 0.8 for 1.2? Tests pass. Change * to /? Tests pass. Flip (:premium user) to (not (:premium user))? Tests pass. The tests prove some number comes back. They say nothing about whether it&aposs the right number. The Question Nobody&aposs Asking Mutation testing asks a harder question: if I introduced a bug, would any test notice? The technique is simple. Take your code, introduce a small change (a \"mutant\"), and run your tests. If a test fails, the mutant is \"killed\" - your tests caught the bug. If all tests pass, the mutant \"survived\" - you&aposve found a gap in your verification. This isn&apost new. PIT does it for Java. Stryker does it for JavaScript. cargo-mutants does it for Rust. Clojure hasn&apost had a practical option. The only dedicated tool, jstepien/mutant, was archived this year as \"wildly experimental.\" You can run PIT on Clojure bytecode, but bytecode mutations bear no relationship to mistakes Clojure developers actually make. You&aposll get mutations like \"swap IADD for ISUB\" when what you want is \"swap -> for ->> \" or \"change :user-id to :userId.\" Why Clojure Makes This Hard Mutation testing has a performance problem everywhere. Run 500 mutations, execute your full test suite for each one, and you&aposre measuring build times in hours. Most developers try it once, watch the clock, and never run it again. But Clojure adds unique challenges: Homoiconicity cuts both ways. Code-as-data makes programmatic transformation elegant, but distinguishing \"meaningful mutation\" from \"syntactic noise\" gets subtle when everything is just nested lists. Macros muddy the waters. A mutation to macro input might not change the expanded code. A mutation inside a macro definition might break in ways that have nothing to do with your production logic. The bugs we make are language-specific. Threading macro confusion, nil punning traps, destructuring gotchas from JSON interop, keyword naming collisions - these aren&apost + becoming -. They&aposre mistakes that come from thinking in Clojure. What If It Could Be Fast? The insight that makes Heretic practical: most mutations only need 2-3 tests. When you mutate a single expression, you don&apost need your entire test suite. You need only the tests that exercise that expression. Usually that&aposs a handful of tests, not hundreds. The challenge is knowing which ones. Not just which functions they call, but which subexpressions they touch. The + inside (if condition (+ a b) (* a b)) might be covered by different tests than the *. Heretic builds this map using ClojureStorm, the instrumented compiler behind FlowStorm. Run your tests once under instrumentation. From then on, each mutation runs only the tests that actually touch that code. Instead of running 200 tests per mutation, we run 2. Instead of hours, seconds. What If It Understood Clojure? Generic operators miss the bugs we actually make: ;; The mutation you want: threading macro confusion (-> data (get :users) first) ; Original (->> data (get :users) first) ; Mutant: wrong arg position, wrong result ;; The mutation you want: nil punning trap (when (seq users) (map :name users)) ; Original (handles empty) (when users (map :name users)) ; Mutant (breaks on empty list) ;; The mutation you want: destructuring gotcha {:keys [user-id name]} ; Original (kebab-case) {:keys [userId name]} ; Mutant (camelCase from JSON) Heretic has 65+ mutation operators designed for Clojure idioms. Swap first for last. Change rest to next. Replace -> with some->. Mutate qualified keywords. The mutations you see will be the bugs you recognize. What If It Could Think? Here&aposs a finding that should worry anyone relying on traditional mutation testing: research shows that nearly half of real-world faults have no strongly coupled traditional mutant. The bugs that escape to production aren&apost the ones that flip operators. They&aposre the ones that invert business logic. ;; Traditional mutation: swap * for / (* price 0.8) --> (/ price 0.8) ; Absurd. Nobody writes this bug. ;; Semantic mutation: invert the discount (* price 0.8) --> (* price 1.2) ; Premium users pay MORE. Plausible bug. A function called apply-discount should never increase the price. That&aposs the invariant tests should verify. An AI can read function names, docstrings, and context to generate the mutations that test whether your tests understand the code&aposs purpose. This hybrid approach - fast deterministic mutations for the common cases, intelligent semantic mutations for the subtle ones - is where Heretic is heading. Meta&aposs ACH system proved the pattern works at industrial scale. Why \"Heretic\"? Clojure discourages mutation. Values are immutable. State changes through controlled transitions. The design philosophy is that uncontrolled mutation leads to bugs. So there&aposs something a bit ironic about a tool that deliberately introduces mutations to find those bugs. We mutate your code to prove your tests would catch it if it happened accidentally - to verify that the discipline holds. This is the first in a series on building Heretic. Upcoming posts will cover how ClojureStorm enables expression-level coverage mapping, how we use rewrite-clj and clj-reload for hot-swapping mutants, and the optimization techniques that make this practical for real codebases. If your coverage is high but bugs still slip through, you&aposre measuring the wrong thing."}, :excerpts [{:text "Heretic: Mutation Testing in Clojure", :matched-terms ["clojure"], :source :title} {:text "... not verification. (defn apply-discount [price user]\n  (if...", :matched-terms ["clojure"], :source :content} {:text "... href=\"https://pitest.org/\">PIT does it for Java.", :matched-terms ["java"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://building.nubank.com/?p=35767", :title "Building elegant interfaces with ClojureScript, React, and UIx", :link "https://building.nubank.com/building-elegant-interfaces-with-clojurescript-react-and-uix/", :published-at #inst "2025-12-23T15:26:47.000-00:00", :content "During Clojure South, JoÃ£o Lanjoni, Software Engineer at Nubank, addressed a central challenge of modern web development: how to combine the ergonomics of ClojureScript with the maturity of React to build scalable, high-performance interfaces. According to JoÃ£o, the solution is UIx, a tool that represents the new generation of bridges that further aligns the Clojure universe with the React ecosystem. In his session, he detailed the context, the limitations of previous approaches, and the value of UIx as a new, efficient entry point for React developers into ClojureScript. From 2013 to today: React and ClojureScript in perspective Since its launch in 2013, React has redefined the structure of frontend applications by introducing concepts like consistent reactivity. The ClojureScript community quickly responded with idiomatic interfaces like Reagent, which became the de facto standard due to its solidity, providing a minimalistic interface between ClojureScript and React, using a Hiccup-like syntax to define components. With the arrival of functional components and hooks, starting around 2019, new interfaces came up to provide a direct way of using functional components (instead of old class-based components). However, as React continuously evolved towards modern patterns, including concurrent rendering, functional components, and new ways to manage component state, Reagent remained tied to class-based components, mainly for backward compatibility. This mismatch resulted in some limitations like performance limitations in large codebases (due to Hiccup parsing in runtime), issues with functional components (as users may have to declare every functional component usage even when they were defined as a React standard), and hindered interoperability with modern React libraries, such as Material UI, Mantine, and Ant Design, widening the gap between the two ecosystems. What UIx changes in your code UIx emerges to resolve this divergence. Acting as a thin interface between ClojureScript and modern React, its focus is technical and pragmatic: it offers a minimal abstraction layer, more predictable performance, and the direct use of functional components and hooks. Furthermore, it ensures native interoperability with the React ecosystem, allowing the lifecycle and state management to be handled directly by React itself. â€œIf React already handles state and lifecycle management well, why not let it do that?â€ JoÃ£o Lanjoni, Software Engineer at Nubank Instead of creating a complete framework or adding unnecessary abstractions, UIx is a lightweight bridge, leveraging what modern React does best, resulting in a ClojureScript codebase with idiomatic syntax but identical behavior to modern React. UIx component structure In practical terms, UIx centralizes component construction around two elements: defui for declaring React components and $ for rendering elements in an explicit and lightweight way. Component bodies process props identically to React. Hooks such as useState are exposed using idiomatic ClojureScript conventions, like use-state, with UIx handling the translation to native React APIs. This ergonomics combines the best of ClojureScript syntax with the React architecture, which, according to JoÃ£o, eliminates the need to train React developers in the internal details of layers like Reagent or Re-frame, keeping the mental model aligned with the React mainstream. Performance in figures A highlight of the presentation was the chart, created by Roman Liutikov â€“ the UIx maintainer â€“, comparing the call stack depth when rendering a simple component in pure React, UIx, and Reagent. React exhibits the shortest path; UIx, by adding only a thin layer, follows closely. In contrast, Reagent, due to Hiccup being interpreted at runtime, shows a significantly deeper call stack. While the difference is minimal in small applications, the impact on predictability and performance becomes notable and increases in products with hundreds or thousands of components. Who is already using UIx in production JoÃ£o presented three real-world examples, all highlighted on the projectâ€™s official page: Metosin, one of the largest Clojure consultancies in Europe; Pitch, an AI presentation platform with amazing slide decks; Cognician, an e-learning platform for personal development. The Pitch case is particularly impressive. The team migrated 2,500 components from Reagent to UIx, maintained compatibility with Re-frame, and saw improvements in predictability and performance. Metosin, meanwhile, employs Juho Teperi, one of the main contributors to Reagent, who also made an example project for a full-stack app using Clojure and ClojureScript and chose UIx to build the web interface, also using Material UI as the component library without any special wrapper. When someone who helped build the previous tool begins to advocate for the new approach, it says a lot about the current moment of the technology, even more with the launch of a new version of Reagent introducing default functional components and a thinner hooks wrapper (inspired also by UIx). Reducing the developer learning curve UIxâ€™s value extends to the hiring and development of engineers, which opens a path for more professionals to enter the ClojureScript ecosystem without the requirement of mastering the intricacies of Reagent, Re-frame, or the atom-based state model from day one. It represents a pragmatic approach to lowering barriers without sacrificing the benefits of a functional and declarative language. â€œThe greatest value of UIx is allowing React developers to write ClojureScript with a minimal learning curve.â€ JoÃ£o Lanjoni, Software Engineer at Nubank When UIx is the best choice UIx is especially recommended for modern and complex front-end applications and teams already familiar with React. It is ideal for codebases that rely heavily on hooks and for projects requiring interoperability with the latest React libraries, with a view toward strong long-term growth potential. The library, intentionally simple, does not attempt to reinvent global state management, maintaining compatibility with mature React libraries like Zustand and Jotai, instead of adding unnecessary layers, or even using a custom hook that subscribes to a Clojure atom to manage a global state (similar to those cited libraries). In essence, UIx does not seek to replace React but rather to act as a thin, modern, and pragmatic bridge. Its goal is to allow teams to build scalable front-ends with the power of React, while preserving the expressiveness and elegance of the Clojure philosophy and syntax. For complex and modern projects in ClojureScript, UIx may be the missing link. The post Building elegant interfaces with ClojureScript, React, and UIx appeared first on Building Nubank."}, :excerpts [{:text "Building elegant interfaces with ClojureScript, React, and UIx", :matched-terms ["clojure"], :source :title} {:text "During Clojure South, JoÃ£o Lanjoni, Software Engineer at Nubank,...", :matched-terms ["clojure"], :source :content} {:text "... development: how to combine the ergonomics of ClojureScript with the maturity of React to build...", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://tonsky.me/blog/syntax-highlighting/", :title "I am sorry, but everyone is getting syntax highlighting wrong", :link "https://tonsky.me/blog/syntax-highlighting/", :published-at #inst "2026-01-03T21:43:11.000-00:00", :content "Translations: Russian Syntax highlighting is a tool. It can help you read code faster. Find things quicker. Orient yourself in a large file. Like any tool, it can be used correctly or incorrectly. Letâ€™s see how to use syntax highlighting to help you work. Christmas Lights Diarrhea Most color themes have a unique bright color for literally everything: one for variables, another for language keywords, constants, punctuation, functions, classes, calls, comments, etc. Sometimes it gets so bad one canâ€™t see the base text color: everything is highlighted. Whatâ€™s the base text color here? The problem with that is, if everything is highlighted, nothing stands out. Your eye adapts and considers it a new norm: everything is bright and shiny, and instead of getting separated, it all blends together. Hereâ€™s a quick test. Try to find the function definition here: and here: See what I mean? So yeah, unfortunately, you canâ€™t just highlight everything. You have to make decisions: what is more important, what is less. What should stand out, what shouldnâ€™t. Highlighting everything is like assigning â€œtop priorityâ€ to every task in Linear. It only works if most of the tasks have lesser priorities. If everything is highlighted, nothing is highlighted. Enough colors to remember There are two main use-cases you want your color theme to address: Look at something and tell what it is by its color (you can tell by reading text, yes, but why do you need syntax highlighting then?) Search for something. You want to know what to look for (which color). 1 is a direct index lookup: color â†’ type of thing. 2 is a reverse lookup: type of thing â†’ color. Truth is, most people donâ€™t do these lookups at all. They might think they do, but in reality, they donâ€™t. Let me illustrate. Before: After: Can you see it? I misspelled return for retunr and its color switched from red to purple. I canâ€™t. Hereâ€™s another test. Close your eyes (not yet! Finish this sentence first) and try to remember what color your color theme uses for class names? Can you? If the answer for both questions is â€œnoâ€, then your color theme is not functional. It might give you comfort (as inâ€”I feel safe. If itâ€™s highlighted, itâ€™s probably code) but you canâ€™t use it as a tool. It doesnâ€™t help you. Whatâ€™s the solution? Have an absolute minimum of colors. So little that they all fit in your head at once. For example, my color theme, Alabaster, only uses four: Green for strings Purple for constants Yellow for comments Light blue for top-level definitions Thatâ€™s it! And I was able to type it all from memory, too. This minimalism allows me to actually do lookups: if Iâ€™m looking for a string, I know it will be green. If Iâ€™m looking at something yellow, I know itâ€™s a comment. Limit the number of different colors to what you can remember. If you swap green and purple in my editor, itâ€™ll be a catastrophe. If somebody swapped colors in yours, would you even notice? What should you highlight? Something there isnâ€™t a lot of. Rememberâ€”we want highlights to stand out. Thatâ€™s why I donâ€™t highlight variables or function callsâ€”they are everywhere, your code is probably 75% variable names and function calls. I do highlight constants (numbers, strings). These are usually used more sparingly and often are reference pointsâ€”a lot of logic paths start from constants. Top-level definitions are another good idea. They give you an idea of a structure quickly. Punctuation: it helps to separate names from syntax a little bit, and you care about names first, especially when quickly scanning code. Please, please donâ€™t highlight language keywords. class, function, if, elsestuff like this. You rarely look for them: â€œwhereâ€™s that ifâ€ is a valid question, but you will be looking not at the if the keyword, but at the condition after it. The condition is the important, distinguishing part. The keyword is not. Highlight names and constants. Grey out punctuation. Donâ€™t highlight language keywords. Comments are important The tradition of using grey for comments comes from the times when people were paid by line. If you have something like of course you would want to grey it out! This is bullshit text that doesnâ€™t add anything and was written to be ignored. But for good comments, the situation is opposite. Good comments ADD to the code. They explain something that couldnâ€™t be expressed directly. They are important. So hereâ€™s another controversial idea: Comments should be highlighted, not hidden away. Use bold colors, draw attention to them. Donâ€™t shy away. If somebody took the time to tell you something, then you want to read it. Two types of comments Another secret nobody is talking about is that there are two types of comments: Explanations Disabled code Most languages donâ€™t distinguish between those, so thereâ€™s not much you can do syntax-wise. Sometimes thereâ€™s a convention (e.g. -- vs /* */ in SQL), then use it! Hereâ€™s a real example from Clojure codebase that makes perfect use of two types of comments: Disabled code is gray, explanation is bright yellow Light or dark? Per statistics, 70% of developers prefer dark themes. Being in the other 30%, that question always puzzled me. Why? And I think I have an answer. Hereâ€™s a typical dark theme: and hereâ€™s a light one: On the latter one, colors are way less vibrant. Here, I picked them out for you: Notice how many colors there are. No one can remember that many. This is because dark colors are in general less distinguishable and more muddy. Look at Hue scale as we move brightness down: Basically, in the dark part of the spectrum, you just get fewer colors to play with. Thereâ€™s no â€œdark yellowâ€ or good-looking â€œdark tealâ€. Nothing can be done here. There are no magic colors hiding somewhere that have both good contrast on a white background and look good at the same time. By choosing a light theme, you are dooming yourself to a very limited, bad-looking, barely distinguishable set of dark colors. So it makes sense. Dark themes do look better. Or rather: light ones canâ€™t look good. Science Â¯\\_(ãƒ„)_/Â¯ But! But. There is one trick you can do, that I donâ€™t see a lot of. Use background colors! Compare: The first one has nice colors, but the contrast is too low: letters become hard to read. The second one has good contrast, but you can barely see colors. The last one has both: high contrast and clean, vibrant colors. Lighter colors are readable even on a white background since they fill a lot more area. Text is the same brightness as in the second example, yet it gives the impression of clearer color. Itâ€™s all upside, really. UI designers know about this trick for a while, but I rarely see it applied in code editors: If your editor supports choosing background color, give it a try. It might open light themes for you. Bold and italics Donâ€™t use. This goes into the same category as too many colors. Itâ€™s just another way to highlight something, and you donâ€™t need too many, because you canâ€™t highlight everything. In theory, you might try to replace colors with typography. Would that work? I donâ€™t know. I havenâ€™t seen any examples. Using italics and bold instead of colors Myth of number-based perfection Some themes pay too much attention to be scientifically uniform. Like, all colors have the same exact lightness, and hues are distributed evenly on a circle. This could be nice (to know if you have OCD), but in practice, it doesnâ€™t work as well as it sounds: OkLab l=0.7473 c=0.1253 h=0, 45, 90, 135, 180, 225, 270, 315 The idea of highlighting is to make things stand out. If you make all colors the same lightness and chroma, they will look very similar to each other, and itâ€™ll be hard to tell them apart. Our eyes are way more sensitive to differences in lightness than in color, and we should use it, not try to negate it. Letâ€™s design a color theme together Letâ€™s apply these principles step by step and see where it leads us. We start with the theme from the start of this post: First, letâ€™s remove highlighting from language keywords and re-introduce base text color: Next, we remove color from variable usage: and from function/method invocation: The thinking is that your code is mostly references to variables and method invocation. If we highlight those, weâ€™ll have to highlight more than 75% of your code. Notice that weâ€™ve kept variable declarations. These are not as ubiquitous and help you quickly answer a common question: where does thing thing come from? Next, letâ€™s tone down punctuation: I prefer to dim it a little bit because it helps names stand out more. Names alone can give you the general idea of whatâ€™s going on, and the exact configuration of brackets is rarely equally important. But you might roll with base color punctuation, too: Okay, getting close. Letâ€™s highlight comments: We donâ€™t use red here because you usually need it for squiggly lines and errors. This is still one color too many, so I unify numbers and strings to both use green: Finally, letâ€™s rotate colors a bit. We want to respect nesting logic, so function declarations should be brighter (yellow) than variable declarations (blue). Compare with what we started: In my opinion, we got a much more workable color theme: itâ€™s easier on the eyes and helps you find stuff faster. Shameless plug time Iâ€™ve been applying these principles for about 8 years now. I call this theme Alabaster and Iâ€™ve built it a couple of times for the editors I used: VS Code JetBrains IDEs Sublime Text (twice) Itâ€™s also been ported to many other editors and terminals; the most complete list is probably here. If your editor is not on the list, try searching for it by nameâ€”it might be built-in already! I always wondered where these color themes come from, and now I became an author of one (and I still donâ€™t know). Feel free to use Alabaster as is or build your own theme using the principles outlined in the articleâ€”either is fine by me. As for the principles themselves, they worked out fantastically for me. Iâ€™ve never wanted to go back, and just one look at any â€œtraditionalâ€ color theme gives me a scare now. I suspect that the only reason we donâ€™t see more restrained color themes is that people never really thought about it. Well, this is your wake-up call. I hope this will inspire people to use color more deliberately and to change the default way we build and use color themes."}, :excerpts [{:text "... is â€œnoâ€, then your color theme is not functional. It might give you comfort (as inâ€”I feel...", :matched-terms ["functional"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://rodschmidt.com/posts/scittle/", :title "Mixing Swift and Clojure in Your iOS App - Scittle", :link "https://rodschmidt.com/posts/scittle/", :published-at #inst "2025-12-25T01:10:57.000-00:00", :content "In my previous article, I showed how to embed a S7 Scheme interpreter in an iOS app. This time, I will show you how to embed a ClojureScript interpreter, or at least a dialect of it. Clojure itself, runs on the JVM, and thereâ€™s not really a way to embed the JVM in an iOS app. Maybe once swift-java gets rolling. There is GraalVM, which lets you compile java code to native code, but it doesnâ€™t support compiling for iOS. Babashka, which is a native Clojure dialect interpreter uses GraalVM."}, :excerpts [{:text "Mixing Swift and Clojure in Your iOS App - Scittle", :matched-terms ["clojure"], :source :title} {:text "... I will show you how to embed a ClojureScript interpreter, or at least a dialect of it. Clojure itself, runs on the JVM, and thereâ€™s not really a way to embed the JVM in an iOS app. Maybe once swift-java gets rolling. There is", :matched-terms ["clojure" "jvm" "java"], :source :content} {:text "... which lets you compile java code to native code, but it doesnâ€™t support...", :matched-terms ["java"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://clojure.org/news/2025/12/23/deref", :title "Clojure Deref (Dec 23, 2025)", :link "https://clojure.org/news/2025/12/23/deref", :published-at #inst "2025-12-23T00:00:00.000-00:00", :content "Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed: RSS). The annual Clojure surveys are live Help shape the future of Clojure! Whether you use Clojure, ClojureScript, Babashka, or any other Clojure dialect, please fill out the 2025 State of Clojure Survey and spread the word on social media. This survey gives us the best snapshot of the Clojure community, so help us get as many participants as possible. If you use ClojureScript or dialects like Squint, Cherry, nbb, and such, please fill out the 2025 State of ClojureScript Survey and share it with others. Thank you for your help! Upcoming Events Clojure real-world-data 38: Dec 26 Scicloj AI Meetup: Agent-o-rama: Jan 17 Clojure Jam 2026: Apr 18-19 & 25-26. Online & free! CFP is open until Jan 31st. Babashka Conf: May 8. Amsterdam, NL. Free registration, but tickets are limited! Dutch Clojure Days 2026: May 9th. Amsterdam, NL. Join the waitlist, or the CFP is open until Jan 15th. Podcasts, videos, and media One year of building my own IDE in clojure - phronmophobic Event-sourcing with projections in Clojure and PostgreSQL - Andrey Fadeev Announcing Multi REPL Sessions in Calva - CalvaTV Clojure/Conj 2025 Photos A Decade on Datomic - Davis Shepherd & Jonathan Indig (Netflix) - ClojureTV UnifyBio: Power Tools for Translational Data Science - Benjamin Kamphaus - ClojureTV Cats, Dogs, and Python - Paula Gearon - ClojureTV Agent-o-rama: Scalable, Traceable, Stateful AI agents in Pure Clojure or Java - Nathan Marz - ClojureTV Clojure South 2025 Construindo aplicaÃ§Ãµes web elegantes com ClojureScript, React e UIx! | Clojure South 2025 - Building Nubank Fail fast, fix faster: Injecting failures on integration tests | Clojure South 2025 - Building Nubank Clojure to Elixir: Functional Programming for Scalable & Sustainable Apps | Clojure South 2025 - Building Nubank Clojure e IA: Construindo Agentes Inteligentes sem Reinventar a Roda | Clojure South 2025 - Building Nubank Introduzindo programaÃ§Ã£o funcional na Carteira Digital de TrÃ¢nsito | Clojure South 2025 - Building Nubank NuFileBox Reverse: GestÃ£o segura de arquivos com Clojure | Clojure South 2025 - Building Nubank Uma estratÃ©gia incremental com apoio IA para testes unitÃ¡rios em Clojure | Clojure South 2025 - Building Nubank Betting on open source: Adventures with Datahike | Clojure South 2025 - Building Nubank 12 years of Component | Clojure South 2025 - Building Nubank Blogs, articles, and news A Christmas Present in Clojure â€“ Metosin - Joel Kaasinen Clerk notebooks with solutions for Advent of Code 2025 - Miran Clojurists Together 2026 Annual Funding Announcement - Kathy Davis Announcing Oak 1.0 - Arne Brasseur Easel Turns One! - Adrian Smith (recur thoughts \"Nullable pattern: Experience report\") - Emil Bengtsson Machine Learning in Clojure with libpython-clj: Bridging Functional Elegance and Pythonâ€™s ML Power [Series 1] - Flexiana - Jiri Knesl The Best Things and Stuff of 2025 - Michael Fogus An incremental strategy with AI support for unit testing in Clojure - Building Nubank - Nubank Editorial How NuFilebox Reverse strengthens file security at Nubank - Building Nubank - Nubank Editorial 12 years of Component: A decade of interactive development - Building Nubank - Nubank Editorial Building elegant interfaces with ClojureScript, React, and UIx - Building Nubank - Nubank Editorial Libraries and Tools Debut release cljs-uix-electron - Uix + Electron starter cljs-uix-wails - Wails + ClojureScript starter Oak - Oak is a Free and Open Source Identity Provider that you can host yourself immersa - Open Source Web-based 3D Presentation Tool bb-timemachine - Run code back in Git-time. solid-cljs - ClojureScript bindings to Solid clojars-download-stats - An always up-to-date, complete SQL export of artifacts daily downloads since November 2012 malt - Malli-Typed interfaces for Clojure distributed-scope - Run one lexical scope across distributed peers. Updates repath-studio 0.4.11 - A local web-based vector graphics editor that combines procedural tooling with traditional design workflows. dtype-next 10.000-beta-11 - A Clojure library designed to aid in the implementation of high performance algorithms and systems. repl-mcp d00f661 - Model Context Protocol Clojure support including REPL integration with development tools. virtuoso 0.1.2 - A number of trivial wrappers on top of virtual threads bbin 0.2.5 - Install any Babashka script or project with one command stripe-clojure 2.1.0 - Clojure SDK for the Stripe API. muutos 2025-12-18 - Muutos is a zero-dependency Clojure library for reacting to changes in a PostgreSQL database. cherry 0.5.34 - Experimental ClojureScript to ES6 module compiler nbb 1.3.205 - Scripting in Clojure on Node.js using SCI replicant 2025.12.1 - A data-driven rendering library for Clojure(Script) that renders hiccup to DOM or to strings. joyride 0.0.72 - Making VS Code Hackable like Emacs since 2022 process 0.6.25 - Clojure library for shelling out / spawning sub-processes fireworks 0.19.0 - Fireworks is a themeable tapping library for Clojure, ClojureScript, and Babashka. bling 0.9.2 - Rich text console printing for Clojure, ClojureScript, and Babashka. clj-kondo 2025.12.23 - Static analyzer and linter for Clojure code that sparks joy calva 2.0.543 - Clojure & ClojureScript Interactive Programming for VS Code sci 0.11.50 - Configurable Clojure/Script interpreter suitable for scripting and Clojure DSLs scittle 0.7.30 - Execute Clojure(Script) directly from browser script tags via SCI partial-cps 0.1.42 - A lean and efficient continuation passing style transform, includes async-await support."}, :excerpts [{:text "Clojure Deref (Dec 23, 2025)", :matched-terms ["clojure"], :source :title} {:text "... class=\"paragraph\"> Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed:", :matched-terms ["clojure"], :source :content} {:text "... class=\"sect1\"> The annual Clojure surveys are live", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://clojure.org/news/2025/12/30/deref", :title "Clojure Deref (Dec 30, 2025)", :link "https://clojure.org/news/2025/12/30/deref", :published-at #inst "2025-12-30T00:00:00.000-00:00", :content "Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed: RSS). Last chance for the annual Clojure surveys! Time is running out to take the Clojure surveys! Please help spread the word, and take a moment to fill them out if you havenâ€™t already. Fill out the 2025 State of Clojure Survey if you use any version or dialect of Clojure in any capacity. Fill out the 2025 State of ClojureScript Survey and if you use ClojureScript or dialects like Squint, Cherry, nbb, and such. Thank you for your help! Upcoming Events Clojure real-world-data 39: Jan 2 Scicloj AI Meetup: Agent-o-rama: Jan 17 Clojure Jam 2026: Apr 18-19 & 25-26. Online & free! CFP is open until Jan 31st. Babashka Conf: May 8. Amsterdam, NL. Free registration, but tickets are limited! Dutch Clojure Days 2026: May 9th. Amsterdam, NL. Join the waitlist, or the CFP is open until Jan 15th. Podcasts, videos, and media Browser Jack-in â€“ Connect your Clojure editor to any web page - CalvaTV Clojure/Conj 2025 Rich Hickeyâ€™s opening remarks from Clojure/Conj 2025 - ClojureTV 12 Years of Component - Alessandra Sierra - ClojureTV Blogs, articles, and news Mixing Swift and Clojure in Your iOS App - Scittle - Rod Schmidt Tetris-playing AI the Polylith way - Part 1 - Joakim Tengstrand Implementing the Algebra of Graphics in Clojure - Part 1 â€“ Clojure Civitas - Daniel Slutsky Machine Learning in Clojure with libpythonâ€‘clj: Using Bayesian Networks for Smarter, Interpretable AI [Series 2] - Flexiana - Jiri Knesl Machine Learning in Clojure with libpythonâ€‘clj: Unlocking Causal Insights Using Microsoftâ€™s EconML [Series 3] - Flexiana - Jiri Knesl One csv parser to rule them all - Kasim Tuman Heretic: Mutation Testing in Clojure - Eric Dvorsak Building Heretic: From ClojureStorm to Mutant Schemata - Eric Dvorsak Thanks AI! - Rich Hickey Libraries and Tools Debut release crabjure - A fast static analyzer for Clojure and ClojureScript, written in Rust. browser-jack-in - A web browser extension that letâ€™s you inject a Scittle REPL server into any browser page. clamav-clj - An idiomatic, modern Clojure wrapper for ClamAV. heretic - Mutation testing for Clojure - fast, practical, and integrated Updates Many Clojure contrib libs were updated to move the Clojure dependency to 1.11.4, which is past the CVE fixed in 1.11.2. partial-cps 0.1.50 - A lean and efficient continuation passing style transform, includes async-await support. csvx 68fd22c - A zero dependencies tool that enables you to control how to tokenize, transform and handle files with char(s) separated values in Clojure and ClojureScript. recife 0.22.0 - A Clojure model checker (using the TLA+/TLC engine) polylith 0.3.32 - A tool used to develop Polylith based architectures in Clojure. nrepl 1.5.2 - A Clojure network REPL that provides a server and client, along with some common APIs of use to IDEs and other tools that may need to evaluate Clojure code in remote environments. manifold 0.5.0 - A compatibility layer for event-driven abstractions"}, :excerpts [{:text "Clojure Deref (Dec 30, 2025)", :matched-terms ["clojure"], :source :title} {:text "... class=\"paragraph\"> Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed:", :matched-terms ["clojure"], :source :content} {:text "... id=\"_last_chance_for_the_annual_clojure_surveys\">", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure-db", :item {:feed-id "planet-clojure", :item-id "https://clojure.org/news/2025/12/23/deref", :title "Clojure Deref (Dec 23, 2025)", :link "https://clojure.org/news/2025/12/23/deref", :published-at #inst "2025-12-23T00:00:00.000-00:00", :content "Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed: RSS). The annual Clojure surveys are live Help shape the future of Clojure! Whether you use Clojure, ClojureScript, Babashka, or any other Clojure dialect, please fill out the 2025 State of Clojure Survey and spread the word on social media. This survey gives us the best snapshot of the Clojure community, so help us get as many participants as possible. If you use ClojureScript or dialects like Squint, Cherry, nbb, and such, please fill out the 2025 State of ClojureScript Survey and share it with others. Thank you for your help! Upcoming Events Clojure real-world-data 38: Dec 26 Scicloj AI Meetup: Agent-o-rama: Jan 17 Clojure Jam 2026: Apr 18-19 & 25-26. Online & free! CFP is open until Jan 31st. Babashka Conf: May 8. Amsterdam, NL. Free registration, but tickets are limited! Dutch Clojure Days 2026: May 9th. Amsterdam, NL. Join the waitlist, or the CFP is open until Jan 15th. Podcasts, videos, and media One year of building my own IDE in clojure - phronmophobic Event-sourcing with projections in Clojure and PostgreSQL - Andrey Fadeev Announcing Multi REPL Sessions in Calva - CalvaTV Clojure/Conj 2025 Photos A Decade on Datomic - Davis Shepherd & Jonathan Indig (Netflix) - ClojureTV UnifyBio: Power Tools for Translational Data Science - Benjamin Kamphaus - ClojureTV Cats, Dogs, and Python - Paula Gearon - ClojureTV Agent-o-rama: Scalable, Traceable, Stateful AI agents in Pure Clojure or Java - Nathan Marz - ClojureTV Clojure South 2025 Construindo aplicaÃ§Ãµes web elegantes com ClojureScript, React e UIx! | Clojure South 2025 - Building Nubank Fail fast, fix faster: Injecting failures on integration tests | Clojure South 2025 - Building Nubank Clojure to Elixir: Functional Programming for Scalable & Sustainable Apps | Clojure South 2025 - Building Nubank Clojure e IA: Construindo Agentes Inteligentes sem Reinventar a Roda | Clojure South 2025 - Building Nubank Introduzindo programaÃ§Ã£o funcional na Carteira Digital de TrÃ¢nsito | Clojure South 2025 - Building Nubank NuFileBox Reverse: GestÃ£o segura de arquivos com Clojure | Clojure South 2025 - Building Nubank Uma estratÃ©gia incremental com apoio IA para testes unitÃ¡rios em Clojure | Clojure South 2025 - Building Nubank Betting on open source: Adventures with Datahike | Clojure South 2025 - Building Nubank 12 years of Component | Clojure South 2025 - Building Nubank Blogs, articles, and news A Christmas Present in Clojure â€“ Metosin - Joel Kaasinen Clerk notebooks with solutions for Advent of Code 2025 - Miran Clojurists Together 2026 Annual Funding Announcement - Kathy Davis Announcing Oak 1.0 - Arne Brasseur Easel Turns One! - Adrian Smith (recur thoughts \"Nullable pattern: Experience report\") - Emil Bengtsson Machine Learning in Clojure with libpython-clj: Bridging Functional Elegance and Pythonâ€™s ML Power [Series 1] - Flexiana - Jiri Knesl The Best Things and Stuff of 2025 - Michael Fogus An incremental strategy with AI support for unit testing in Clojure - Building Nubank - Nubank Editorial How NuFilebox Reverse strengthens file security at Nubank - Building Nubank - Nubank Editorial 12 years of Component: A decade of interactive development - Building Nubank - Nubank Editorial Building elegant interfaces with ClojureScript, React, and UIx - Building Nubank - Nubank Editorial Libraries and Tools Debut release cljs-uix-electron - Uix + Electron starter cljs-uix-wails - Wails + ClojureScript starter Oak - Oak is a Free and Open Source Identity Provider that you can host yourself immersa - Open Source Web-based 3D Presentation Tool bb-timemachine - Run code back in Git-time. solid-cljs - ClojureScript bindings to Solid clojars-download-stats - An always up-to-date, complete SQL export of artifacts daily downloads since November 2012 malt - Malli-Typed interfaces for Clojure distributed-scope - Run one lexical scope across distributed peers. Updates repath-studio 0.4.11 - A local web-based vector graphics editor that combines procedural tooling with traditional design workflows. dtype-next 10.000-beta-11 - A Clojure library designed to aid in the implementation of high performance algorithms and systems. repl-mcp d00f661 - Model Context Protocol Clojure support including REPL integration with development tools. virtuoso 0.1.2 - A number of trivial wrappers on top of virtual threads bbin 0.2.5 - Install any Babashka script or project with one command stripe-clojure 2.1.0 - Clojure SDK for the Stripe API. muutos 2025-12-18 - Muutos is a zero-dependency Clojure library for reacting to changes in a PostgreSQL database. cherry 0.5.34 - Experimental ClojureScript to ES6 module compiler nbb 1.3.205 - Scripting in Clojure on Node.js using SCI replicant 2025.12.1 - A data-driven rendering library for Clojure(Script) that renders hiccup to DOM or to strings. joyride 0.0.72 - Making VS Code Hackable like Emacs since 2022 process 0.6.25 - Clojure library for shelling out / spawning sub-processes fireworks 0.19.0 - Fireworks is a themeable tapping library for Clojure, ClojureScript, and Babashka. bling 0.9.2 - Rich text console printing for Clojure, ClojureScript, and Babashka. clj-kondo 2025.12.23 - Static analyzer and linter for Clojure code that sparks joy calva 2.0.543 - Clojure & ClojureScript Interactive Programming for VS Code sci 0.11.50 - Configurable Clojure/Script interpreter suitable for scripting and Clojure DSLs scittle 0.7.30 - Execute Clojure(Script) directly from browser script tags via SCI partial-cps 0.1.42 - A lean and efficient continuation passing style transform, includes async-await support."}, :excerpts [{:text "Clojure Deref (Dec 23, 2025)", :matched-terms ["clojure"], :source :title} {:text "... class=\"paragraph\"> Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed:", :matched-terms ["clojure"], :source :content} {:text "... class=\"sect1\"> The annual Clojure surveys are live", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure-db", :item {:feed-id "planet-clojure", :item-id "https://building.nubank.com/?p=35767", :title "Building elegant interfaces with ClojureScript, React, and UIx", :link "https://building.nubank.com/building-elegant-interfaces-with-clojurescript-react-and-uix/", :published-at #inst "2025-12-23T15:26:47.000-00:00", :content "During Clojure South, JoÃ£o Lanjoni, Software Engineer at Nubank, addressed a central challenge of modern web development: how to combine the ergonomics of ClojureScript with the maturity of React to build scalable, high-performance interfaces. According to JoÃ£o, the solution is UIx, a tool that represents the new generation of bridges that further aligns the Clojure universe with the React ecosystem. In his session, he detailed the context, the limitations of previous approaches, and the value of UIx as a new, efficient entry point for React developers into ClojureScript. From 2013 to today: React and ClojureScript in perspective Since its launch in 2013, React has redefined the structure of frontend applications by introducing concepts like consistent reactivity. The ClojureScript community quickly responded with idiomatic interfaces like Reagent, which became the de facto standard due to its solidity, providing a minimalistic interface between ClojureScript and React, using a Hiccup-like syntax to define components. With the arrival of functional components and hooks, starting around 2019, new interfaces came up to provide a direct way of using functional components (instead of old class-based components). However, as React continuously evolved towards modern patterns, including concurrent rendering, functional components, and new ways to manage component state, Reagent remained tied to class-based components, mainly for backward compatibility. This mismatch resulted in some limitations like performance limitations in large codebases (due to Hiccup parsing in runtime), issues with functional components (as users may have to declare every functional component usage even when they were defined as a React standard), and hindered interoperability with modern React libraries, such as Material UI, Mantine, and Ant Design, widening the gap between the two ecosystems. What UIx changes in your code UIx emerges to resolve this divergence. Acting as a thin interface between ClojureScript and modern React, its focus is technical and pragmatic: it offers a minimal abstraction layer, more predictable performance, and the direct use of functional components and hooks. Furthermore, it ensures native interoperability with the React ecosystem, allowing the lifecycle and state management to be handled directly by React itself. â€œIf React already handles state and lifecycle management well, why not let it do that?â€ JoÃ£o Lanjoni, Software Engineer at Nubank Instead of creating a complete framework or adding unnecessary abstractions, UIx is a lightweight bridge, leveraging what modern React does best, resulting in a ClojureScript codebase with idiomatic syntax but identical behavior to modern React. UIx component structure In practical terms, UIx centralizes component construction around two elements: defui for declaring React components and $ for rendering elements in an explicit and lightweight way. Component bodies process props identically to React. Hooks such as useState are exposed using idiomatic ClojureScript conventions, like use-state, with UIx handling the translation to native React APIs. This ergonomics combines the best of ClojureScript syntax with the React architecture, which, according to JoÃ£o, eliminates the need to train React developers in the internal details of layers like Reagent or Re-frame, keeping the mental model aligned with the React mainstream. Performance in figures A highlight of the presentation was the chart, created by Roman Liutikov â€“ the UIx maintainer â€“, comparing the call stack depth when rendering a simple component in pure React, UIx, and Reagent. React exhibits the shortest path; UIx, by adding only a thin layer, follows closely. In contrast, Reagent, due to Hiccup being interpreted at runtime, shows a significantly deeper call stack. While the difference is minimal in small applications, the impact on predictability and performance becomes notable and increases in products with hundreds or thousands of components. Who is already using UIx in production JoÃ£o presented three real-world examples, all highlighted on the projectâ€™s official page: Metosin, one of the largest Clojure consultancies in Europe; Pitch, an AI presentation platform with amazing slide decks; Cognician, an e-learning platform for personal development. The Pitch case is particularly impressive. The team migrated 2,500 components from Reagent to UIx, maintained compatibility with Re-frame, and saw improvements in predictability and performance. Metosin, meanwhile, employs Juho Teperi, one of the main contributors to Reagent, who also made an example project for a full-stack app using Clojure and ClojureScript and chose UIx to build the web interface, also using Material UI as the component library without any special wrapper. When someone who helped build the previous tool begins to advocate for the new approach, it says a lot about the current moment of the technology, even more with the launch of a new version of Reagent introducing default functional components and a thinner hooks wrapper (inspired also by UIx). Reducing the developer learning curve UIxâ€™s value extends to the hiring and development of engineers, which opens a path for more professionals to enter the ClojureScript ecosystem without the requirement of mastering the intricacies of Reagent, Re-frame, or the atom-based state model from day one. It represents a pragmatic approach to lowering barriers without sacrificing the benefits of a functional and declarative language. â€œThe greatest value of UIx is allowing React developers to write ClojureScript with a minimal learning curve.â€ JoÃ£o Lanjoni, Software Engineer at Nubank When UIx is the best choice UIx is especially recommended for modern and complex front-end applications and teams already familiar with React. It is ideal for codebases that rely heavily on hooks and for projects requiring interoperability with the latest React libraries, with a view toward strong long-term growth potential. The library, intentionally simple, does not attempt to reinvent global state management, maintaining compatibility with mature React libraries like Zustand and Jotai, instead of adding unnecessary layers, or even using a custom hook that subscribes to a Clojure atom to manage a global state (similar to those cited libraries). In essence, UIx does not seek to replace React but rather to act as a thin, modern, and pragmatic bridge. Its goal is to allow teams to build scalable front-ends with the power of React, while preserving the expressiveness and elegance of the Clojure philosophy and syntax. For complex and modern projects in ClojureScript, UIx may be the missing link. The post Building elegant interfaces with ClojureScript, React, and UIx appeared first on Building Nubank."}, :excerpts [{:text "Building elegant interfaces with ClojureScript, React, and UIx", :matched-terms ["clojure"], :source :title} {:text "During Clojure South, JoÃ£o Lanjoni, Software Engineer at Nubank,...", :matched-terms ["clojure"], :source :content} {:text "... development: how to combine the ergonomics of ClojureScript with the maturity of React to build...", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure-db", :item {:feed-id "planet-clojure", :item-id "https://tengstrand.github.io/blog/2025-12-28-tetris-playing-ai-the-polylith-way-1.html", :title "Tetris-playing AI the Polylith way - Part 1", :link "https://tengstrand.github.io/blog/2025-12-28-tetris-playing-ai-the-polylith-way-1.html", :published-at #inst "2025-12-28T23:59:59.000-00:00", :content "In this blog series, I will show how to work with the Polylith architecture and how organizing code into components helps create a good structure for high-level functional style programming. You might feel that organizing into components is unnecessary, and yes, for a tiny codebase like this I would agree. It&aposs still easy to reason about the code and keep everything in mind, but as the codebase grows, so does the value of this structure, in terms of better overview, clearer system boundaries, and increased flexibility in how these building blocks can be combined into various systems. We will get familiar with this by implementing a self-playing Tetris program in Clojure and Python while reflecting on the differences between the two languages. The goal The task for this first post is to place a T piece on a Tetris board (represented by a two-dimensional array): [[0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,0,0,0,0] [0,0,0,0,0,0,T,0,0,0] [0,0,0,0,0,T,T,T,0,0]] We will put the code in the piece and board components in a Polylith workspace (output from the info command): This will not be a complete guide to Polylith, Clojure, or Python, but I will explain the most important parts and refer to relevant documentation when needed. The resulting source code from this first blog post in the series can be found here: The Clojure workspace The Python workspace Workspace We begin by installing the poly command line tool for Clojure, which we will use when working with the Polylith codebase: brew install polyfy/polylith/poly The next step is to create a Polylith workspace: poly create workspace name:tetris-polylith top-ns:tetrisanalyzer We now have a standard Polylith workspace for Clojure in place: â–¾ tetris-polylith â–¸ bases â–¸ components â–¸ development â–¸ projects deps.edn workspace.edn Python We will use uv as package manager for Python (see setup for other alternatives). First we install uv: curl -LsSf https://astral.sh/uv/install.sh | sh Then we create the tetris-polylith-uv workspace directory, by executing: uv init tetris-polylith-uv cd tetris-polylith-uv uv add polylith-cli --dev uv sync which creates: README.md main.py pyproject.toml uv.lock Finally we create the standard Polylith workspace structure: uv run poly create workspace --name tetrisanalyzer --theme loose which adds: â–¾ tetris-polylith-uv â–¸ bases â–¸ components â–¸ development â–¸ projects workspace.toml The workspace requires some additional manual steps, documented here. The piece component Now we are ready to create our first component for the Clojure codebase: poly create component name:piece This adds the piece component to the workspace structure: â–¾ components â–¾ piece â–¾ src â–¾ tetrisanalyzer â–¾ piece interface.clj core.clj â–¾ test â–¾ tetrisanalyzer â–¾ piece interface-test.clj If you have used Polylith with Clojure before, you know that you also need to manually add piece to deps.edn, which is described here. Python Let&aposs do the same for Python: uv run poly create component --name piece This adds the piece component to the structure: â–¾ components â–¾ tetrisanalyzer â–¾ piece __init__.py core.py â–¾ test â–¾ components â–¾ tetrisanalyzer â–¾ piece __init__.py test_core.py Piece shapes In Tetris, there are 7 different pieces that can be rotated, summing up to 19 shapes: Here we will store them in a multi-dimensional array where each possible piece shape is made up of four [x,y] cells, with [0,0] representing the upper left corner. For example the Z piece in its inital position (rotation 0) consists of the cells [0,0] [1,0] [1,1] [2,1]: This is how it looks like in Clojure (commas are treated as white spaces in Clojure and are often omitted): (ns tetrisanalyzer.piece.piece) (def pieces [nil ;; I (1) [[[0 0] [1 0] [2 0] [3 0]] [[0 0] [0 1] [0 2] [0 3]]] ;; Z (2) [[[0 0] [1 0] [1 1] [2 1]] [[1 0] [0 1] [1 1] [0 2]]] ;; S (3) [[[1 0] [2 0] [0 1] [1 1]] [[0 0] [0 1] [1 1] [1 2]]] ;; J (4) [[[0 0] [1 0] [2 0] [2 1]] [[0 0] [1 0] [0 1] [0 2]] [[0 0] [0 1] [1 1] [2 1]] [[1 0] [1 1] [0 2] [1 2]]] ;; L (5) [[[0 0] [1 0] [2 0] [0 1]] [[0 0] [0 1] [0 2] [1 2]] [[2 0] [0 1] [1 1] [2 1]] [[0 0] [1 0] [1 1] [1 2]]] ;; T (6) [[[0 0] [1 0] [2 0] [1 1]] [[0 0] [0 1] [1 1] [0 2]] [[1 0] [0 1] [1 1] [2 1]] [[1 0] [0 1] [1 1] [1 2]]] ;; O (7) [[[0 0] [1 0] [0 1] [1 1]]]]) Python Here is how it looks in Python: pieces = [None, # I (1) [[[0, 0], [1, 0], [2, 0], [3, 0]], [[0, 0], [0, 1], [0, 2], [0, 3]]], # Z (2) [[[0, 0], [1, 0], [1, 1], [2, 1]], [[1, 0], [0, 1], [1, 1], [0, 2]]], # S (3) [[[1, 0], [2, 0], [0, 1], [1, 1]], [[0, 0], [0, 1], [1, 1], [1, 2]]], # J (4) [[[0, 0], [1, 0], [2, 0], [2, 1]], [[0, 0], [1, 0], [0, 1], [0, 2]], [[0, 0], [0, 1], [1, 1], [2, 1]], [[1, 0], [1, 1], [0, 2], [1, 2]]], # L (5) [[[0, 0], [1, 0], [2, 0], [0, 1]], [[0, 0], [0, 1], [0, 2], [1, 2]], [[2, 0], [0, 1], [1, 1], [2, 1]], [[0, 0], [1, 0], [1, 1], [1, 2]]], # T (6) [[[0, 0], [1, 0], [2, 0], [1, 1]], [[0, 0], [0, 1], [1, 1], [0, 2]], [[1, 0], [0, 1], [1, 1], [2, 1]], [[1, 0], [0, 1], [1, 1], [1, 2]]], # O (7) [[[0, 0], [1, 0], [0, 1], [1, 1]]]] In Clojure we had to specify the namespace at the top of the file, but in Python, the namespace is implicitly given based on the directory hierarchy. Here we put the above code in shape.py, and it will therefore automatically belong to the tetrisanalyzer.piece.shape module: â–¾ tetris-polylith-uv â–¾ components â–¾ tetrisanalyzer â–¾ piece __init__.py shape.py Interface In Polylith, only what&aposs in the component&aposs interface is exposed to the rest of the codebase. In Python, we can optionally control what gets exposed in wildcard imports (from module import *) by defining the __all__ variable in the __init__.py module. However, even without __all__, all public names (those not starting with _) are still accessible through explicit imports. This is how the piece interface in __init__.py looks like: from tetrisanalyzer.piece.core import I, Z, S, J, L, T, O, piece __all__ = [\"I\", \"Z\", \"S\", \"J\", \"L\", \"T\", \"O\", \"piece\"] We could have put all the code directly in __init__.py, but it&aposs a common pattern in Python to keep this module clean by delegating to implementation modules like core.py: from tetrisanalyzer.piece import shape I = 1 Z = 2 S = 3 J = 4 L = 5 T = 6 O = 7 def piece(p, rotation): return shape.pieces[p][rotation] The piece component now has these files: â–¾ tetris-polylith-uv â–¾ components â–¾ tetrisanalyzer â–¾ piece __init__.py core.py shape.py Clojure In Clojure, the interface is often just a single namespace with the name interface: â–¾ components â–¾ piece â–¾ src â–¾ tetrisanalyzer â–¾ piece interface.clj Implemented like this: (ns tetrisanalyzer.piece.interface (:require [tetrisanalyzer.piece.shape :as shape])) (def I 1) (def Z 2) (def S 3) (def J 4) (def L 5) (def T 6) (def O 7) (defn piece [p rotation] (get-in shape/pieces [p rotation])) A language comparision Let&aposs see what differences there are in the two languages: ;; Clojure (defn piece [p rotation] (get-in shape/pieces [p rotation])) # Python def piece(p, rotation): return shape.pieces[p][rotation] An obvious difference here is that Clojure is a Lisp dialect, while Python uses a more traditional syntax. This means that if you want anything to happen in Clojure, you put it first in a list: (defn piece ...) is a macro that expands to (def piece (fn ...)) which defines the function piece (get-in shape/pieces [p rotation]) is a call to the function clojure.core/get-in, where: The first argument shape/pieces refers to the pieces vector in the shape namespace The second argument creates the vector [p rotation] with two arguments: p is a value between 1 and 7, representing one of the pieces: I, Z, S, J, L, T, and O rotation is a value between 0 and 3, representing the number of 90-degree rotations Another significant difference is that data is immutable in Clojure, while in Python it&aposs mutable (like the pieces data structure). However, a similarity is that both languages are dynamically typed, but uses concrete types in the compiled code: ;; Clojure (class \\Z) ;; Returns java.lang.Character (class 2) ;; Returns java.lang.Long (class Z) ;; Returns java.lang.Long (since Z is bound to 2) # Python type(&aposZ&apos) # Returns (characters are strings in Python) type(2) # Returns type(Z) # Returns (since Z is bound to 2) The languages also share another feature: type information can be added optionally. In Clojure, this is done using type hints for Java interop and performance optimization. In Python, type hints (introduced in Python 3.5) can be added using the typing module, though they are not enforced at runtime and are primarily used for static type checking with tools like mypy. The board component Now let&aposs continue by creating a board component: poly create component name:board Which adds the board component to the workspace: â–¾ tetris-polylith â–¸ bases â–¾ components â–¸ board â–¸ piece â–¸ development â–¸ projects And this is how we create a board component in Python: uv run poly create component --name board This adds the board component to the workspace: â–¾ components â–¾ tetrisanalyzer â–¸ board â–¸ piece â–¾ test â–¾ components â–¾ tetrisanalyzer â–¸ board â–¸ piece The Clojure code that places a piece on the board is implemented like this: (ns tetrisanalyzer.board.core) (defn empty-board [width height] (vec (repeat height (vec (repeat width 0))))) (defn set-cell [board p x y [cx cy]] (assoc-in board [(+ y cy) (+ x cx)] p)) (defn set-piece [board p x y piece] (reduce (fn [board cell] (set-cell board p x y cell)) board piece)) In Python (which uses two blank lines between functions by default): def empty_board(width, height): return [[0] * width for _ in range(height)] def set_cell(board, p, x, y, cell): cx, cy = cell board[y + cy][x + cx] = p def set_piece(board, p, x, y, piece): for cell in piece: set_cell(board, p, x, y, cell) return board Let&aposs go through these functions. empty-board (defn empty-board [width height] (vec (repeat height (vec (repeat width 0))))) To explain this function, we can break it down into smaller statements: (defn empty-board [width height] ;; [4 2] (let [row-list (repeat width 0) ;; (0 0 0 0) row (vec row-list) ;; [0 0 0 0] rows (repeat height row) ;; ([0 0 0 0] [0 0 0 0]) board (vec rows)] ;; [[0 0 0 0] [0 0 0 0]] board)) We convert the lists to vectors using the vec function, so that we (later) can access it via index. Note that it is the last value in the function (board) that is returned. empty_board def empty_board(width, height): return [[0] * width for _ in range(height)] This can be rewritten as: def empty_board(width, height): # width = 4, height = 2 row = [0] * width # row = [0, 0, 0, 0] rows = range(height) # rows = lazy sequence with the length of 2 board = [row for _ in rows] # board = [[0, 0, 0, 0], [0, 0, 0, 0]] return board The [row for _ in rows] statement is a list comprehension and is a way to create data structures in Python by looping. We loop twice through range(height), which yields the values 0 and 1, but we&aposre not interested in these values, so we use the _ placeholder. set-cell (defn set-cell [board p x y [cx cy]] (assoc-in board [(+ y cy) (+ x cx)] p)) Let&aposs break it down into an alternative implementation and call it with: board = [[0 0 0 0] [0 0 0 0]] p = 6, x = 2, y = 0, cell = [0 1]) (defn set-cell [board p x y cell] (let [[cx cy] cell ;; Destructures [0 1] into cx = 0, cy = 1 xx (+ x cx) ;; xx = 2 + 0 = 2 yy (+ y cy)] ;; yy = 0 + 1 = 1 (assoc-in board [yy xx] p))) ;; [[0 0 0 0] [0 0 6 0]] In the original version, destructuring of [cx cy] happens directly in the function&aposs parameter list. The assoc-in function works like board[y][x] in Python in this example, with the difference that it doesn&apost mutate, but instead returns a new immutable board. set_cell def set_cell(board, p, x, y, cell): cx, cy = cell board[y + cy][x + cx] = p # [[0,0,0,0] [0,0,6,0]] As mentioned earlier, this code mutates the two-dimensional list in place. It doesn&apost return anything, which differs from the Clojure version that returns a new board with one cell changed. set-piece (defn set-piece [board p x y piece] (reduce (fn [board cell] (set-cell board p x y cell)) board ;; An empty board as initial value piece)) ;; cells: [[1 0] [0 1] [1 1] [2 1]] If you are new to reduce, think of it as a recursive function that processes each element in a collection, accumulating a result as it goes. The initial call to set-cell will use an empty board and the first [1 0] cell from piece, then use the returned board from set-cell and the second cell [0 1] from piece to call set-cell again, and continue like that until it has applied all cells in piece, where it returns a new board. set_piece def set_piece(board, p, x, y, piece): for cell in piece: set_cell(board, p, x, y, cell) return board The Python version is pretty straight forward, with a for loop that mutates the board. We choose to return the board to make the function more flexible, allowing it to be used in expressions and enabling method chaining, which is a common Python pattern, even though the board is already mutated in place. Test The test looks like this in Clojure: (ns tetrisanalyzer.board.core-test (:require [clojure.test :refer :all] [tetrisanalyzer.piece.interface :as piece] [tetrisanalyzer.board.core :as board])) (def empty-board [[0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0]]) (deftest empty-board-test (is (= empty-board (board/empty-board 10 15)))) (deftest set-piece-test (let [T piece/T rotate-two-times 2 piece-t (piece/piece T rotate-two-times) x 5 y 13] (is (= [[0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 T 0 0 0] [0 0 0 0 0 T T T 0 0]] (board/set-piece empty-board T x y piece-t))))) Let&aposs execute the tests to check that everything works as expected: poly test :dev The tests passed! Python Now, let&aposs add a Python test for the board: from tetrisanalyzer import board, piece empty_board = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ] def test_empty_board(): assert empty_board == board.empty_board(10, 15) def test_set_piece(): T = piece.T rotate_two_times = 2 piece_t = piece.piece(T, rotate_two_times) x = 5 y = 13 expected = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, T, 0, 0, 0], [0, 0, 0, 0, 0, T, T, T, 0, 0], ] assert expected == board.set_piece(empty_board, T, x, y, piece_t) Let&aposs install and run the tests using pytest: uv add pytest --dev And run the tests: uv run pytest With that, we have finished the first post in this blog series! If you&aposre eager to see a self-playing Tetris program, I happen to have made a couple in other languages that you can watch here. Happy Coding!"}, :excerpts [{:text "... helps create a good structure for high-level functional style programming. You might feel that...", :matched-terms ["functional"], :source :content} {:text "... in Clojure and", :matched-terms ["clojure"], :source :content} {:text "... array): [[0,0,0,0,0,0,0,0,0,0]\n [0,0,0,0,0,0,0,0,0,0]\n...", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure-db", :item {:feed-id "planet-clojure", :item-id "https://blog.parenstech.com/2025-12-28-heretic-mutation-testing.html", :title "Heretic: Mutation Testing in Clojure", :link "https://blog.parenstech.com/2025-12-28-heretic-mutation-testing.html", :published-at #inst "2025-12-28T23:59:59.000-00:00", :content "Your tests pass. Your coverage is high. You deploy. Three days later, a bug surfaces in a function your tests definitely executed. The coverage report confirms it: that line is green. Your test ran the code. So how did a bug slip through? Because coverage measures execution, not verification. (defn apply-discount [price user] (if (:premium user) (* price 0.8) price)) (deftest apply-discount-test (is (number? (apply-discount 100 {:premium true}))) (is (number? (apply-discount 100 {:premium false})))) Coverage: 100%. Every branch executed. Tests: green. But swap 0.8 for 1.2? Tests pass. Change * to /? Tests pass. Flip (:premium user) to (not (:premium user))? Tests pass. The tests prove some number comes back. They say nothing about whether it&aposs the right number. The Question Nobody&aposs Asking Mutation testing asks a harder question: if I introduced a bug, would any test notice? The technique is simple. Take your code, introduce a small change (a \"mutant\"), and run your tests. If a test fails, the mutant is \"killed\" - your tests caught the bug. If all tests pass, the mutant \"survived\" - you&aposve found a gap in your verification. This isn&apost new. PIT does it for Java. Stryker does it for JavaScript. cargo-mutants does it for Rust. Clojure hasn&apost had a practical option. The only dedicated tool, jstepien/mutant, was archived this year as \"wildly experimental.\" You can run PIT on Clojure bytecode, but bytecode mutations bear no relationship to mistakes Clojure developers actually make. You&aposll get mutations like \"swap IADD for ISUB\" when what you want is \"swap -> for ->> \" or \"change :user-id to :userId.\" Why Clojure Makes This Hard Mutation testing has a performance problem everywhere. Run 500 mutations, execute your full test suite for each one, and you&aposre measuring build times in hours. Most developers try it once, watch the clock, and never run it again. But Clojure adds unique challenges: Homoiconicity cuts both ways. Code-as-data makes programmatic transformation elegant, but distinguishing \"meaningful mutation\" from \"syntactic noise\" gets subtle when everything is just nested lists. Macros muddy the waters. A mutation to macro input might not change the expanded code. A mutation inside a macro definition might break in ways that have nothing to do with your production logic. The bugs we make are language-specific. Threading macro confusion, nil punning traps, destructuring gotchas from JSON interop, keyword naming collisions - these aren&apost + becoming -. They&aposre mistakes that come from thinking in Clojure. What If It Could Be Fast? The insight that makes Heretic practical: most mutations only need 2-3 tests. When you mutate a single expression, you don&apost need your entire test suite. You need only the tests that exercise that expression. Usually that&aposs a handful of tests, not hundreds. The challenge is knowing which ones. Not just which functions they call, but which subexpressions they touch. The + inside (if condition (+ a b) (* a b)) might be covered by different tests than the *. Heretic builds this map using ClojureStorm, the instrumented compiler behind FlowStorm. Run your tests once under instrumentation. From then on, each mutation runs only the tests that actually touch that code. Instead of running 200 tests per mutation, we run 2. Instead of hours, seconds. What If It Understood Clojure? Generic operators miss the bugs we actually make: ;; The mutation you want: threading macro confusion (-> data (get :users) first) ; Original (->> data (get :users) first) ; Mutant: wrong arg position, wrong result ;; The mutation you want: nil punning trap (when (seq users) (map :name users)) ; Original (handles empty) (when users (map :name users)) ; Mutant (breaks on empty list) ;; The mutation you want: destructuring gotcha {:keys [user-id name]} ; Original (kebab-case) {:keys [userId name]} ; Mutant (camelCase from JSON) Heretic has 65+ mutation operators designed for Clojure idioms. Swap first for last. Change rest to next. Replace -> with some->. Mutate qualified keywords. The mutations you see will be the bugs you recognize. What If It Could Think? Here&aposs a finding that should worry anyone relying on traditional mutation testing: research shows that nearly half of real-world faults have no strongly coupled traditional mutant. The bugs that escape to production aren&apost the ones that flip operators. They&aposre the ones that invert business logic. ;; Traditional mutation: swap * for / (* price 0.8) --> (/ price 0.8) ; Absurd. Nobody writes this bug. ;; Semantic mutation: invert the discount (* price 0.8) --> (* price 1.2) ; Premium users pay MORE. Plausible bug. A function called apply-discount should never increase the price. That&aposs the invariant tests should verify. An AI can read function names, docstrings, and context to generate the mutations that test whether your tests understand the code&aposs purpose. This hybrid approach - fast deterministic mutations for the common cases, intelligent semantic mutations for the subtle ones - is where Heretic is heading. Meta&aposs ACH system proved the pattern works at industrial scale. Why \"Heretic\"? Clojure discourages mutation. Values are immutable. State changes through controlled transitions. The design philosophy is that uncontrolled mutation leads to bugs. So there&aposs something a bit ironic about a tool that deliberately introduces mutations to find those bugs. We mutate your code to prove your tests would catch it if it happened accidentally - to verify that the discipline holds. This is the first in a series on building Heretic. Upcoming posts will cover how ClojureStorm enables expression-level coverage mapping, how we use rewrite-clj and clj-reload for hot-swapping mutants, and the optimization techniques that make this practical for real codebases. If your coverage is high but bugs still slip through, you&aposre measuring the wrong thing."}, :excerpts [{:text "Heretic: Mutation Testing in Clojure", :matched-terms ["clojure"], :source :title} {:text "... not verification. (defn apply-discount [price user]\n  (if...", :matched-terms ["clojure"], :source :content} {:text "... does it for Rust. Clojure hasn&apost had a practical option. The...", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure-db", :item {:feed-id "planet-clojure", :item-id "https://clojure.org/news/2025/12/30/deref", :title "Clojure Deref (Dec 30, 2025)", :link "https://clojure.org/news/2025/12/30/deref", :published-at #inst "2025-12-30T00:00:00.000-00:00", :content "Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed: RSS). Last chance for the annual Clojure surveys! Time is running out to take the Clojure surveys! Please help spread the word, and take a moment to fill them out if you havenâ€™t already. Fill out the 2025 State of Clojure Survey if you use any version or dialect of Clojure in any capacity. Fill out the 2025 State of ClojureScript Survey and if you use ClojureScript or dialects like Squint, Cherry, nbb, and such. Thank you for your help! Upcoming Events Clojure real-world-data 39: Jan 2 Scicloj AI Meetup: Agent-o-rama: Jan 17 Clojure Jam 2026: Apr 18-19 & 25-26. Online & free! CFP is open until Jan 31st. Babashka Conf: May 8. Amsterdam, NL. Free registration, but tickets are limited! Dutch Clojure Days 2026: May 9th. Amsterdam, NL. Join the waitlist, or the CFP is open until Jan 15th. Podcasts, videos, and media Browser Jack-in â€“ Connect your Clojure editor to any web page - CalvaTV Clojure/Conj 2025 Rich Hickeyâ€™s opening remarks from Clojure/Conj 2025 - ClojureTV 12 Years of Component - Alessandra Sierra - ClojureTV Blogs, articles, and news Mixing Swift and Clojure in Your iOS App - Scittle - Rod Schmidt Tetris-playing AI the Polylith way - Part 1 - Joakim Tengstrand Implementing the Algebra of Graphics in Clojure - Part 1 â€“ Clojure Civitas - Daniel Slutsky Machine Learning in Clojure with libpythonâ€‘clj: Using Bayesian Networks for Smarter, Interpretable AI [Series 2] - Flexiana - Jiri Knesl Machine Learning in Clojure with libpythonâ€‘clj: Unlocking Causal Insights Using Microsoftâ€™s EconML [Series 3] - Flexiana - Jiri Knesl One csv parser to rule them all - Kasim Tuman Heretic: Mutation Testing in Clojure - Eric Dvorsak Building Heretic: From ClojureStorm to Mutant Schemata - Eric Dvorsak Thanks AI! - Rich Hickey Libraries and Tools Debut release crabjure - A fast static analyzer for Clojure and ClojureScript, written in Rust. browser-jack-in - A web browser extension that letâ€™s you inject a Scittle REPL server into any browser page. clamav-clj - An idiomatic, modern Clojure wrapper for ClamAV. heretic - Mutation testing for Clojure - fast, practical, and integrated Updates Many Clojure contrib libs were updated to move the Clojure dependency to 1.11.4, which is past the CVE fixed in 1.11.2. partial-cps 0.1.50 - A lean and efficient continuation passing style transform, includes async-await support. csvx 68fd22c - A zero dependencies tool that enables you to control how to tokenize, transform and handle files with char(s) separated values in Clojure and ClojureScript. recife 0.22.0 - A Clojure model checker (using the TLA+/TLC engine) polylith 0.3.32 - A tool used to develop Polylith based architectures in Clojure. nrepl 1.5.2 - A Clojure network REPL that provides a server and client, along with some common APIs of use to IDEs and other tools that may need to evaluate Clojure code in remote environments. manifold 0.5.0 - A compatibility layer for event-driven abstractions"}, :excerpts [{:text "Clojure Deref (Dec 30, 2025)", :matched-terms ["clojure"], :source :title} {:text "... class=\"paragraph\"> Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed:", :matched-terms ["clojure"], :source :content} {:text "... id=\"_last_chance_for_the_annual_clojure_surveys\">", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure-db", :item {:feed-id "planet-clojure", :item-id "https://blog.michielborkent.nl/oss-updates-nov-dec-2025.html", :title "OSS updates November and December 2025", :link "https://blog.michielborkent.nl/oss-updates-nov-dec-2025.html", :published-at #inst "2026-01-01T23:59:59.000-00:00", :content "In this post I&aposll give updates about open source I worked on during November and December 2025. To see previous OSS updates, go here. Sponsors I&aposd like to thank all the sponsors and contributors that make this work possible. Without you, the below projects would not be as mature or wouldn&apost exist or be maintained at all! So a sincere thank you to everyone who contributes to the sustainability of these projects. Current top tier sponsors: Clojurists Together Roam Research Nextjournal Nubank Open the details section for more info about sponsoring. Sponsor info If you want to ensure that the projects I work on are sustainably maintained, you can sponsor this work in the following ways. Thank you! Github Sponsors The Babashka or Clj-kondo OpenCollective Ko-fi Patreon Clojurists Together Updates Clojure Conj 2025 Last November I had the honor and pleasure to visit the Clojure Conj 2025. I met a host of wonderful and interesting long-time and new Clojurians, many that I&aposve known online for a long time and now met for the first time. It was especially exciting to finally meet Rich Hickey and talk to him during a meeting about Clojure dialects and Clojure tooling. The talk that I gave there: \"Making tools developers actually use\" will come online soon. Babashka conf and Dutch Clojure Days 2026 In 2026 I&aposm organizing Babashka Conf 2026. It will be an afternoon event (13:00-17:00) hosted in the Forum hall of the beautiful public library of Amsterdam. More information here. Get your ticket via Meetup.com (currently there&aposs a waiting list, but more places will come available once speakers are confirmed). CfP will open mid January. The day after babashka conf, Dutch Clojure Days 2026 will be happening. It&aposs not too late to get your talk proposal in. More info here. Projects Here are updates about the projects/libraries I&aposve worked on in the last two months in detail. babashka: native, fast starting Clojure interpreter for scripting. Bump process to 0.6.25 Bump deps.clj Fix #1901: add java.security.DigestOutputStream Redefining namespace with ns should override metadata Bump nextjournal.markdown to 0.7.222 Bump edamame to 1.5.37 Fix #1899: with-meta followed by dissoc on records no longer works Bump fs to 0.5.30 Bump nextjournal.markdown to 0.7.213 Fix #1882: support for reifying java.time.temporal.TemporalField (@EvenMoreIrrelevance) Bump Selmer to 1.12.65 SCI: sci.impl.Reflector was rewritten into Clojure dissoc on record with non-record field should return map instead of record Bump edamame to 1.5.35 Bump core.rrb-vector to 0.2.0 Migrate detecting of executable name for self-executing uberjar executable from ProcessHandle to to native image ProcessInfo to avoid sandbox errors Bump cli to 0.8.67 Bump fs to 0.5.29 Bump nextjournal.markdown to 0.7.201 SCI: Configurable Clojure/Script interpreter suitable for scripting Add support for :refer-global and :require-global Add println-str Fix #997: Var is mistaken for local when used under the same name in a let body Fix #1001: JS interop with reserved js keyword fails (regression of #987) sci.impl.Reflector was rewritten into Clojure Fix babashka/babashka#1886: Return a map when dissociating a record basis field. Fix #1011: reset ns metadata when evaluating ns form multiple times Fix for https://github.com/babashka/babashka/issues/1899 Fix #1010: add js-in in CLJS Add array-seq clj-kondo: static analyzer and linter for Clojure code that sparks joy. #2600: NEW linter: unused-excluded-var to warn on unused vars in :refer-clojure :exclude (@jramosg) #2459: NEW linter: :destructured-or-always-evaluates to warn on s-expressions in :or defaults in map destructuring (@jramosg) Add type checking support for sorted-map-by, sorted-set, and sorted-set-by functions (@jramosg) Add new type array and type checking support for the next functions: to-array, alength, aget, aset and aclone (@jramosg) Fix #2695: false positive :unquote-not-syntax-quoted in leiningen&aposs defproject Leiningen&aposs defproject behavior can now be configured using leiningen.core.project/defproject Fix #2699: fix false positive unresolved string var with extend-type on CLJS Rename :refer-clojure-exclude-unresolved-var linter to unresolved-excluded-var for consistency v2025.12.23 #2654: NEW linter: redundant-let-binding, defaults to :off (@tomdl89) #2653: NEW linter: :unquote-not-syntax-quoted to warn on ~ and ~@ usage outside syntax-quote (`) (@jramosg) #2613: NEW linter: :refer-clojure-exclude-unresolved-var to warn on non-existing vars in :refer-clojure :exclude (@jramosg) #2668: Lint & syntax errors in let bindings and lint for trailing & (@tomdl89) #2590: duplicate-key-in-assoc changed to duplicate-key-args, and now lints dissoc, assoc! and dissoc! too (@tomdl89) #2651: resume linting after paren mismatches clojure-lsp#2651: Fix inner class name for java-class-definitions. clojure-lsp#2651: Include inner class java-class-definition analysis. Bump babashka/fs #2532: Disable :duplicate-require in require + :reload / :reload-all #2432: Don&apost warn for :redundant-fn-wrapper in case of inlined function #2599: detect invalid arity for invoking collection as higher order function #2661: Fix false positive :unexpected-recur when recur is used inside clojure.core.match/match (@jramosg) #2617: Add types for repeatedly (@jramosg) Add :ratio type support for numerator and denominator functions (@jramosg) #2676: Report unresolved namespace for namespaced maps with unknown aliases (@jramosg) #2683: data argument of ex-info may be nil since clojure 1.12 Bump built-in ClojureScript analysis info Fix #2687: support new :refer-global and :require-global ns options in CLJS Fix #2554: support inline configs in .cljc files edamame: configurable EDN and Clojure parser with location metadata and more Edamame: configurable EDN and Clojure parser with location metadata and more Minor: leave out :edamame/read-cond-splicing when not splicing Allow :read-cond function to override :edamame/read-cond-splicing value The result from :read-cond with a function should be spliced. This behavior differs from :read-cond + :preserve which always returns a reader conditional object which cannot be spliced. Support function for :features option to just select the first feature that occurs squint: CLJS syntax to JS compiler Allow macro namespaces to load \"node:fs\", etc. to read config files for conditional compilation Don&apost emit IIFE for top-level let so you can write let over defn to capture values. Fix js-yield and js-yield* in expression position Implement some? as macro Fix #758: volatile!, vswap!, vreset! pr-str, prn etc now print EDN (with the idea that you can paste it back into your program) new #js/Map reader that reads a JavaScript Map from a Clojure map (maps are printed like this with pr-str too) Support passing keyword to mapv #759: doseq can&apost be used in expression context Fix #753: optimize output of dotimes alength as macro reagami: A minimal zero-deps Reagent-like for Squint and CLJS Performance enhancements treat innerHTML as a property rather than an attribute Drop support for camelCased properties / (css) attributes Fix :default-value in input range Support data param in :on-render Support default values for uncontrolled components Fix child count mismatch Fix re-rendering/patching of subroots Add :on-render hook for mounting/updating/unmounting third part JS components NEW: parmezan: fixes unbalanced or unexpected parens or other delimiters in Clojure files CLI: Turn Clojure functions into CLIs! #126: - value accidentally parsed as option, e.g. --file - #124: Specifying exec fn that starts with hyphen is treated as option Drop Clojure 1.9 support. Minimum Clojure version is now 1.10.3. clerk: Moldable Live Programming for Clojure always analyze doc (but not deps) when no-cache is set (#786) add option to disable inline formulas in markdown (#780) scittle: Execute Clojure(Script) directly from browser script tags via SCI #114: Enable source maps (@jeroenvandijk) #140: Enable customizing the nrepl websocket port (@PEZ) Bump shadow-cljs and SCI Nextjournal Markdown Add config option to avoid TeX formulas API improvements for passing options cherry: Experimental ClojureScript to ES6 module compiler Fix cherry compile CLI command not receiving file arguments Bump shadow-cljs to 3.3.4 Fix #163: Add assert to macros (@willcohen) Fix #165: Fix ClojureScript protocol dispatch functions (@willcohen) Fix #167: Protocol dispatch functions inside IIFEs; bump squint accordingly Fix #169: fix extend-type on Object Fix #171: Add satisfies? macro (@willcohen) deps.clj: A faithful port of the clojure CLI bash script to Clojure Released several versions catching up with the clojure CLI quickdoc: Quick and minimal API doc generation for Clojure Fix extra newline in codeblock quickblog: light-weight static blog engine for Clojure and babashka Add support for a blog contained within another website; see Serving an alternate content root in README. (@jmglov) Upgrade babashka/http-server to 0.1.14 Fix :blog-image-alt option being ignored when using CLI (bb quickblog render) nbb: Scripting in Clojure on Node.js using SCI #395: fix vim-fireplace infinite loop on nREPL session close. Add ILookup and Cons Add abs nREPL: support \"completions\" op neil: A CLI to add common aliases and features to deps.edn-based projects. neil.el - a hook that runs after finding a package (@agzam) neil.el - adds a function for injecting a found package into current CIDER session (@agzam) #245: neil.el - neil-executable-path now can be set to clj -M:neil #251: Upgrade library deps-new to 0.10.3 #255: update maven search URL fs - File system utility library for Clojure #154 reflect in directory check and docs that move never follows symbolic links (@lread) #181 delete-tree now deletes broken symbolic link root (@lread) #193 create-dirs now recognizes sym-linked dirs on JDK 11 (@lread) #184: new check in copy-tree for copying to self too rigid #165: zip now excludes zip-file from zip-file (@lread) #167: add root fn which exposes Path getRoot (@lread) #166: copy-tree now fails fast on attempt to copy parent to child (@lread) #152: an empty-string path \"\" is now (typically) understood to be the current working directory (as per underlying JDK file APIs) (@lread) #155: fs/with-temp-dir clj-kondo linting refinements (@lread) #162: unixify no longer expands into absolute path on Windows (potentially BREAKING) Add return type hint to read-all-bytes process: Clojure library for shelling out / spawning sub-processes #181: support :discard or ProcessBuilder$Redirect as :out and :err options Contributions to third party projects: ClojureScript CLJS-3466: support qualified method in return position CLJS-3468: :refer-global should not make unrenamed object available Other projects These are (some of the) other projects I&aposm involved with but little to no activity happened in the past month. Click for more details - [pod-babashka-go-sqlite3](https://github.com/babashka/pod-babashka-go-sqlite3): A babashka pod for interacting with sqlite3 - [unused-deps](https://github.com/borkdude/unused-deps): Find unused deps in a clojure project - [pod-babashka-fswatcher](https://github.com/babashka/pod-babashka-fswatcher): babashka filewatcher pod - [sci.nrepl](https://github.com/babashka/sci.nrepl): nREPL server for SCI projects that run in the browser - [babashka.nrepl-client](https://github.com/babashka/nrepl-client) - [http-server](https://github.com/babashka/http-server): serve static assets - [nbb](https://github.com/babashka/nbb): Scripting in Clojure on Node.js using SCI - [sci.configs](https://github.com/babashka/sci.configs): A collection of ready to be used SCI configs. - [http-client](https://github.com/babashka/http-client): babashka's http-client - [html](https://github.com/borkdude/html): Html generation library inspired by squint's html tag - [instaparse-bb](https://github.com/babashka/instaparse-bb): Use instaparse from babashka - [sql pods](https://github.com/babashka/babashka-sql-pods): babashka pods for SQL databases - [rewrite-edn](https://github.com/borkdude/rewrite-edn): Utility lib on top of - [rewrite-clj](https://github.com/clj-commons/rewrite-clj): Rewrite Clojure code and edn - [tools-deps-native](https://github.com/babashka/tools-deps-native) and [tools.bbuild](https://github.com/babashka/tools.bbuild): use tools.deps directly from babashka - [bbin](https://github.com/babashka/bbin): Install any Babashka script or project with one command - [qualify-methods](https://github.com/borkdude/qualify-methods) - Initial release of experimental tool to rewrite instance calls to use fully qualified methods (Clojure 1.12 only) - [tools](https://github.com/borkdude/tools): a set of [bbin](https://github.com/babashka/bbin/) installable scripts - [babashka.json](https://github.com/babashka/json): babashka JSON library/adapter - [speculative](https://github.com/borkdude/speculative) - [squint-macros](https://github.com/squint-cljs/squint-macros): a couple of macros that stand-in for [applied-science/js-interop](https://github.com/applied-science/js-interop) and [promesa](https://github.com/funcool/promesa) to make CLJS projects compatible with squint and/or cherry. - [grasp](https://github.com/borkdude/grasp): Grep Clojure code using clojure.spec regexes - [lein-clj-kondo](https://github.com/clj-kondo/lein-clj-kondo): a leiningen plugin for clj-kondo - [http-kit](https://github.com/http-kit/http-kit): Simple, high-performance event-driven HTTP client+server for Clojure. - [babashka.nrepl](https://github.com/babashka/babashka.nrepl): The nREPL server from babashka as a library, so it can be used from other SCI-based CLIs - [jet](https://github.com/borkdude/jet): CLI to transform between JSON, EDN, YAML and Transit using Clojure - [lein2deps](https://github.com/borkdude/lein2deps): leiningen to deps.edn converter - [cljs-showcase](https://github.com/borkdude/cljs-showcase): Showcase CLJS libs using SCI - [babashka.book](https://github.com/babashka/book): Babashka manual - [pod-babashka-buddy](https://github.com/babashka/pod-babashka-buddy): A pod around buddy core (Cryptographic Api for Clojure). - [gh-release-artifact](https://github.com/borkdude/gh-release-artifact): Upload artifacts to Github releases idempotently - [carve](https://github.com/borkdude/carve) - Remove unused Clojure vars - [4ever-clojure](https://github.com/oxalorg/4ever-clojure) - Pure CLJS version of 4clojure, meant to run forever! - [pod-babashka-lanterna](https://github.com/babashka/pod-babashka-lanterna): Interact with clojure-lanterna from babashka - [joyride](https://github.com/BetterThanTomorrow/joyride): VSCode CLJS scripting and REPL (via [SCI](https://github.com/babashka/sci)) - [clj2el](https://borkdude.github.io/clj2el/): transpile Clojure to elisp - [deflet](https://github.com/borkdude/deflet): make let-expressions REPL-friendly! - [deps.add-lib](https://github.com/borkdude/deps.add-lib): Clojure 1.12's add-lib feature for leiningen and/or other environments without a specific version of the clojure CLI"}, :excerpts [{:text "... id=\"updates\">Updates Clojure Conj 2025 Last November I had the honor and pleasure to visit the Clojure Conj 2025. I met a host of wonderful and...", :matched-terms ["clojure"], :source :content} {:text "... Hickey and talk to him during a meeting about Clojure dialects and Clojure tooling. The talk that I gave there: \"Making...", :matched-terms ["clojure"], :source :content} {:text "... align=\"center\" alt=\"presentation at Dutch Clojure meetup\"...", :matched-terms ["clojure"], :source :content}]} {:rule-id "clojure-db", :item {:feed-id "planet-clojure", :item-id "tag:blogger.com,1999:blog-1409352204799783992.post-1198041635414991858", :title "Joyful Python with the REPL", :link "https://davidvujic.blogspot.com/2022/08/joyful-python-with-repl.html", :published-at #inst "2026-01-03T20:25:31.000-00:00", :content "REPL Driven Development is a workflow that makes coding both joyful and interactive. The feedback loop from the REPL is a great thing to have at your fingertips. \"If you can improve just one thing in your software development, make it getting faster feedback.\" Dave Farley Just like Test Driven Development (TDD), it will help you write testable code. I have also noticed a nice side effect from this workflow: REPL Driven Development encourages a functional programming style. REPL Driven Development is an everyday thing among Clojure developers and doable in Python, but far less known here. I'm working on making it an everyday thing in Python development too. But what is REPL Driven Development? What is it? You evaluate variables, code blocks, functions - or an entire module - and get instant feedback, just by a hitting a key combination in your favorite code editor. There's no reason to leave the IDE for a less featured shell to accomplish all of that. You already have autocomplete, syntax highlighting and the color theme set up in your editor. Why not use that, instead of a shell? Evaluate code and get feedback, without leaving the code editor. Ideally, the result of an evaluation pops up right next to the cursor, so you don't have to do any context switches or lose focus. It can also be printed out in a separate frame right next to the code. This means that testing the code you currently write is at your fingertips. Easy setup With some help from IPython, it is possible to write, modify & evaluate Python code in a REPL Driven way. I would recommend to install IPython globally, to make it accessible from anywhere on your machine. pip install ipython Configure IPython to make it ready for REPL Driven Development: c.InteractiveShellApp.exec_lines = [\"%autoreload 2\"] c.InteractiveShellApp.extensions = [\"autoreload\"] c.TerminalInteractiveShell.confirm_exit = False You will probably find the configuration file here: ~/.ipython/profile_default/ipython_config.py You are almost all set. Emacs setup Emacs is my favorite editor. I'm using a couple of Python specific packages to make life as a Python developer in general better, such as elpy. The auto-virtualenv package will also help out making REPL Driven Developer easier. It will find local virtual environments automatically and you can start coding without any python-path quirks. Most importantly, set IPython as the default shell in Emacs. Have a look at my Emacs setup for the details. VS Code setup I am not a VS Code user. But I wanted to learn how well supported REPL Driven Development is in VS Code, so I added these extensions: You would probably want to add keyboard shortcuts to get the true interactive feel of it. Here, I'm just trying things out by selecting code, right clicking and running it in an interactive window. It seems to work pretty well! I haven't figured out if the interactive window is picking up the global IPython config yet, or if it already refreshes a submodule when updated. Evaluating code in the editor with fast feedback loops. It would be great to have keyboard commands here, though. Current limitations In Clojure, you connect to & modify an actually running program by re-evaluating the source code. That is a wonderful thing for the developer experience in general. I haven't been able to do that with Python, and believe Python would need something equivalent to NRepl to get that kind of magic powers. Better than TDD I practice REPL Driven Development in my daily Python work. For me, it has become a way to quickly verify if the code I currently write is working as expected. I usually think of this REPL driven thing as Test Driven Development Deluxe. Besides just evaluating the code, I often write short-lived code snippets to test out some functionality. By doing that, I can write code and test it interactively. Sometimes, these code snippets are converted permanent unit tests. For a live demo, have a look at my five minute lightning talk from PyCon Sweden about REPL Driven Development in Python. Never too late to learn I remember it took me almost a year learning & developing Clojure before I actually \"got it\". Before that, I sometimes copied some code and pasted it into a REPL and then ran it. But that didn't give me a nice developer experience at all. Copy-pasting code is cumbersome and will often fail because of missing variables, functions or imports. Don't do that. I remember the feeling when figuring out the REPL Driven Development workflow, I finally had understood how software development should be done. It took me about 20 years to get there. It is never too late to learn new things. ðŸ˜ Top photo by ckturistando on Unsplash"}, :excerpts [{:text "... workflow: REPL Driven Development encourages a functional programming style. REPL Driven Development is an everyday thing among Clojure developers and doable in Python, but far less...", :matched-terms ["functional" "clojure"], :source :content}]} {:rule-id "clojure-db", :item {:feed-id "planet-clojure", :item-id "https://tonsky.me/blog/syntax-highlighting/", :title "I am sorry, but everyone is getting syntax highlighting wrong", :link "https://tonsky.me/blog/syntax-highlighting/", :published-at #inst "2026-01-03T21:43:11.000-00:00", :content "Translations: Russian Syntax highlighting is a tool. It can help you read code faster. Find things quicker. Orient yourself in a large file. Like any tool, it can be used correctly or incorrectly. Letâ€™s see how to use syntax highlighting to help you work. Christmas Lights Diarrhea Most color themes have a unique bright color for literally everything: one for variables, another for language keywords, constants, punctuation, functions, classes, calls, comments, etc. Sometimes it gets so bad one canâ€™t see the base text color: everything is highlighted. Whatâ€™s the base text color here? The problem with that is, if everything is highlighted, nothing stands out. Your eye adapts and considers it a new norm: everything is bright and shiny, and instead of getting separated, it all blends together. Hereâ€™s a quick test. Try to find the function definition here: and here: See what I mean? So yeah, unfortunately, you canâ€™t just highlight everything. You have to make decisions: what is more important, what is less. What should stand out, what shouldnâ€™t. Highlighting everything is like assigning â€œtop priorityâ€ to every task in Linear. It only works if most of the tasks have lesser priorities. If everything is highlighted, nothing is highlighted. Enough colors to remember There are two main use-cases you want your color theme to address: Look at something and tell what it is by its color (you can tell by reading text, yes, but why do you need syntax highlighting then?) Search for something. You want to know what to look for (which color). 1 is a direct index lookup: color â†’ type of thing. 2 is a reverse lookup: type of thing â†’ color. Truth is, most people donâ€™t do these lookups at all. They might think they do, but in reality, they donâ€™t. Let me illustrate. Before: After: Can you see it? I misspelled return for retunr and its color switched from red to purple. I canâ€™t. Hereâ€™s another test. Close your eyes (not yet! Finish this sentence first) and try to remember what color your color theme uses for class names? Can you? If the answer for both questions is â€œnoâ€, then your color theme is not functional. It might give you comfort (as inâ€”I feel safe. If itâ€™s highlighted, itâ€™s probably code) but you canâ€™t use it as a tool. It doesnâ€™t help you. Whatâ€™s the solution? Have an absolute minimum of colors. So little that they all fit in your head at once. For example, my color theme, Alabaster, only uses four: Green for strings Purple for constants Yellow for comments Light blue for top-level definitions Thatâ€™s it! And I was able to type it all from memory, too. This minimalism allows me to actually do lookups: if Iâ€™m looking for a string, I know it will be green. If Iâ€™m looking at something yellow, I know itâ€™s a comment. Limit the number of different colors to what you can remember. If you swap green and purple in my editor, itâ€™ll be a catastrophe. If somebody swapped colors in yours, would you even notice? What should you highlight? Something there isnâ€™t a lot of. Rememberâ€”we want highlights to stand out. Thatâ€™s why I donâ€™t highlight variables or function callsâ€”they are everywhere, your code is probably 75% variable names and function calls. I do highlight constants (numbers, strings). These are usually used more sparingly and often are reference pointsâ€”a lot of logic paths start from constants. Top-level definitions are another good idea. They give you an idea of a structure quickly. Punctuation: it helps to separate names from syntax a little bit, and you care about names first, especially when quickly scanning code. Please, please donâ€™t highlight language keywords. class, function, if, elsestuff like this. You rarely look for them: â€œwhereâ€™s that ifâ€ is a valid question, but you will be looking not at the if the keyword, but at the condition after it. The condition is the important, distinguishing part. The keyword is not. Highlight names and constants. Grey out punctuation. Donâ€™t highlight language keywords. Comments are important The tradition of using grey for comments comes from the times when people were paid by line. If you have something like of course you would want to grey it out! This is bullshit text that doesnâ€™t add anything and was written to be ignored. But for good comments, the situation is opposite. Good comments ADD to the code. They explain something that couldnâ€™t be expressed directly. They are important. So hereâ€™s another controversial idea: Comments should be highlighted, not hidden away. Use bold colors, draw attention to them. Donâ€™t shy away. If somebody took the time to tell you something, then you want to read it. Two types of comments Another secret nobody is talking about is that there are two types of comments: Explanations Disabled code Most languages donâ€™t distinguish between those, so thereâ€™s not much you can do syntax-wise. Sometimes thereâ€™s a convention (e.g. -- vs /* */ in SQL), then use it! Hereâ€™s a real example from Clojure codebase that makes perfect use of two types of comments: Disabled code is gray, explanation is bright yellow Light or dark? Per statistics, 70% of developers prefer dark themes. Being in the other 30%, that question always puzzled me. Why? And I think I have an answer. Hereâ€™s a typical dark theme: and hereâ€™s a light one: On the latter one, colors are way less vibrant. Here, I picked them out for you: Notice how many colors there are. No one can remember that many. This is because dark colors are in general less distinguishable and more muddy. Look at Hue scale as we move brightness down: Basically, in the dark part of the spectrum, you just get fewer colors to play with. Thereâ€™s no â€œdark yellowâ€ or good-looking â€œdark tealâ€. Nothing can be done here. There are no magic colors hiding somewhere that have both good contrast on a white background and look good at the same time. By choosing a light theme, you are dooming yourself to a very limited, bad-looking, barely distinguishable set of dark colors. So it makes sense. Dark themes do look better. Or rather: light ones canâ€™t look good. Science Â¯\\_(ãƒ„)_/Â¯ But! But. There is one trick you can do, that I donâ€™t see a lot of. Use background colors! Compare: The first one has nice colors, but the contrast is too low: letters become hard to read. The second one has good contrast, but you can barely see colors. The last one has both: high contrast and clean, vibrant colors. Lighter colors are readable even on a white background since they fill a lot more area. Text is the same brightness as in the second example, yet it gives the impression of clearer color. Itâ€™s all upside, really. UI designers know about this trick for a while, but I rarely see it applied in code editors: If your editor supports choosing background color, give it a try. It might open light themes for you. Bold and italics Donâ€™t use. This goes into the same category as too many colors. Itâ€™s just another way to highlight something, and you donâ€™t need too many, because you canâ€™t highlight everything. In theory, you might try to replace colors with typography. Would that work? I donâ€™t know. I havenâ€™t seen any examples. Using italics and bold instead of colors Myth of number-based perfection Some themes pay too much attention to be scientifically uniform. Like, all colors have the same exact lightness, and hues are distributed evenly on a circle. This could be nice (to know if you have OCD), but in practice, it doesnâ€™t work as well as it sounds: OkLab l=0.7473 c=0.1253 h=0, 45, 90, 135, 180, 225, 270, 315 The idea of highlighting is to make things stand out. If you make all colors the same lightness and chroma, they will look very similar to each other, and itâ€™ll be hard to tell them apart. Our eyes are way more sensitive to differences in lightness than in color, and we should use it, not try to negate it. Letâ€™s design a color theme together Letâ€™s apply these principles step by step and see where it leads us. We start with the theme from the start of this post: First, letâ€™s remove highlighting from language keywords and re-introduce base text color: Next, we remove color from variable usage: and from function/method invocation: The thinking is that your code is mostly references to variables and method invocation. If we highlight those, weâ€™ll have to highlight more than 75% of your code. Notice that weâ€™ve kept variable declarations. These are not as ubiquitous and help you quickly answer a common question: where does thing thing come from? Next, letâ€™s tone down punctuation: I prefer to dim it a little bit because it helps names stand out more. Names alone can give you the general idea of whatâ€™s going on, and the exact configuration of brackets is rarely equally important. But you might roll with base color punctuation, too: Okay, getting close. Letâ€™s highlight comments: We donâ€™t use red here because you usually need it for squiggly lines and errors. This is still one color too many, so I unify numbers and strings to both use green: Finally, letâ€™s rotate colors a bit. We want to respect nesting logic, so function declarations should be brighter (yellow) than variable declarations (blue). Compare with what we started: In my opinion, we got a much more workable color theme: itâ€™s easier on the eyes and helps you find stuff faster. Shameless plug time Iâ€™ve been applying these principles for about 8 years now. I call this theme Alabaster and Iâ€™ve built it a couple of times for the editors I used: VS Code JetBrains IDEs Sublime Text (twice) Itâ€™s also been ported to many other editors and terminals; the most complete list is probably here. If your editor is not on the list, try searching for it by nameâ€”it might be built-in already! I always wondered where these color themes come from, and now I became an author of one (and I still donâ€™t know). Feel free to use Alabaster as is or build your own theme using the principles outlined in the articleâ€”either is fine by me. As for the principles themselves, they worked out fantastically for me. Iâ€™ve never wanted to go back, and just one look at any â€œtraditionalâ€ color theme gives me a scare now. I suspect that the only reason we donâ€™t see more restrained color themes is that people never really thought about it. Well, this is your wake-up call. I hope this will inspire people to use color more deliberately and to change the default way we build and use color themes."}, :excerpts [{:text "... is â€œnoâ€, then your color theme is not functional. It might give you comfort (as inâ€”I feel...", :matched-terms ["functional"], :source :content}]} {:rule-id "clojurescript", :item {:feed-id "planet-clojure", :item-id "https://clojure.org/news/2025/12/23/deref", :title "Clojure Deref (Dec 23, 2025)", :link "https://clojure.org/news/2025/12/23/deref", :published-at #inst "2025-12-23T00:00:00.000-00:00", :content "Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed: RSS). The annual Clojure surveys are live Help shape the future of Clojure! Whether you use Clojure, ClojureScript, Babashka, or any other Clojure dialect, please fill out the 2025 State of Clojure Survey and spread the word on social media. This survey gives us the best snapshot of the Clojure community, so help us get as many participants as possible. If you use ClojureScript or dialects like Squint, Cherry, nbb, and such, please fill out the 2025 State of ClojureScript Survey and share it with others. Thank you for your help! Upcoming Events Clojure real-world-data 38: Dec 26 Scicloj AI Meetup: Agent-o-rama: Jan 17 Clojure Jam 2026: Apr 18-19 & 25-26. Online & free! CFP is open until Jan 31st. Babashka Conf: May 8. Amsterdam, NL. Free registration, but tickets are limited! Dutch Clojure Days 2026: May 9th. Amsterdam, NL. Join the waitlist, or the CFP is open until Jan 15th. Podcasts, videos, and media One year of building my own IDE in clojure - phronmophobic Event-sourcing with projections in Clojure and PostgreSQL - Andrey Fadeev Announcing Multi REPL Sessions in Calva - CalvaTV Clojure/Conj 2025 Photos A Decade on Datomic - Davis Shepherd & Jonathan Indig (Netflix) - ClojureTV UnifyBio: Power Tools for Translational Data Science - Benjamin Kamphaus - ClojureTV Cats, Dogs, and Python - Paula Gearon - ClojureTV Agent-o-rama: Scalable, Traceable, Stateful AI agents in Pure Clojure or Java - Nathan Marz - ClojureTV Clojure South 2025 Construindo aplicaÃ§Ãµes web elegantes com ClojureScript, React e UIx! | Clojure South 2025 - Building Nubank Fail fast, fix faster: Injecting failures on integration tests | Clojure South 2025 - Building Nubank Clojure to Elixir: Functional Programming for Scalable & Sustainable Apps | Clojure South 2025 - Building Nubank Clojure e IA: Construindo Agentes Inteligentes sem Reinventar a Roda | Clojure South 2025 - Building Nubank Introduzindo programaÃ§Ã£o funcional na Carteira Digital de TrÃ¢nsito | Clojure South 2025 - Building Nubank NuFileBox Reverse: GestÃ£o segura de arquivos com Clojure | Clojure South 2025 - Building Nubank Uma estratÃ©gia incremental com apoio IA para testes unitÃ¡rios em Clojure | Clojure South 2025 - Building Nubank Betting on open source: Adventures with Datahike | Clojure South 2025 - Building Nubank 12 years of Component | Clojure South 2025 - Building Nubank Blogs, articles, and news A Christmas Present in Clojure â€“ Metosin - Joel Kaasinen Clerk notebooks with solutions for Advent of Code 2025 - Miran Clojurists Together 2026 Annual Funding Announcement - Kathy Davis Announcing Oak 1.0 - Arne Brasseur Easel Turns One! - Adrian Smith (recur thoughts \"Nullable pattern: Experience report\") - Emil Bengtsson Machine Learning in Clojure with libpython-clj: Bridging Functional Elegance and Pythonâ€™s ML Power [Series 1] - Flexiana - Jiri Knesl The Best Things and Stuff of 2025 - Michael Fogus An incremental strategy with AI support for unit testing in Clojure - Building Nubank - Nubank Editorial How NuFilebox Reverse strengthens file security at Nubank - Building Nubank - Nubank Editorial 12 years of Component: A decade of interactive development - Building Nubank - Nubank Editorial Building elegant interfaces with ClojureScript, React, and UIx - Building Nubank - Nubank Editorial Libraries and Tools Debut release cljs-uix-electron - Uix + Electron starter cljs-uix-wails - Wails + ClojureScript starter Oak - Oak is a Free and Open Source Identity Provider that you can host yourself immersa - Open Source Web-based 3D Presentation Tool bb-timemachine - Run code back in Git-time. solid-cljs - ClojureScript bindings to Solid clojars-download-stats - An always up-to-date, complete SQL export of artifacts daily downloads since November 2012 malt - Malli-Typed interfaces for Clojure distributed-scope - Run one lexical scope across distributed peers. Updates repath-studio 0.4.11 - A local web-based vector graphics editor that combines procedural tooling with traditional design workflows. dtype-next 10.000-beta-11 - A Clojure library designed to aid in the implementation of high performance algorithms and systems. repl-mcp d00f661 - Model Context Protocol Clojure support including REPL integration with development tools. virtuoso 0.1.2 - A number of trivial wrappers on top of virtual threads bbin 0.2.5 - Install any Babashka script or project with one command stripe-clojure 2.1.0 - Clojure SDK for the Stripe API. muutos 2025-12-18 - Muutos is a zero-dependency Clojure library for reacting to changes in a PostgreSQL database. cherry 0.5.34 - Experimental ClojureScript to ES6 module compiler nbb 1.3.205 - Scripting in Clojure on Node.js using SCI replicant 2025.12.1 - A data-driven rendering library for Clojure(Script) that renders hiccup to DOM or to strings. joyride 0.0.72 - Making VS Code Hackable like Emacs since 2022 process 0.6.25 - Clojure library for shelling out / spawning sub-processes fireworks 0.19.0 - Fireworks is a themeable tapping library for Clojure, ClojureScript, and Babashka. bling 0.9.2 - Rich text console printing for Clojure, ClojureScript, and Babashka. clj-kondo 2025.12.23 - Static analyzer and linter for Clojure code that sparks joy calva 2.0.543 - Clojure & ClojureScript Interactive Programming for VS Code sci 0.11.50 - Configurable Clojure/Script interpreter suitable for scripting and Clojure DSLs scittle 0.7.30 - Execute Clojure(Script) directly from browser script tags via SCI partial-cps 0.1.42 - A lean and efficient continuation passing style transform, includes async-await support."}, :excerpts [{:text "... class=\"paragraph\"> Whether you use Clojure, ClojureScript, Babashka, or any other Clojure dialect, please...", :matched-terms ["clojurescript"], :source :content} {:text "... class=\"paragraph\"> If you use ClojureScript or dialects like Squint, Cherry, nbb, and such, please fill out the 2025 State of ClojureScript Survey and share it with...", :matched-terms ["clojurescript"], :source :content} {:text "... Multi REPL Sessions in Calva -...", :matched-terms ["repl"], :source :content}]} {:rule-id "clojurescript", :item {:feed-id "planet-clojure", :item-id "https://building.nubank.com/?p=35767", :title "Building elegant interfaces with ClojureScript, React, and UIx", :link "https://building.nubank.com/building-elegant-interfaces-with-clojurescript-react-and-uix/", :published-at #inst "2025-12-23T15:26:47.000-00:00", :content "During Clojure South, JoÃ£o Lanjoni, Software Engineer at Nubank, addressed a central challenge of modern web development: how to combine the ergonomics of ClojureScript with the maturity of React to build scalable, high-performance interfaces. According to JoÃ£o, the solution is UIx, a tool that represents the new generation of bridges that further aligns the Clojure universe with the React ecosystem. In his session, he detailed the context, the limitations of previous approaches, and the value of UIx as a new, efficient entry point for React developers into ClojureScript. From 2013 to today: React and ClojureScript in perspective Since its launch in 2013, React has redefined the structure of frontend applications by introducing concepts like consistent reactivity. The ClojureScript community quickly responded with idiomatic interfaces like Reagent, which became the de facto standard due to its solidity, providing a minimalistic interface between ClojureScript and React, using a Hiccup-like syntax to define components. With the arrival of functional components and hooks, starting around 2019, new interfaces came up to provide a direct way of using functional components (instead of old class-based components). However, as React continuously evolved towards modern patterns, including concurrent rendering, functional components, and new ways to manage component state, Reagent remained tied to class-based components, mainly for backward compatibility. This mismatch resulted in some limitations like performance limitations in large codebases (due to Hiccup parsing in runtime), issues with functional components (as users may have to declare every functional component usage even when they were defined as a React standard), and hindered interoperability with modern React libraries, such as Material UI, Mantine, and Ant Design, widening the gap between the two ecosystems. What UIx changes in your code UIx emerges to resolve this divergence. Acting as a thin interface between ClojureScript and modern React, its focus is technical and pragmatic: it offers a minimal abstraction layer, more predictable performance, and the direct use of functional components and hooks. Furthermore, it ensures native interoperability with the React ecosystem, allowing the lifecycle and state management to be handled directly by React itself. â€œIf React already handles state and lifecycle management well, why not let it do that?â€ JoÃ£o Lanjoni, Software Engineer at Nubank Instead of creating a complete framework or adding unnecessary abstractions, UIx is a lightweight bridge, leveraging what modern React does best, resulting in a ClojureScript codebase with idiomatic syntax but identical behavior to modern React. UIx component structure In practical terms, UIx centralizes component construction around two elements: defui for declaring React components and $ for rendering elements in an explicit and lightweight way. Component bodies process props identically to React. Hooks such as useState are exposed using idiomatic ClojureScript conventions, like use-state, with UIx handling the translation to native React APIs. This ergonomics combines the best of ClojureScript syntax with the React architecture, which, according to JoÃ£o, eliminates the need to train React developers in the internal details of layers like Reagent or Re-frame, keeping the mental model aligned with the React mainstream. Performance in figures A highlight of the presentation was the chart, created by Roman Liutikov â€“ the UIx maintainer â€“, comparing the call stack depth when rendering a simple component in pure React, UIx, and Reagent. React exhibits the shortest path; UIx, by adding only a thin layer, follows closely. In contrast, Reagent, due to Hiccup being interpreted at runtime, shows a significantly deeper call stack. While the difference is minimal in small applications, the impact on predictability and performance becomes notable and increases in products with hundreds or thousands of components. Who is already using UIx in production JoÃ£o presented three real-world examples, all highlighted on the projectâ€™s official page: Metosin, one of the largest Clojure consultancies in Europe; Pitch, an AI presentation platform with amazing slide decks; Cognician, an e-learning platform for personal development. The Pitch case is particularly impressive. The team migrated 2,500 components from Reagent to UIx, maintained compatibility with Re-frame, and saw improvements in predictability and performance. Metosin, meanwhile, employs Juho Teperi, one of the main contributors to Reagent, who also made an example project for a full-stack app using Clojure and ClojureScript and chose UIx to build the web interface, also using Material UI as the component library without any special wrapper. When someone who helped build the previous tool begins to advocate for the new approach, it says a lot about the current moment of the technology, even more with the launch of a new version of Reagent introducing default functional components and a thinner hooks wrapper (inspired also by UIx). Reducing the developer learning curve UIxâ€™s value extends to the hiring and development of engineers, which opens a path for more professionals to enter the ClojureScript ecosystem without the requirement of mastering the intricacies of Reagent, Re-frame, or the atom-based state model from day one. It represents a pragmatic approach to lowering barriers without sacrificing the benefits of a functional and declarative language. â€œThe greatest value of UIx is allowing React developers to write ClojureScript with a minimal learning curve.â€ JoÃ£o Lanjoni, Software Engineer at Nubank When UIx is the best choice UIx is especially recommended for modern and complex front-end applications and teams already familiar with React. It is ideal for codebases that rely heavily on hooks and for projects requiring interoperability with the latest React libraries, with a view toward strong long-term growth potential. The library, intentionally simple, does not attempt to reinvent global state management, maintaining compatibility with mature React libraries like Zustand and Jotai, instead of adding unnecessary layers, or even using a custom hook that subscribes to a Clojure atom to manage a global state (similar to those cited libraries). In essence, UIx does not seek to replace React but rather to act as a thin, modern, and pragmatic bridge. Its goal is to allow teams to build scalable front-ends with the power of React, while preserving the expressiveness and elegance of the Clojure philosophy and syntax. For complex and modern projects in ClojureScript, UIx may be the missing link. The post Building elegant interfaces with ClojureScript, React, and UIx appeared first on Building Nubank."}, :excerpts [{:text "Building elegant interfaces with ClojureScript, React, and UIx", :matched-terms ["clojurescript" "react"], :source :title} {:text "... development: how to combine the ergonomics of ClojureScript with the maturity of React to build scalable, high-performance...", :matched-terms ["clojurescript" "react"], :source :content} {:text "... further aligns the Clojure universe with the React ecosystem. In his session, he detailed the...", :matched-terms ["react"], :source :content}]} {:rule-id "clojurescript", :item {:feed-id "planet-clojure", :item-id "https://www.birkey.co/2025-12-28-once-csv-parser-to-rule-them-all.html", :title "One csv parser to rule them all", :link "https://www.birkey.co/2025-12-28-once-csv-parser-to-rule-them-all.html", :published-at #inst "2025-12-28T23:44:00.000-00:00", :content "One would think that parsing CSV files is pretty straightforward until you get bitten by all kinds of CSV files exists in the wild. Many years ago, I have written a small CSV reader with following requirements in mind: Should not depend on any other code other than Clojure Should allow me to control how I tokenize and transform lines Should allow me to have complete controll over delimiting charactor or charactors, file encoding, amount of lines to read and error handling The result is csvx. I update it to work across Clojure and ClojureScript both in NodeJS and browser environment. The entire code is less than 200 lines including comments and blank lines. If you find yourself in need of a csv reader with above requirements, you are welcome to steal the code. Enjoy! Tags: Clojure ClojureScript"}, :excerpts [{:text "... I update it to work across Clojure and ClojureScript both in NodeJS and browser environment. The entire code is...", :matched-terms ["clojurescript" "node"], :source :content} {:text "... ClojureScript", :matched-terms ["clojurescript"], :source :content}]} {:rule-id "clojurescript", :item {:feed-id "planet-clojure", :item-id "https://clojure.org/news/2025/12/30/deref", :title "Clojure Deref (Dec 30, 2025)", :link "https://clojure.org/news/2025/12/30/deref", :published-at #inst "2025-12-30T00:00:00.000-00:00", :content "Welcome to the Clojure Deref! This is a weekly link/news roundup for the Clojure ecosystem (feed: RSS). Last chance for the annual Clojure surveys! Time is running out to take the Clojure surveys! Please help spread the word, and take a moment to fill them out if you havenâ€™t already. Fill out the 2025 State of Clojure Survey if you use any version or dialect of Clojure in any capacity. Fill out the 2025 State of ClojureScript Survey and if you use ClojureScript or dialects like Squint, Cherry, nbb, and such. Thank you for your help! Upcoming Events Clojure real-world-data 39: Jan 2 Scicloj AI Meetup: Agent-o-rama: Jan 17 Clojure Jam 2026: Apr 18-19 & 25-26. Online & free! CFP is open until Jan 31st. Babashka Conf: May 8. Amsterdam, NL. Free registration, but tickets are limited! Dutch Clojure Days 2026: May 9th. Amsterdam, NL. Join the waitlist, or the CFP is open until Jan 15th. Podcasts, videos, and media Browser Jack-in â€“ Connect your Clojure editor to any web page - CalvaTV Clojure/Conj 2025 Rich Hickeyâ€™s opening remarks from Clojure/Conj 2025 - ClojureTV 12 Years of Component - Alessandra Sierra - ClojureTV Blogs, articles, and news Mixing Swift and Clojure in Your iOS App - Scittle - Rod Schmidt Tetris-playing AI the Polylith way - Part 1 - Joakim Tengstrand Implementing the Algebra of Graphics in Clojure - Part 1 â€“ Clojure Civitas - Daniel Slutsky Machine Learning in Clojure with libpythonâ€‘clj: Using Bayesian Networks for Smarter, Interpretable AI [Series 2] - Flexiana - Jiri Knesl Machine Learning in Clojure with libpythonâ€‘clj: Unlocking Causal Insights Using Microsoftâ€™s EconML [Series 3] - Flexiana - Jiri Knesl One csv parser to rule them all - Kasim Tuman Heretic: Mutation Testing in Clojure - Eric Dvorsak Building Heretic: From ClojureStorm to Mutant Schemata - Eric Dvorsak Thanks AI! - Rich Hickey Libraries and Tools Debut release crabjure - A fast static analyzer for Clojure and ClojureScript, written in Rust. browser-jack-in - A web browser extension that letâ€™s you inject a Scittle REPL server into any browser page. clamav-clj - An idiomatic, modern Clojure wrapper for ClamAV. heretic - Mutation testing for Clojure - fast, practical, and integrated Updates Many Clojure contrib libs were updated to move the Clojure dependency to 1.11.4, which is past the CVE fixed in 1.11.2. partial-cps 0.1.50 - A lean and efficient continuation passing style transform, includes async-await support. csvx 68fd22c - A zero dependencies tool that enables you to control how to tokenize, transform and handle files with char(s) separated values in Clojure and ClojureScript. recife 0.22.0 - A Clojure model checker (using the TLA+/TLC engine) polylith 0.3.32 - A tool used to develop Polylith based architectures in Clojure. nrepl 1.5.2 - A Clojure network REPL that provides a server and client, along with some common APIs of use to IDEs and other tools that may need to evaluate Clojure code in remote environments. manifold 0.5.0 - A compatibility layer for event-driven abstractions"}, :excerpts [{:text "... out the 2025 State of ClojureScript Survey and if you use ClojureScript or dialects like Squint, Cherry, nbb,...", :matched-terms ["clojurescript"], :source :content}]} {:rule-id "clojurescript", :item {:feed-id "planet-clojure", :item-id "https://blog.michielborkent.nl/oss-updates-nov-dec-2025.html", :title "OSS updates November and December 2025", :link "https://blog.michielborkent.nl/oss-updates-nov-dec-2025.html", :published-at #inst "2026-01-01T23:59:59.000-00:00", :content "In this post I&aposll give updates about open source I worked on during November and December 2025. To see previous OSS updates, go here. Sponsors I&aposd like to thank all the sponsors and contributors that make this work possible. Without you, the below projects would not be as mature or wouldn&apost exist or be maintained at all! So a sincere thank you to everyone who contributes to the sustainability of these projects. Current top tier sponsors: Clojurists Together Roam Research Nextjournal Nubank Open the details section for more info about sponsoring. Sponsor info If you want to ensure that the projects I work on are sustainably maintained, you can sponsor this work in the following ways. Thank you! Github Sponsors The Babashka or Clj-kondo OpenCollective Ko-fi Patreon Clojurists Together Updates Clojure Conj 2025 Last November I had the honor and pleasure to visit the Clojure Conj 2025. I met a host of wonderful and interesting long-time and new Clojurians, many that I&aposve known online for a long time and now met for the first time. It was especially exciting to finally meet Rich Hickey and talk to him during a meeting about Clojure dialects and Clojure tooling. The talk that I gave there: \"Making tools developers actually use\" will come online soon. Babashka conf and Dutch Clojure Days 2026 In 2026 I&aposm organizing Babashka Conf 2026. It will be an afternoon event (13:00-17:00) hosted in the Forum hall of the beautiful public library of Amsterdam. More information here. Get your ticket via Meetup.com (currently there&aposs a waiting list, but more places will come available once speakers are confirmed). CfP will open mid January. The day after babashka conf, Dutch Clojure Days 2026 will be happening. It&aposs not too late to get your talk proposal in. More info here. Projects Here are updates about the projects/libraries I&aposve worked on in the last two months in detail. babashka: native, fast starting Clojure interpreter for scripting. Bump process to 0.6.25 Bump deps.clj Fix #1901: add java.security.DigestOutputStream Redefining namespace with ns should override metadata Bump nextjournal.markdown to 0.7.222 Bump edamame to 1.5.37 Fix #1899: with-meta followed by dissoc on records no longer works Bump fs to 0.5.30 Bump nextjournal.markdown to 0.7.213 Fix #1882: support for reifying java.time.temporal.TemporalField (@EvenMoreIrrelevance) Bump Selmer to 1.12.65 SCI: sci.impl.Reflector was rewritten into Clojure dissoc on record with non-record field should return map instead of record Bump edamame to 1.5.35 Bump core.rrb-vector to 0.2.0 Migrate detecting of executable name for self-executing uberjar executable from ProcessHandle to to native image ProcessInfo to avoid sandbox errors Bump cli to 0.8.67 Bump fs to 0.5.29 Bump nextjournal.markdown to 0.7.201 SCI: Configurable Clojure/Script interpreter suitable for scripting Add support for :refer-global and :require-global Add println-str Fix #997: Var is mistaken for local when used under the same name in a let body Fix #1001: JS interop with reserved js keyword fails (regression of #987) sci.impl.Reflector was rewritten into Clojure Fix babashka/babashka#1886: Return a map when dissociating a record basis field. Fix #1011: reset ns metadata when evaluating ns form multiple times Fix for https://github.com/babashka/babashka/issues/1899 Fix #1010: add js-in in CLJS Add array-seq clj-kondo: static analyzer and linter for Clojure code that sparks joy. #2600: NEW linter: unused-excluded-var to warn on unused vars in :refer-clojure :exclude (@jramosg) #2459: NEW linter: :destructured-or-always-evaluates to warn on s-expressions in :or defaults in map destructuring (@jramosg) Add type checking support for sorted-map-by, sorted-set, and sorted-set-by functions (@jramosg) Add new type array and type checking support for the next functions: to-array, alength, aget, aset and aclone (@jramosg) Fix #2695: false positive :unquote-not-syntax-quoted in leiningen&aposs defproject Leiningen&aposs defproject behavior can now be configured using leiningen.core.project/defproject Fix #2699: fix false positive unresolved string var with extend-type on CLJS Rename :refer-clojure-exclude-unresolved-var linter to unresolved-excluded-var for consistency v2025.12.23 #2654: NEW linter: redundant-let-binding, defaults to :off (@tomdl89) #2653: NEW linter: :unquote-not-syntax-quoted to warn on ~ and ~@ usage outside syntax-quote (`) (@jramosg) #2613: NEW linter: :refer-clojure-exclude-unresolved-var to warn on non-existing vars in :refer-clojure :exclude (@jramosg) #2668: Lint & syntax errors in let bindings and lint for trailing & (@tomdl89) #2590: duplicate-key-in-assoc changed to duplicate-key-args, and now lints dissoc, assoc! and dissoc! too (@tomdl89) #2651: resume linting after paren mismatches clojure-lsp#2651: Fix inner class name for java-class-definitions. clojure-lsp#2651: Include inner class java-class-definition analysis. Bump babashka/fs #2532: Disable :duplicate-require in require + :reload / :reload-all #2432: Don&apost warn for :redundant-fn-wrapper in case of inlined function #2599: detect invalid arity for invoking collection as higher order function #2661: Fix false positive :unexpected-recur when recur is used inside clojure.core.match/match (@jramosg) #2617: Add types for repeatedly (@jramosg) Add :ratio type support for numerator and denominator functions (@jramosg) #2676: Report unresolved namespace for namespaced maps with unknown aliases (@jramosg) #2683: data argument of ex-info may be nil since clojure 1.12 Bump built-in ClojureScript analysis info Fix #2687: support new :refer-global and :require-global ns options in CLJS Fix #2554: support inline configs in .cljc files edamame: configurable EDN and Clojure parser with location metadata and more Edamame: configurable EDN and Clojure parser with location metadata and more Minor: leave out :edamame/read-cond-splicing when not splicing Allow :read-cond function to override :edamame/read-cond-splicing value The result from :read-cond with a function should be spliced. This behavior differs from :read-cond + :preserve which always returns a reader conditional object which cannot be spliced. Support function for :features option to just select the first feature that occurs squint: CLJS syntax to JS compiler Allow macro namespaces to load \"node:fs\", etc. to read config files for conditional compilation Don&apost emit IIFE for top-level let so you can write let over defn to capture values. Fix js-yield and js-yield* in expression position Implement some? as macro Fix #758: volatile!, vswap!, vreset! pr-str, prn etc now print EDN (with the idea that you can paste it back into your program) new #js/Map reader that reads a JavaScript Map from a Clojure map (maps are printed like this with pr-str too) Support passing keyword to mapv #759: doseq can&apost be used in expression context Fix #753: optimize output of dotimes alength as macro reagami: A minimal zero-deps Reagent-like for Squint and CLJS Performance enhancements treat innerHTML as a property rather than an attribute Drop support for camelCased properties / (css) attributes Fix :default-value in input range Support data param in :on-render Support default values for uncontrolled components Fix child count mismatch Fix re-rendering/patching of subroots Add :on-render hook for mounting/updating/unmounting third part JS components NEW: parmezan: fixes unbalanced or unexpected parens or other delimiters in Clojure files CLI: Turn Clojure functions into CLIs! #126: - value accidentally parsed as option, e.g. --file - #124: Specifying exec fn that starts with hyphen is treated as option Drop Clojure 1.9 support. Minimum Clojure version is now 1.10.3. clerk: Moldable Live Programming for Clojure always analyze doc (but not deps) when no-cache is set (#786) add option to disable inline formulas in markdown (#780) scittle: Execute Clojure(Script) directly from browser script tags via SCI #114: Enable source maps (@jeroenvandijk) #140: Enable customizing the nrepl websocket port (@PEZ) Bump shadow-cljs and SCI Nextjournal Markdown Add config option to avoid TeX formulas API improvements for passing options cherry: Experimental ClojureScript to ES6 module compiler Fix cherry compile CLI command not receiving file arguments Bump shadow-cljs to 3.3.4 Fix #163: Add assert to macros (@willcohen) Fix #165: Fix ClojureScript protocol dispatch functions (@willcohen) Fix #167: Protocol dispatch functions inside IIFEs; bump squint accordingly Fix #169: fix extend-type on Object Fix #171: Add satisfies? macro (@willcohen) deps.clj: A faithful port of the clojure CLI bash script to Clojure Released several versions catching up with the clojure CLI quickdoc: Quick and minimal API doc generation for Clojure Fix extra newline in codeblock quickblog: light-weight static blog engine for Clojure and babashka Add support for a blog contained within another website; see Serving an alternate content root in README. (@jmglov) Upgrade babashka/http-server to 0.1.14 Fix :blog-image-alt option being ignored when using CLI (bb quickblog render) nbb: Scripting in Clojure on Node.js using SCI #395: fix vim-fireplace infinite loop on nREPL session close. Add ILookup and Cons Add abs nREPL: support \"completions\" op neil: A CLI to add common aliases and features to deps.edn-based projects. neil.el - a hook that runs after finding a package (@agzam) neil.el - adds a function for injecting a found package into current CIDER session (@agzam) #245: neil.el - neil-executable-path now can be set to clj -M:neil #251: Upgrade library deps-new to 0.10.3 #255: update maven search URL fs - File system utility library for Clojure #154 reflect in directory check and docs that move never follows symbolic links (@lread) #181 delete-tree now deletes broken symbolic link root (@lread) #193 create-dirs now recognizes sym-linked dirs on JDK 11 (@lread) #184: new check in copy-tree for copying to self too rigid #165: zip now excludes zip-file from zip-file (@lread) #167: add root fn which exposes Path getRoot (@lread) #166: copy-tree now fails fast on attempt to copy parent to child (@lread) #152: an empty-string path \"\" is now (typically) understood to be the current working directory (as per underlying JDK file APIs) (@lread) #155: fs/with-temp-dir clj-kondo linting refinements (@lread) #162: unixify no longer expands into absolute path on Windows (potentially BREAKING) Add return type hint to read-all-bytes process: Clojure library for shelling out / spawning sub-processes #181: support :discard or ProcessBuilder$Redirect as :out and :err options Contributions to third party projects: ClojureScript CLJS-3466: support qualified method in return position CLJS-3468: :refer-global should not make unrenamed object available Other projects These are (some of the) other projects I&aposm involved with but little to no activity happened in the past month. Click for more details - [pod-babashka-go-sqlite3](https://github.com/babashka/pod-babashka-go-sqlite3): A babashka pod for interacting with sqlite3 - [unused-deps](https://github.com/borkdude/unused-deps): Find unused deps in a clojure project - [pod-babashka-fswatcher](https://github.com/babashka/pod-babashka-fswatcher): babashka filewatcher pod - [sci.nrepl](https://github.com/babashka/sci.nrepl): nREPL server for SCI projects that run in the browser - [babashka.nrepl-client](https://github.com/babashka/nrepl-client) - [http-server](https://github.com/babashka/http-server): serve static assets - [nbb](https://github.com/babashka/nbb): Scripting in Clojure on Node.js using SCI - [sci.configs](https://github.com/babashka/sci.configs): A collection of ready to be used SCI configs. - [http-client](https://github.com/babashka/http-client): babashka's http-client - [html](https://github.com/borkdude/html): Html generation library inspired by squint's html tag - [instaparse-bb](https://github.com/babashka/instaparse-bb): Use instaparse from babashka - [sql pods](https://github.com/babashka/babashka-sql-pods): babashka pods for SQL databases - [rewrite-edn](https://github.com/borkdude/rewrite-edn): Utility lib on top of - [rewrite-clj](https://github.com/clj-commons/rewrite-clj): Rewrite Clojure code and edn - [tools-deps-native](https://github.com/babashka/tools-deps-native) and [tools.bbuild](https://github.com/babashka/tools.bbuild): use tools.deps directly from babashka - [bbin](https://github.com/babashka/bbin): Install any Babashka script or project with one command - [qualify-methods](https://github.com/borkdude/qualify-methods) - Initial release of experimental tool to rewrite instance calls to use fully qualified methods (Clojure 1.12 only) - [tools](https://github.com/borkdude/tools): a set of [bbin](https://github.com/babashka/bbin/) installable scripts - [babashka.json](https://github.com/babashka/json): babashka JSON library/adapter - [speculative](https://github.com/borkdude/speculative) - [squint-macros](https://github.com/squint-cljs/squint-macros): a couple of macros that stand-in for [applied-science/js-interop](https://github.com/applied-science/js-interop) and [promesa](https://github.com/funcool/promesa) to make CLJS projects compatible with squint and/or cherry. - [grasp](https://github.com/borkdude/grasp): Grep Clojure code using clojure.spec regexes - [lein-clj-kondo](https://github.com/clj-kondo/lein-clj-kondo): a leiningen plugin for clj-kondo - [http-kit](https://github.com/http-kit/http-kit): Simple, high-performance event-driven HTTP client+server for Clojure. - [babashka.nrepl](https://github.com/babashka/babashka.nrepl): The nREPL server from babashka as a library, so it can be used from other SCI-based CLIs - [jet](https://github.com/borkdude/jet): CLI to transform between JSON, EDN, YAML and Transit using Clojure - [lein2deps](https://github.com/borkdude/lein2deps): leiningen to deps.edn converter - [cljs-showcase](https://github.com/borkdude/cljs-showcase): Showcase CLJS libs using SCI - [babashka.book](https://github.com/babashka/book): Babashka manual - [pod-babashka-buddy](https://github.com/babashka/pod-babashka-buddy): A pod around buddy core (Cryptographic Api for Clojure). - [gh-release-artifact](https://github.com/borkdude/gh-release-artifact): Upload artifacts to Github releases idempotently - [carve](https://github.com/borkdude/carve) - Remove unused Clojure vars - [4ever-clojure](https://github.com/oxalorg/4ever-clojure) - Pure CLJS version of 4clojure, meant to run forever! - [pod-babashka-lanterna](https://github.com/babashka/pod-babashka-lanterna): Interact with clojure-lanterna from babashka - [joyride](https://github.com/BetterThanTomorrow/joyride): VSCode CLJS scripting and REPL (via [SCI](https://github.com/babashka/sci)) - [clj2el](https://borkdude.github.io/clj2el/): transpile Clojure to elisp - [deflet](https://github.com/borkdude/deflet): make let-expressions REPL-friendly! - [deps.add-lib](https://github.com/borkdude/deps.add-lib): Clojure 1.12's add-lib feature for leiningen and/or other environments without a specific version of the clojure CLI"}, :excerpts []} {:rule-id "rescript", :item {:feed-id "planet-clojure", :item-id "https://blog.michielborkent.nl/oss-updates-nov-dec-2025.html", :title "OSS updates November and December 2025", :link "https://blog.michielborkent.nl/oss-updates-nov-dec-2025.html", :published-at #inst "2026-01-01T23:59:59.000-00:00", :content "In this post I&aposll give updates about open source I worked on during November and December 2025. To see previous OSS updates, go here. Sponsors I&aposd like to thank all the sponsors and contributors that make this work possible. Without you, the below projects would not be as mature or wouldn&apost exist or be maintained at all! So a sincere thank you to everyone who contributes to the sustainability of these projects. Current top tier sponsors: Clojurists Together Roam Research Nextjournal Nubank Open the details section for more info about sponsoring. Sponsor info If you want to ensure that the projects I work on are sustainably maintained, you can sponsor this work in the following ways. Thank you! Github Sponsors The Babashka or Clj-kondo OpenCollective Ko-fi Patreon Clojurists Together Updates Clojure Conj 2025 Last November I had the honor and pleasure to visit the Clojure Conj 2025. I met a host of wonderful and interesting long-time and new Clojurians, many that I&aposve known online for a long time and now met for the first time. It was especially exciting to finally meet Rich Hickey and talk to him during a meeting about Clojure dialects and Clojure tooling. The talk that I gave there: \"Making tools developers actually use\" will come online soon. Babashka conf and Dutch Clojure Days 2026 In 2026 I&aposm organizing Babashka Conf 2026. It will be an afternoon event (13:00-17:00) hosted in the Forum hall of the beautiful public library of Amsterdam. More information here. Get your ticket via Meetup.com (currently there&aposs a waiting list, but more places will come available once speakers are confirmed). CfP will open mid January. The day after babashka conf, Dutch Clojure Days 2026 will be happening. It&aposs not too late to get your talk proposal in. More info here. Projects Here are updates about the projects/libraries I&aposve worked on in the last two months in detail. babashka: native, fast starting Clojure interpreter for scripting. Bump process to 0.6.25 Bump deps.clj Fix #1901: add java.security.DigestOutputStream Redefining namespace with ns should override metadata Bump nextjournal.markdown to 0.7.222 Bump edamame to 1.5.37 Fix #1899: with-meta followed by dissoc on records no longer works Bump fs to 0.5.30 Bump nextjournal.markdown to 0.7.213 Fix #1882: support for reifying java.time.temporal.TemporalField (@EvenMoreIrrelevance) Bump Selmer to 1.12.65 SCI: sci.impl.Reflector was rewritten into Clojure dissoc on record with non-record field should return map instead of record Bump edamame to 1.5.35 Bump core.rrb-vector to 0.2.0 Migrate detecting of executable name for self-executing uberjar executable from ProcessHandle to to native image ProcessInfo to avoid sandbox errors Bump cli to 0.8.67 Bump fs to 0.5.29 Bump nextjournal.markdown to 0.7.201 SCI: Configurable Clojure/Script interpreter suitable for scripting Add support for :refer-global and :require-global Add println-str Fix #997: Var is mistaken for local when used under the same name in a let body Fix #1001: JS interop with reserved js keyword fails (regression of #987) sci.impl.Reflector was rewritten into Clojure Fix babashka/babashka#1886: Return a map when dissociating a record basis field. Fix #1011: reset ns metadata when evaluating ns form multiple times Fix for https://github.com/babashka/babashka/issues/1899 Fix #1010: add js-in in CLJS Add array-seq clj-kondo: static analyzer and linter for Clojure code that sparks joy. #2600: NEW linter: unused-excluded-var to warn on unused vars in :refer-clojure :exclude (@jramosg) #2459: NEW linter: :destructured-or-always-evaluates to warn on s-expressions in :or defaults in map destructuring (@jramosg) Add type checking support for sorted-map-by, sorted-set, and sorted-set-by functions (@jramosg) Add new type array and type checking support for the next functions: to-array, alength, aget, aset and aclone (@jramosg) Fix #2695: false positive :unquote-not-syntax-quoted in leiningen&aposs defproject Leiningen&aposs defproject behavior can now be configured using leiningen.core.project/defproject Fix #2699: fix false positive unresolved string var with extend-type on CLJS Rename :refer-clojure-exclude-unresolved-var linter to unresolved-excluded-var for consistency v2025.12.23 #2654: NEW linter: redundant-let-binding, defaults to :off (@tomdl89) #2653: NEW linter: :unquote-not-syntax-quoted to warn on ~ and ~@ usage outside syntax-quote (`) (@jramosg) #2613: NEW linter: :refer-clojure-exclude-unresolved-var to warn on non-existing vars in :refer-clojure :exclude (@jramosg) #2668: Lint & syntax errors in let bindings and lint for trailing & (@tomdl89) #2590: duplicate-key-in-assoc changed to duplicate-key-args, and now lints dissoc, assoc! and dissoc! too (@tomdl89) #2651: resume linting after paren mismatches clojure-lsp#2651: Fix inner class name for java-class-definitions. clojure-lsp#2651: Include inner class java-class-definition analysis. Bump babashka/fs #2532: Disable :duplicate-require in require + :reload / :reload-all #2432: Don&apost warn for :redundant-fn-wrapper in case of inlined function #2599: detect invalid arity for invoking collection as higher order function #2661: Fix false positive :unexpected-recur when recur is used inside clojure.core.match/match (@jramosg) #2617: Add types for repeatedly (@jramosg) Add :ratio type support for numerator and denominator functions (@jramosg) #2676: Report unresolved namespace for namespaced maps with unknown aliases (@jramosg) #2683: data argument of ex-info may be nil since clojure 1.12 Bump built-in ClojureScript analysis info Fix #2687: support new :refer-global and :require-global ns options in CLJS Fix #2554: support inline configs in .cljc files edamame: configurable EDN and Clojure parser with location metadata and more Edamame: configurable EDN and Clojure parser with location metadata and more Minor: leave out :edamame/read-cond-splicing when not splicing Allow :read-cond function to override :edamame/read-cond-splicing value The result from :read-cond with a function should be spliced. This behavior differs from :read-cond + :preserve which always returns a reader conditional object which cannot be spliced. Support function for :features option to just select the first feature that occurs squint: CLJS syntax to JS compiler Allow macro namespaces to load \"node:fs\", etc. to read config files for conditional compilation Don&apost emit IIFE for top-level let so you can write let over defn to capture values. Fix js-yield and js-yield* in expression position Implement some? as macro Fix #758: volatile!, vswap!, vreset! pr-str, prn etc now print EDN (with the idea that you can paste it back into your program) new #js/Map reader that reads a JavaScript Map from a Clojure map (maps are printed like this with pr-str too) Support passing keyword to mapv #759: doseq can&apost be used in expression context Fix #753: optimize output of dotimes alength as macro reagami: A minimal zero-deps Reagent-like for Squint and CLJS Performance enhancements treat innerHTML as a property rather than an attribute Drop support for camelCased properties / (css) attributes Fix :default-value in input range Support data param in :on-render Support default values for uncontrolled components Fix child count mismatch Fix re-rendering/patching of subroots Add :on-render hook for mounting/updating/unmounting third part JS components NEW: parmezan: fixes unbalanced or unexpected parens or other delimiters in Clojure files CLI: Turn Clojure functions into CLIs! #126: - value accidentally parsed as option, e.g. --file - #124: Specifying exec fn that starts with hyphen is treated as option Drop Clojure 1.9 support. Minimum Clojure version is now 1.10.3. clerk: Moldable Live Programming for Clojure always analyze doc (but not deps) when no-cache is set (#786) add option to disable inline formulas in markdown (#780) scittle: Execute Clojure(Script) directly from browser script tags via SCI #114: Enable source maps (@jeroenvandijk) #140: Enable customizing the nrepl websocket port (@PEZ) Bump shadow-cljs and SCI Nextjournal Markdown Add config option to avoid TeX formulas API improvements for passing options cherry: Experimental ClojureScript to ES6 module compiler Fix cherry compile CLI command not receiving file arguments Bump shadow-cljs to 3.3.4 Fix #163: Add assert to macros (@willcohen) Fix #165: Fix ClojureScript protocol dispatch functions (@willcohen) Fix #167: Protocol dispatch functions inside IIFEs; bump squint accordingly Fix #169: fix extend-type on Object Fix #171: Add satisfies? macro (@willcohen) deps.clj: A faithful port of the clojure CLI bash script to Clojure Released several versions catching up with the clojure CLI quickdoc: Quick and minimal API doc generation for Clojure Fix extra newline in codeblock quickblog: light-weight static blog engine for Clojure and babashka Add support for a blog contained within another website; see Serving an alternate content root in README. (@jmglov) Upgrade babashka/http-server to 0.1.14 Fix :blog-image-alt option being ignored when using CLI (bb quickblog render) nbb: Scripting in Clojure on Node.js using SCI #395: fix vim-fireplace infinite loop on nREPL session close. Add ILookup and Cons Add abs nREPL: support \"completions\" op neil: A CLI to add common aliases and features to deps.edn-based projects. neil.el - a hook that runs after finding a package (@agzam) neil.el - adds a function for injecting a found package into current CIDER session (@agzam) #245: neil.el - neil-executable-path now can be set to clj -M:neil #251: Upgrade library deps-new to 0.10.3 #255: update maven search URL fs - File system utility library for Clojure #154 reflect in directory check and docs that move never follows symbolic links (@lread) #181 delete-tree now deletes broken symbolic link root (@lread) #193 create-dirs now recognizes sym-linked dirs on JDK 11 (@lread) #184: new check in copy-tree for copying to self too rigid #165: zip now excludes zip-file from zip-file (@lread) #167: add root fn which exposes Path getRoot (@lread) #166: copy-tree now fails fast on attempt to copy parent to child (@lread) #152: an empty-string path \"\" is now (typically) understood to be the current working directory (as per underlying JDK file APIs) (@lread) #155: fs/with-temp-dir clj-kondo linting refinements (@lread) #162: unixify no longer expands into absolute path on Windows (potentially BREAKING) Add return type hint to read-all-bytes process: Clojure library for shelling out / spawning sub-processes #181: support :discard or ProcessBuilder$Redirect as :out and :err options Contributions to third party projects: ClojureScript CLJS-3466: support qualified method in return position CLJS-3468: :refer-global should not make unrenamed object available Other projects These are (some of the) other projects I&aposm involved with but little to no activity happened in the past month. Click for more details - [pod-babashka-go-sqlite3](https://github.com/babashka/pod-babashka-go-sqlite3): A babashka pod for interacting with sqlite3 - [unused-deps](https://github.com/borkdude/unused-deps): Find unused deps in a clojure project - [pod-babashka-fswatcher](https://github.com/babashka/pod-babashka-fswatcher): babashka filewatcher pod - [sci.nrepl](https://github.com/babashka/sci.nrepl): nREPL server for SCI projects that run in the browser - [babashka.nrepl-client](https://github.com/babashka/nrepl-client) - [http-server](https://github.com/babashka/http-server): serve static assets - [nbb](https://github.com/babashka/nbb): Scripting in Clojure on Node.js using SCI - [sci.configs](https://github.com/babashka/sci.configs): A collection of ready to be used SCI configs. - [http-client](https://github.com/babashka/http-client): babashka's http-client - [html](https://github.com/borkdude/html): Html generation library inspired by squint's html tag - [instaparse-bb](https://github.com/babashka/instaparse-bb): Use instaparse from babashka - [sql pods](https://github.com/babashka/babashka-sql-pods): babashka pods for SQL databases - [rewrite-edn](https://github.com/borkdude/rewrite-edn): Utility lib on top of - [rewrite-clj](https://github.com/clj-commons/rewrite-clj): Rewrite Clojure code and edn - [tools-deps-native](https://github.com/babashka/tools-deps-native) and [tools.bbuild](https://github.com/babashka/tools.bbuild): use tools.deps directly from babashka - [bbin](https://github.com/babashka/bbin): Install any Babashka script or project with one command - [qualify-methods](https://github.com/borkdude/qualify-methods) - Initial release of experimental tool to rewrite instance calls to use fully qualified methods (Clojure 1.12 only) - [tools](https://github.com/borkdude/tools): a set of [bbin](https://github.com/babashka/bbin/) installable scripts - [babashka.json](https://github.com/babashka/json): babashka JSON library/adapter - [speculative](https://github.com/borkdude/speculative) - [squint-macros](https://github.com/squint-cljs/squint-macros): a couple of macros that stand-in for [applied-science/js-interop](https://github.com/applied-science/js-interop) and [promesa](https://github.com/funcool/promesa) to make CLJS projects compatible with squint and/or cherry. - [grasp](https://github.com/borkdude/grasp): Grep Clojure code using clojure.spec regexes - [lein-clj-kondo](https://github.com/clj-kondo/lein-clj-kondo): a leiningen plugin for clj-kondo - [http-kit](https://github.com/http-kit/http-kit): Simple, high-performance event-driven HTTP client+server for Clojure. - [babashka.nrepl](https://github.com/babashka/babashka.nrepl): The nREPL server from babashka as a library, so it can be used from other SCI-based CLIs - [jet](https://github.com/borkdude/jet): CLI to transform between JSON, EDN, YAML and Transit using Clojure - [lein2deps](https://github.com/borkdude/lein2deps): leiningen to deps.edn converter - [cljs-showcase](https://github.com/borkdude/cljs-showcase): Showcase CLJS libs using SCI - [babashka.book](https://github.com/babashka/book): Babashka manual - [pod-babashka-buddy](https://github.com/babashka/pod-babashka-buddy): A pod around buddy core (Cryptographic Api for Clojure). - [gh-release-artifact](https://github.com/borkdude/gh-release-artifact): Upload artifacts to Github releases idempotently - [carve](https://github.com/borkdude/carve) - Remove unused Clojure vars - [4ever-clojure](https://github.com/oxalorg/4ever-clojure) - Pure CLJS version of 4clojure, meant to run forever! - [pod-babashka-lanterna](https://github.com/babashka/pod-babashka-lanterna): Interact with clojure-lanterna from babashka - [joyride](https://github.com/BetterThanTomorrow/joyride): VSCode CLJS scripting and REPL (via [SCI](https://github.com/babashka/sci)) - [clj2el](https://borkdude.github.io/clj2el/): transpile Clojure to elisp - [deflet](https://github.com/borkdude/deflet): make let-expressions REPL-friendly! - [deps.add-lib](https://github.com/borkdude/deps.add-lib): Clojure 1.12's add-lib feature for leiningen and/or other environments without a specific version of the clojure CLI"}, :excerpts []}]