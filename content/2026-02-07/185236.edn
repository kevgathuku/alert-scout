[{:rule-id "rails-deploy", :item {:feed-id "planet-clojure", :item-id "https://jobs.braveclojure.com/company/openmarkets-health/listing/full-stack-engineer-mid-to-senior-level/lP_6RtfCmrc4ylUtzhZeQ", :title "Full Stack Engineer (mid- to senior-level) at OpenMarkets Health", :link "https://jobs.braveclojure.com/company/openmarkets-health/listing/full-stack-engineer-mid-to-senior-level/lP_6RtfCmrc4ylUtzhZeQ", :published-at #inst "2026-02-07T13:16:15.000-00:00", :content "Full Stack Engineer (mid- to senior-level) at OpenMarkets Health OpenMarkets people are… Committed to driving waste out of healthcare Transparent and accountable to their colleagues on a weekly basis. Committed to the success of their customers and their teammates. Hungry to learn by making and sharing their mistakes, as well as reading and discussing ideas with their teammates. Eager to do today what most people would put off until tomorrow. Why you want to work with us… Fast-paced start-up environment with a lot of opportunity to make a large impact. Passionate, dedicated colleagues with a strong vision for changing how healthcare equipment purchasing is done. Opportunity to develop software to help remove wasteful spending from equipment purchasing, leaving more dollars for patient care. Other benefits include comprehensive health care benefits, 401K with 4% match, pre-tax transit benefits, generous PTO, flexible maternity/family leave options and the ability to work remotely. Apply today if you are someone… Who is proficient in Clojure and ClojureScript (bonus if you're also familiar with Ruby on Rails). Who knows (or is willing to learn) re-frame and Reagent Forms. Who practices test-driven development Who has written software for at least 4 years. Is empathetic towards their team, understands the tradeoffs in their implementations, and communicates their code effectively. Can speak and write in non-technical terms, and believes in the value of effective time management. We want everyone OpenMarkets is an equal opportunity employer. We believe that we can only make healthcare work for everyone if we get everyone to work on it. We do not discriminate on the basis of race, religion, color, national origin, gender, sexual orientation, age, marital status, veteran status, or disability status."}, :excerpts [{:text "... (bonus if you're also familiar with Ruby on Rails). Who knows (or is willing to learn)...", :matched-terms ["rails" "ruby"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://dev.to/pvgomes/java-in-2026-still-boring-still-powerful-still-printing-money-5ehj", :title "Java in 2026: still boring, still powerful, still printing money", :link "https://dev.to/pvgomes/java-in-2026-still-boring-still-powerful-still-printing-money-5ehj", :published-at #inst "2026-02-07T14:16:00.000-00:00", :content "Let’s be honest. Java is not sexy. Nobody wakes up excited thinking “wow, I hope today I can write some beautiful enterprise Java code.” And yet… Banks, fintechs, payment processors, credit engines, risk platforms, and trading systems are still massively powered by Java in 2026. And they’re not moving away anytime soon. With AI taking up to 70% of written code? Not a problem. I have worked as a software engineer for more than 17 years, and since I've started, people talking about java becoming legacy was just part of my day. we are in 2026, american debt is skyrocketing, BTC is melting and dollar losing value... while Java? Well, looks like this guy is a tough dinosaur Quick Java timeline (why this dinosaur refuses to die) 1995 → Java is born. “Write once, run anywhere.” 2006 → Open-sourced. Enterprise adoption explodes. 2014 → Java 8. Lambdas. Streams. Real modern Java begins. 2018–2021 → 6-month release cycle. JVM performance goes crazy. 2021 → Java 17 LTS becomes enterprise default. 2023 → Java 21 LTS ships with virtual threads (Project Loom). Massive scalability shift. 2026 → Java 25 era. Cloud-native, AI-assisted dev, still dominating finance production systems. So yeah… Not dead. Not even close. Why finance still trusts Java more than anything else financial systems do not care about hype. They care about, predictability, latency stability, memory safety, tooling maturity and last but not least a huge hiring pool JVM stability is unmatched if you run: loan engines payment authorization anti-fraud scoring card transaction routing JVM gives: battle-tested GC (even with its problems) insane observability deterministic performance tuning backwards compatibility across decades Concurrency changed the game (virtual threads) Before Java 21: threads were expensive and async code was ugly, now: try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    IntStream.range(0, 1_000_000).forEach(i ->\n        executor.submit(() -> processTransaction(i))\n    );\n}\n This is millions of concurrent operations with simple blocking code and no reactive nightmare. For fintech backends, this is huge. Spring ecosystem still dominates enterprise Yes, people complain about Spring Boot, but look at reality: 80%+ of fintech APIs run on Spring security + observability + config = solved problems onboarding engineers is easy production support is predictable Example minimal API: @RestController\n@RequestMapping(\"/loans\")\npublic class LoanController {\n\n    @GetMapping(\"/{id}\")\n    public Loan getLoan(@PathVariable String id) {\n        return new Loan(id, BigDecimal.valueOf(1000));\n    }\n}\n Boring? Yes, but every engineer can get it easily, even in an eventual case of some AI-code-creationg halucination. Finance chooses boring. Performance is no longer an excuse Modern JVM gives ZGC/Shenandoah which is ultra-low latency GC, JIT + profiling that optimizes the runtime, theres also a GraalVM native images for faster startup on any cloud provider The real shift in 2026: AI-augmented Java developers This is where things get interesting, guess what? java is a big winner here, if I can't check everything is being created, how about I rely on a very deterministic well shapped programming language? A simple example on putting claude code/github copilot to work for you Example: generate a Spring service instantly Prompt in editor: create a service that calculates compound interest with validation and unit tests Result in seconds: @Service\npublic class InterestService {\n\n    public BigDecimal compound(\n        BigDecimal principal,\n        BigDecimal rate,\n        int periods\n    ) {\n        if (principal.signum() <= 0 || rate.signum() < 0 || periods < 0) {\n            throw new IllegalArgumentException(\"Invalid input\");\n        }\n\n        return principal.multiply(\n            BigDecimal.ONE.add(rate).pow(periods)\n        );\n    }\n}\n tests look like a charming... @Test\nvoid compound_shouldGrow() {\n    var service = new InterestService();\n    var result = service.compound(\n        BigDecimal.valueOf(1000),\n        BigDecimal.valueOf(0.1),\n        2\n    );\n\n    assertEquals(new BigDecimal(\"1210.00\"), result.setScale(2));\n}\n Time saved with control. How about using claude for refactoring and architecture? Some things that were a nightmare before, now are just a task in jira like: migrating legacy Java 8 → Java 21 converting blocking code → virtual threads generating integration tests explaining weird enterprise codebases Real workflow: inline or chat with the legacy class modernize for Java 21 + clean architecture\n tadah: get production-ready refactor This is insane leverage. Lets talk about career now, this moment a lot of software engineers are actually loosing their jobs, one more reason why java careers are still strong... Everyone wants to learn: Rust Go A new AI-agent-ish of work shiny new things But banks still run on Java, and guess what? So supply ↓ Demand ↑ Opportunity. Lets finish here... Java in 2026 is like: a boring Swiss bank account that quietly keeps getting richer Not hype. Not trendy. But extremely powerful where it matters. And in finance…, and somehow, even this boring guy is leveraging himself on AI to get fun a nice I'm not saying sitck with java, java is more than a programming language, it is a technology, we have for example Clojure that is a lisp way of coding that runs on JVM, how about Kotlin? My point is to be aware and awake, Java still rocks. posted here"}, :excerpts [{:text "Java in 2026: still boring, still powerful, still...", :matched-terms ["java"], :source :title} {:text "Let’s be honest. Java is not sexy. Nobody wakes up excited thinking “wow, I hope today I can write some beautiful enterprise Java code.” And yet… Banks, fintechs, payment...", :matched-terms ["java"], :source :content} {:text "... trading systems are still massively powered by Java in 2026. And they’re not moving away anytime...", :matched-terms ["java"], :source :content}]}]