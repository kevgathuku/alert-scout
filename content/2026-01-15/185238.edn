[{:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://www.jvm-weekly.com/p/while-the-ink-is-still-wet-jdk-mailing", :title "Java‚Äôs Plans for 2026 and new curiosities from JDK Mailing Lists  - JVM Weekly vol. 159", :link "https://www.jvm-weekly.com/p/while-the-ink-is-still-wet-jdk-mailing", :published-at #inst "2026-01-15T14:02:58.000-00:00", :content "New year, new plans, new promises we‚Äôll look back on in twelve months with a mixture of nostalgia and disappointment. But rather than dwelling too much on those New Year‚Äôs resolutions - there‚Äôll be plenty of opportunity for that - let‚Äôs take a look at what OpenJDK teams themselves are saying about their plans for 2026. Thanks for reading JVM Weekly! Subscribe for free to receive new posts and support my work. OpenJDK Plans for 2026 - Valhalla Getting Closer, Amber Not Slowing Down, Loom Nearly Complete I have to admit: Nicolai Parlog from Oracle gave me a pleasant surprise. His New Year‚Äôs episode of Inside Java Newscast extracted concrete details from people working on individual projects. An ‚Äúanonymous source‚Äù (whose identity anyone who‚Äôs ever heard Brian Goetz will immediately guess) dropped some bombs worth discussing. Valhalla is targeting JDK 28. This is probably the most important piece of news. Our Anonymous Source revealed that value types won‚Äôt make it into JDK 27 - but not because they aren‚Äôt ready. ‚ÄúWe‚Äôre bringing an elephant onto a train and want to make sure we get into an empty car.‚Äù JDK 27 forks in June, so mainline will switch to 28 then - with room for JEP 401. After value types, nullness markers, array improvements, and primitive-wrapper unification are queued up - but that‚Äôs a perspective for later releases. Vector API is waiting for Valhalla. JDK 26 will see its eleventh (!) incubation - and it‚Äôll stay that way until value types land in mainline. When that happens, the implementation will be rewritten and the API moved from jdk.incubator.vector to the proper java package. Leyden - AOT code compilation. The AOT cache will contain not just loaded classes and method profiles, but compiled machine code as well. The runtime will be able to pull optimized code straight from the cache, dramatically reducing warmup time. Structured Concurrency nearing finalization. After the revamp in JDK 25, the API will go through preview with minimal changes - Nikolai rates the chances of finalization this year as good. This is the last piece of the big Project Loom picture (though some would like to see a bit of ‚Äúscope creep‚Äù here - in the positive way - which we‚Äôll get to shortly). Amber - constant patterns and pattern assignment. The team is ‚Äúknee-deep in the second phase of pattern matching.‚Äù Two features are mature enough that JEPs may appear this year. We‚Äôll examine all of this ourselves in a moment since the details from the mailing lists are very interesting, but apparently ideas for generalizing records and pattern matching to classes and interfaces are popping up on amber-spec-experts. So ‚Äúthings are happening.‚Äù Babylon preparing code reflection incubation. The technology allowing frameworks to reflect over code in methods and lambdas is developing well‚Äîwe should hear more this year. I‚Äôm personally eager for any announcements related to GPU support. That‚Äôs the official plans. But as usual, the most interesting things happen at the margins‚Äîin experimental branches and mailing list discussions. And that‚Äôs exactly where Valhalla is showing that value types are just the beginning of a much more ambitious story. Type Classes - Valhalla experiments with the next step Maurizio Cimadamore announced on the valhalla-dev list the publication of an experimental type classes prototype - a mechanism Brian Goetz presented at JVMLS 2025 in his talk Growing the Java Language. The code landed in a new type-classes branch in the Valhalla repository. What problem do type classes solve? Today in Java, you can‚Äôt write generic mathematical code that works on int, BigDecimal, and a hypothetical Float16 alike. Interfaces require types to explicitly implement them - you can‚Äôt say Integer implements Addable without modifying the Integer class. Type classes (known from Haskell, appearing as traits in Rust) invert this relationship: instead of requiring implementation in the class, you provide an external ‚Äúwitness‚Äù that says ‚Äúhere‚Äôs how to add values of type X.‚Äù Witnesses can be defined for any type, even someone else‚Äôs. record MyInt(int x) { }\n\ninterface Sum<X> {\n    X zero();\n    X add(X a, X b);\n}\n\n__witness Sum<MyInt> SUM_MYINT = new Sum<>() {\n    MyInt zero() { return new MyInt(0); }\n    MyInt add(MyInt a, MyInt b) { return new MyInt(a.x + b.x); }\n};\n\n// Usage:\nSum<MyInt> sum = Sum<MyInt>.__witness;\nMyInt zero = sum.zero();\nMyInt one = new MyInt(1);\nassert sum.add(zero, one).equals(one);\n In this prototype, you can define a type class and a witness for a specific type. For example, here‚Äôs how an addition type class (Sum) and its witness for a value class MyInt are defined. Sum<X> is a generic interface representing a type class for addition. __witness defines a witness for how MyInt implements that type class externally. The witness can then be looked up and used at runtime. This prototype enables external definitions of operations for types without modifying those types themselves, addressing a long-standing limitation in Java: today it‚Äôs impossible to write truly generic mathematical code that works uniformly across primitives like int, boxed types such as BigDecimal, and custom numeric or value types, because interfaces require the types to explicitly implement them. Type classes invert this relationship by allowing behavior to be attached externally via so-called ‚Äúwitnesses,‚Äù making it possible to state ‚Äúhere‚Äôs how type X does addition‚Äù without editing X at all. Goetz explained the broader vision at JVMLS: type classes are meant to enable operator overloading for value types, collection literals, or new numeric types with full support for +, -, * - but without the operator hell known from C++, since they‚Äôd be limited to value classes only. C++ macros are even more‚Ä¶ interesting. Maurizio is very clear on one point, though: this is purely a space for experimentation, not a proposal for inclusion in the Java platform, and any JEP is still a long way off. With Valhalla, as ever, patience is part of the lesson. However, they have even more under they sleeve now! Null Checks get concrete - The ‚ÄúBang World‚Äù Prototype Daniel Smith announced on valhalla-spec-experts another prototype branch worth watching: bworld (short for ‚Äúbang world‚Äù). This one tackles the long-awaited nullness markers - specifically, the runtime enforcement side of making ! actually mean something. The idea is straightforward: mark types with ! to indicate a non-null barrier, and have the JVM enforce it. You‚Äôll be able to use ! on field types, local variables, method parameters, return types, casts, instanceof, and array element types. And crucially - this isn‚Äôt limited to value classes. Any reference type can be marked. What happens at runtime? The compiler generates calls to a new java.lang.runtime.Checks API (deliberately not Objects.requireNonNull - they want the JVM to have freedom to treat these checks specially). What those it mean in practice? A cast to String! will throw if you pass null A field declared as String! name must be initialized before the super() call. Arrays created with new Foo![]{a, b, c} will reject null writes dynamically. Daniel notes that current implementation only fully supports runtime checks for value-class-typed fields and arrays - other reference types will get the metadata in the class file, but enforcement is coming later. The prototype also includes optional lint warnings for suspicious patterns - like assigning null literals to ! targets or removing ! markers when overriding methods. But the most interesting bit is ‚Äúuse-site checks‚Äù: the compiler can insert null checks when calling methods from untrusted binaries! This neatly exposes the real problem: not greenfield code, but millions of libraries that were written when null markers weren‚Äôt even imaginable. That‚Äôs the real challenge: how to introduce null-safety into a 30-year-old ecosystem gradually, without breaking the world? But as Daniel puts it: This is not the final version of the feature... it‚Äôs a snapshot. But we‚Äôve been wanting something concrete that we could play with. The Kotlin crowd will feel right at home, except for one crucial difference: Kotlin‚Äôs null-safety is purely a compiler-land, erased at runtime. Java is building actual JVM enforcement. Slower to arrive, but when a String! field says ‚Äúnever null,‚Äù the runtime will back that promise up. Ephemeral Threads - Clojure knocks on Project Loom‚Äôs Door ‚ÄúWith a Request‚Äù Mama, take this badge off of me I can‚Äôt use it anymore It‚Äôs gettin‚Äô dark, too dark for me to see I feel like I‚Äôm knockin‚Äô on heaven‚Äôs door Since Structured Concurrency is approaching finalization, can Project Loom be considered ‚Äúfinished‚Äù? The community has a different opinion. A heated discussion (30+ emails in a week) erupted on the loom-dev list, initiated by Alex Miller from the Clojure team. The topic? So-called ‚Äúephemeral threads‚Äù- threads that can be garbage collected before they finish their work. Sounds like heresy in the Java world, where for 30 years an iron rule has applied: threads are GC roots and live until they complete their work. But for the Clojure community, this has been daily bread for over a decade. What‚Äôs the deal? The core.async library lets you create lightweight ‚Äúgo blocks‚Äù that wait for data from channels. If all channels become unreachable, the block can also be collected by GC - since it would never wake up anyway. Elegant and practical when building pub/sub or pipelines. The problem: after migrating to virtual threads, the pattern stopped working. Alan Bateman, Tech Lead of Loom, is however skeptical about the ephemeral thread concept, pointing to deeper complications: interactions with finalizers and cleaners can lead to scenarios from mildly creepy to truly terrifying.: The possibility of GC‚Äôing a started thread before it terminates is a scary topic. It interacts with many areas and gets really scary once you bring phantom refs, cleaners, and finalizers into the discussion. For these so-called ‚Äúforgotten sender‚Äù and ‚Äúabandoned receiver‚Äù cases then it might be more interesting to see how they could be work with structured concurrency. Right now, the first API is focused on fan-out scenarios but in time we would like to have it work with channel like constructs too. I suspect this will be closer to what you are interested in. Since JDK 21, VTs are tracked by default for diagnostic tools, so ‚Äúabandoned‚Äù threads hang in memory indefinitely. The flag - Djdk.trackAllThreads=false helps, but Miller rightly asks about its future, and hears from Alan Bateman: It's clearly an attractive nuisance right now and setting it to false is specific to the root \"thread grouping\". There is some performance work required in that area but otherwise I think it needs to be removed. The argument for ephemeral threads is simple: virtual threads open the door to Erlang-style architectures where lightweight processes can be abandoned when they become redundant. Miller writes directly: Most of these constructs work as infinite loops without persistent references. You simply can‚Äôt build such libraries with the traditional approach to thread termination. Similar voices came from other users experimenting with their own schedulers - they want to use VTs as an invisible implementation detail where the end programmer doesn‚Äôt think about threads at all. Oracle has serious concerns, however. The main one: debugging. Viktor Klang illustrates with an example - code acquires a file descriptor, parks the thread, then releases it. If the thread gets collected while parked, the descriptor leaks without a trace. This easily leads to problems where resources leak without any trace of who lost the - which can be nightmarish in production, argues Klang. Andrew Haley from Red Hat offered an interesting counterargument: if a thread is waiting on an unreachable semaphore, it will never release resources anyway - whether it takes up memory or not, the problem is the same. There is a light at the end of the tunnel, however. Bateman suggests that cases of ‚Äúabandoned‚Äù threads might play better with structured concurrency, which over time is meant to handle channel constructs as well. For Clojure, though, this means waiting - an official API for ephemeral threads probably won‚Äôt materialize, and the unofficial flag will likely disappear. The discussion shows a broader trend: virtual threads opened Pandora‚Äôs box of new patterns that the JVM ecosystem is only beginning to explore. Project Amber in 2026 - Pattern Assignment and Constant Patterns on the Horizon And finally, Gavin Bierman from the Amber team shared details of plans for 2026 on the amber-spec-experts list. Beyond continuing work on Primitive Patterns (currently in preview), two new features are in the pipeline - draft JEPs should appear soon. Pattern Assignment solves an irritating problem: sometimes we use pattern matching not because something might match, but because we want to conveniently decompose a value into parts. Today we have to write: void process(ColorPoint cp) {\n    if (cp instanceof ColorPoint(var x, var y, var c)) {\n        // actual code, unnecessarily nested\n    }\n}\n The compiler and programmer both know the pattern will always work‚Äîbut the syntax forces us to pretend it‚Äôs a conditional operation. The new proposal will let you simply write: void process(ColorPoint cp) {\n    ColorPoint(var x, var y, var c) = cp;  // Pattern Assignment!\n    // actual code, no nesting\n} Constant Patterns is the second proposal, simplifying a common case‚Äîmatching against a specific value. Instead of: case Point(var x, var y) when x == 0 && y == 0 -> { /* origin */ } You‚Äôll be able to write: case Point(0, 0) -> { /* origin */ } Constants (including null) will be able to appear directly as nested patterns - which will somewhat unify the awkward division between ‚Äúcase constants‚Äù and ‚Äúcase patterns.‚Äù Finally, a small observation from my functional heart (working at the company behind Scala obliges üòâ). Looking at all these discussions, it‚Äôs hard not to notice a common denominator: functional languages and their concepts remain a key reference point for JVM evolution. Type classes are a mechanism straight from Haskell. Pattern assignment is essentially the equivalent of let with deconstruction known from ML-family languages. And ephemeral threads? It‚Äôs a request for semantics that Erlang and its descendants have treated as obvious for years. But here‚Äôs where it gets interesting: Java isn‚Äôt so much ‚Äúadopting‚Äù these concepts as conducting a sort of dialogue with them - and often says ‚Äúno‚Äù or ‚Äúyes, but.‚Äù Type classes will be limited to value classes to avoid ‚Äúoperator overloading hell.‚Äù Ephemeral threads? Bateman politely suggests that maybe structured concurrency will someday handle these cases - which in practice means ‚Äúwe‚Äôll do it our way or not at all.‚Äù Pattern matching is evolving so cautiously that Scala had time to have it, stop having it (in the sense of: stop being fashionable), and have it again before Java got to constant patterns. And this is precisely the paradox that fascinates me: paradoxically, Java has probably become the most important testing ground for functional ideas in the mainstream‚Äînot despite its conservatism, but because of it. Every feature goes through such brutal mills of backward compatibility, edge case analysis, and years of preview that what comes out the other side is... surprisingly solid. Haskell‚Äôs type classes are elegant but also notoriously difficult for the average programmer to understand. Java will probably produce something less elegant, more ‚Äúcorporate‚Äù- and paradoxically more useful for most developers. Because there are some genuinely good ideas there beyond the memes and cheap laughs. There‚Äôs a certain irony in all of this: Clojure, the language that since 2007 has been proving that functional programming on the JVM is possible and practical, is now asking for functionality it implemented itself for a decade‚Äîbut can‚Äôt port to virtual threads without platform support. Alex Miller knocks on the door with a proposal inspired by Erlang, and Java responds in the style of: ‚Äúinteresting, but have you thought about interaction with finalizers? Because we have, and we have nightmares.‚Äù Maybe that‚Äôs exactly why this relationship works. Functional languages explore, Java stabilizes. Erlang shows that ephemeral processes are possible, Clojure proves they work in practice on the JVM, and ten years from now Java will introduce something called ‚ÄúScoped Ephemeral Task Contexts‚Äù that will work with every version back to JDK 8. And mass-market enterprise will finally get a feature that functional programmers were talking about at conferences in 2015. That‚Äôs the deal‚Äîand honestly, I‚Äôm not sure there‚Äôs a better model for evolving a programming language that has to support billions of lines of production code. PS: If you want to go deeper - see you in person üëã If this edition resonated and you‚Äôd like to continue the conversation offline, I‚Äôll be talking about JVM in the Age of AI at a few upcoming events: üá∏üá™ JVM in the Age of AI: 2026 Edition @ JFokus 2026 I‚Äôll be running a 90-minute Deep Dive session focused on what really needs to happen inside the JVM for it to remain a serious platform for AI and ML - hardware, Valhalla, Babylon, GPU offloading, TornadoVM, Llama3.java, and the 2026 perspective. I‚Äôll also be doing two polish JUGs during one week, talking about ‚ÄúAgentic Systems beyond localhost‚Äù with more room for questions (and for me to fill üòÅ) 21.01 - Wroc≈Çaw Java User Group (With One-and-Only Jarek Pa≈Çka) 22.01 - Kielce Java User Group Love the meetup, as they give a bit more freedom to speaker - and I always like to adapt to what you want to dig into. If you‚Äôre around: come say hi, argue, disagree, or just nerd out about the JVM. Before we close this edition, one sad piece of news. Scott Adams has passed away. I know - he was a controversial figure, especially in his later years, and not everyone agreed with his views. But there‚Äôs no denying one thing: his humor was singular, sharp in a way that only engineers and office survivors truly appreciate. For years, Dilbert perfectly captured the absurdities of corporate life, technical organizations, and management theater ‚Äî and it did so with a precision that made it a recurring guest in this newsletter. Many of us laughed because it was funny; many of us winced because it was accurate. Whatever one thinks about Scott Adams the person, Scott Adams the cartoonist shaped a generation of engineers and gave us a shared language to talk about dysfunction, nonsense, and the quiet heroism of surviving another meeting that should have been an email. Rest in peace, Scott. Thanks for reading JVM Weekly! Subscribe for free to receive new posts and support my work."}, :excerpts [{:text "Java‚Äôs Plans for 2026 and new curiosities from JDK Mailing Lists  - JVM Weekly vol. 159", :matched-terms ["java" "jvm"], :source :title} {:text "... class=\"cta-caption\">Thanks for reading JVM Weekly! Subscribe for free to receive new posts...", :matched-terms ["jvm"], :source :content}]}]