[{:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://coruscation.net/blogs/about-dynamic-adding-to-classpath-in-clojure.html", :title "About Dynamic Adding to Classpath in Clojure", :link "https://coruscation.net/blogs/about-dynamic-adding-to-classpath-in-clojure.html", :published-at #inst "2026-01-25T12:43:45.000-00:00", :content "Well, I guess people will just inevitably get into the problem of classpath, one way or another. The Classpath is a Lie described the problem very well: classpath is a lie. classpath, per se, is a simple list separated by colons, however, the real work is done by the Classloader. Nevertheless, this isn't a post talking about classpath and ClassLoader. There are already a lot of great articles talking about it (links at the end of this post), and I can't claim I understand ClassLoaders to the extent that I can confidently teach others about it either. This is a blog about what I have found during the process of trying to add new directories to classpath and require Clojure files in them at runtime. ClassLoader in Clojure is something very messy. The best strategy probably is to avoid the problem altogether. But still, if you really want to do it, I wish the following content can offer some help. Use Builtin clojure.core/add-classpath Clojure has a builtin add-classpath function. Although it has been deprecated, it works for simple use cases. (defn check-dynamic-load []\n  (let [tmp-dir (.toFile (Files/createTempDirectory \"classpath-demo\" (into-array java.nio.file.attribute.FileAttribute [])))\n        tmp-clj (File/createTempFile \"demo\" \".clj\" tmp-dir)\n        tmp-name (subs (.getName tmp-clj)\n                       0\n                       (.lastIndexOf (.getName tmp-clj)\n                                     \".\"))]\n    ;; Add `tmp-dir` to `classpath` using builtin `add-classpath`.\n    (add-classpath (.toURL tmp-dir))\n\n    ;; Put a Clojure file under the directory\n    (spit tmp-clj\n          (str \"(ns \" tmp-name \") (def a 1)\"))\n                                        ;\n    ;; `require` the Clojure file, and resolve the variable\n    (assert (= 1 (var-get (requiring-resolve (symbol tmp-name\n                                                     \"a\")))))\n\n    ;; Update the Clojure file\n    (spit tmp-clj\n          (str \"(ns \" tmp-name \") (def a 2)\"))\n\n    ;; Reload the Clojure file\n    (require (symbol tmp-name)\n             :reload-all)\n\n    ;; We can read the new value\n    (assert (= 2 (var-get (requiring-resolve (symbol tmp-name\n                                                     \"a\")))))\n    (println \"success\")))\n\n;; success\n(check-dynamic-load)\n If we evaluate the above code in a REPL or in cider, it works and prints \"success\". As we can see from the code, we can require a Clojure file whose path determined at runtime, and reload it to get the updated value. However, there is a reason of it being deprecated. We can check its source code: // The method used by clojure.core/add-classpath\nstatic public void addURL(Object url) throws MalformedURLException{\n      URL u = (url instanceof String) ? toUrl((String) url) : (URL) url;\n      ClassLoader ccl = Thread.currentThread().getContextClassLoader();\n      if(ccl instanceof DynamicClassLoader)\n              ((DynamicClassLoader)ccl).addURL(u);\n      else\n              throw new IllegalAccessError(\"Context classloader is not a DynamicClassLoader\");\n}\n It checks if the current thread's ContextClassLoader is a DynamicClassLoader. If so, it will call the DynamicClassLoader's addURL method. That means, this method will fail if there's some code set the current ContextClassLoader to something other than a DynamicClassLoader. We expect add-classpath continues to work in case because the convention of setting a new ClassLoader is to set the current ClassLoader as the parent of the newly created ClassLoader. However, clojure.core/add-classpath only checks the current ClassLoader, more on this in the section. (let [future\n      (future\n        (let [cl (.getContextClassLoader (Thread/currentThread))]\n          (.setContextClassLoader (Thread/currentThread)\n                                  (java.net.URLClassLoader. (into-array java.net.URL [])\n                                                            cl)))\n            (try (check-dynamic-load)\n             (assert \"unreachable\")\n             (catch Throwable t\n               (println \"dynamic loading failed\"))))]\n  ;; \"dynamic loading failed\"\n  @future)\n Use add-classpath from pomegranate pomegranate provides a add-classpath that solves the problem described in the previous section. The only thing we need to change is to replace clojure.core/add-classpath with cemerick.pomegranate/add-classpath. (ns demo\n  (:require\n   [cemerick.pomegranate :as pomegranate]))\n\n(defn check-dynamic-load-using-pomegranate []\n  (let [;; ...\n        ]\n    ;; same code as `check-dynamic-load`\n    (pomegranate/add-classpath (.toURL tmp-dir))\n    ;; same code as `check-dynamic-load`\n    ))\n\n(let [future\n      (future\n        (let [cl (.getContextClassLoader (Thread/currentThread))]\n          (.setContextClassLoader (Thread/currentThread)\n                                  (java.net.URLClassLoader. (into-array java.net.URL [])\n                                                            cl)))\n        (check-dynamic-load-using-pomegranate)\n        (print \"success\"))]\n  ;; success\n  @future)\n Unlike add-classpath from clojure.core, pomegranate's add-classpath try to find the ClassLoader closest to the Primordial ClassLoader that is compatible with add-classpath, and call the addURL method from it. ;; in `add-classpath` function in pomegranate.clj  \n(let [classloaders (classloader-hierarchy)]\n      (if-let [cl (last (filter modifiable-classloader? classloaders))]\n        (add-classpath jar-or-dir cl)\n        (throw (IllegalStateException. (str \"Could not find a suitable classloader to modify from \"\n                                            (mapv (fn [^ClassLoader c]\n                                                    (-> c .getClass .getSimpleName))\n                                                  classloaders))))))\n Create a DynamicClassLoader When There isn't One If you are running Clojure in REPL or with nrepl, the ContextClassLoader of the current thread will certainly be DynamicClassLoader, set by one of those tools. However, when you run clj command in a non-interactive manner, or use a AOT-compiled jar file, this wouldn't be the case. This problem is quite easy to solve, we just need to set the ContextClassLoader to a DynamicClassLoader created by ourselves in the entrypoint of the program. (defn -main [& args]\n  (let [cl (.getContextClassLoader (Thread/currentThread))]\n    (.setContextClassLoader (Thread/currentThread) (clojure.lang.DynamicClassLoader. cl)))\n  ;; other code...\n  )\n When Using kaocha So far, so good. Except when you finish the code and try to test some code and run it under the kaocha test runner. kaocha also did its own thing with ClassLoader and provides a add-classpath method. It breaks the previous method. By detecting kaocha's presence and calling its add-classpath, alongside with the pomegranate one solves the issue for me. (when (find-ns 'kaocha.classpath)\n  ((intern 'kaocha.classpath\n           'add-classpath)\n   new-path))\n A Few More Words This post is definitely not comprehensive, and there are still a lot things I currently do not understand. The method I have described works for me for now. If you want to understand more about this topic, I have listed a few links below. Links Find a way out of the ClassLoader maze (2003) Once Upon a Class The Classpath is a Lie"}, :excerpts [{:text "About Dynamic Adding to Classpath in Clojure", :matched-terms ["clojure"], :source :title} {:text "... to add new directories to classpath and require Clojure files in them at runtime. ClassLoader in Clojure is something very messy. The best strategy...", :matched-terms ["clojure"], :source :content} {:text "... content can offer some help. Use Builtin clojure.core/add-classpath Clojure has a builtin add-classpath function. Although it...", :matched-terms ["clojure"], :source :content}]}]