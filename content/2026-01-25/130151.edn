[{:rule-id "rule-ai", :item {:feed-id "hn", :item-id "https://figshare.com/articles/conference_contribution/Measuring_Fidelity_Decay_A_Framework_for_Semantic_Drift_and_Collapse/30422107?file=58969378", :title "LLMs Don't Hallucinate – They Drift", :link "https://figshare.com/articles/conference_contribution/Measuring_Fidelity_Decay_A_Framework_for_Semantic_Drift_and_Collapse/30422107?file=58969378", :published-at #inst "2026-01-25T12:34:10.000-00:00", :content "Comments"}, :excerpts [{:text "LLMs Don't Hallucinate – They Drift", :matched-terms ["llm"], :source :title}]} {:rule-id "clojure-db", :item {:feed-id "planet-clojure", :item-id "https://avelino.run/chrondb-polyglot-ffi-clojure-graalvm-native-image/", :title "ChronDB: Transforming a Clojure Database into a Polyglot Library with GraalVM Native Image and FFI", :link "https://avelino.run/chrondb-polyglot-ffi-clojure-graalvm-native-image/", :published-at #inst "2026-01-25T00:00:00.000-00:00", :content "ChronDB was born as a server. A time-traveling key/value database with Git as its storage engine, exposing PostgreSQL wire protocol, Redis protocol, and REST/HTTP. You'd download the server, run it, connect with your favorite client. Classic architecture. Then I started building spuff — ephemeral dev environments in the cloud. Spin up when needed, auto-destroy when forgotten. Written in Rust. For state management, I reached for SQLite. Simple, embedded, no server to manage. Just a file."}, :excerpts [{:text "ChronDB: Transforming a Clojure Database into a Polyglot Library with GraalVM...", :matched-terms ["clojure"], :source :title} {:text "... with Git as its storage engine, exposing PostgreSQL wire protocol, Redis protocol, and REST/HTTP....", :matched-terms ["sql"], :source :content} {:text "... when forgotten. Written in Rust. For state management, I reached for SQLite. Simple, embedded, no server to manage. Just a...", :matched-terms ["state" "sql"], :source :content}]}]