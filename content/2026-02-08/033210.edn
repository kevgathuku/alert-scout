[{:rule-id "rule-ai", :item {:feed-id "hn", :item-id "https://github.com/localgpt-app/localgpt", :title "Show HN: LocalGPT – A local-first AI assistant in Rust with persistent memory", :link "https://github.com/localgpt-app/localgpt", :published-at #inst "2026-02-08T01:26:38.000-00:00", :content "Comments"}, :excerpts [{:text "Show HN: LocalGPT – A local-first AI assistant in Rust with...", :matched-terms ["gpt"], :source :title}]} {:rule-id "rule-ai", :item {:feed-id "hn-frontpage", :item-id "https://news.ycombinator.com/item?id=46926043", :title "Speed up responses with fast mode", :link "https://code.claude.com/docs/en/fast-mode", :published-at #inst "2026-02-07T18:08:23.000-00:00", :content "Article URL: https://code.claude.com/docs/en/fast-mode Comments URL: https://news.ycombinator.com/item?id=46926043 Points: 131 # Comments: 139"}, :excerpts [{:text "Article URL: https://code.claude.com/docs/en/fast-mode Comments URL:...", :matched-terms ["claude"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://dev.to/hlship/datastar-observations-3icg", :title "Datastar Observations", :link "https://dev.to/hlship/datastar-observations-3icg", :published-at #inst "2026-02-07T23:35:22.000-00:00", :content "I've been very impressed, so far, with Datastar[https://data-star.dev], a tiny JavaScript library for front-end work; I've been switching a personal side-project from using Svelte for it's UI to Datastar, and as amazing as Svelte is, Datastar has impressed me more. Datastar's essential concept is for the client to shift virtually all logic and all markup rendering back to the server; event handlers can succinctly call server endpoints, which return markup, and the markup is morphed into the running DOM. This makes the server-side is the system of record. Datastar has a nice DSL, based on data-* attributes, allowing you to do nearly anything you need to do in the client, declaratively. Alternately, the server can start an SSE (server sent event) stream and send down markup to morph into the DOM, or JavaScript to execute, over any period of time. For example, my project has a long running process and it was a snap to create a modal progress dialog and keep it updated as the server-side process looped through its inputs. The mantra of Datastar is to trust the morph and the browser -- it's surprisingly fast to update even when sending a fair bit of content. It feels wasteful to update a whole page just to change a few small things (say, mark a button as disabled) but it works, and it's fast, and it frees you from a nearly all client-side reactive updates (and all the related edge cases and unforseen consequences). The server side is not bound to any particular language or framework (they have API implementations for Clojure, Java, Python, Ruby, and many others) ... and you could probably write your own API in an afternoon. I especially like side-stepping the issue of needing more representations of data; the data lives server-side, all that is ever sent to the client is markup. There's no over-the-wire representation, and no parallel client-side data model. All that's ever exposed as endpoints are intentional ones that do work and deliver markup ... in other words, always use-case based, never schema based. There's a minimal amount of reactive logic in the client, but the essence of moving the logic to server feels like home; Tapestry (way back in 2005) had some similar ideas, but was far more limited (due to many factors, including JavaScript and browser maturity in that time). I value simplicity, and Datastar looks to fit my needs without doing so much that is magical or hidden. I consider that a big win!"}, :excerpts [{:text "... with Datastar[https://data-star.dev], a tiny JavaScript library for front-end work; I've been...", :matched-terms ["java"], :source :content} {:text "... and send down markup to morph into the DOM, or JavaScript to execute, over any period of time. For...", :matched-terms ["java"], :source :content} {:text "... or framework (they have API implementations for Clojure, Java, Python, Ruby, and many others) ... and you could...", :matched-terms ["clojure" "java"], :source :content}]}]