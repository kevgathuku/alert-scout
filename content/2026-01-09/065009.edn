[{:rule-id "rule-ai", :item {:feed-id "hn", :item-id "https://github.com/anomalyco/opencode/issues/7410", :title "Anthropic blocks third-party use of Claude Code subscriptions", :link "https://github.com/anomalyco/opencode/issues/7410", :published-at #inst "2026-01-09T03:44:35.000-00:00", :content "<a href=\"https://news.ycombinator.com/item?id=46549823\">Comments</a>"}, :excerpts [{:text "Anthropic blocks third-party use of Claude Code subscriptions", :matched-terms ["claude"], :source :title}]} {:rule-id "rule-ai", :item {:feed-id "hn-frontpage", :item-id "https://news.ycombinator.com/item?id=46549444", :title "Show HN: Executable Markdown files with Unix pipes", :link "https://news.ycombinator.com/item?id=46549444", :published-at #inst "2026-01-09T02:29:12.000-00:00", :content "\n<p>I wanted to run markdown files like shell scripts. So I built an open source tool that lets you use a shebang to pipe them through Claude Code with full stdin/stdout support.<p>task.md:<p><pre><code>    #!/usr/bin/env claude-run\n\n    Analyze this codebase and summarize the architecture.\n</code></pre>\nThen:<p><pre><code>    chmod +x task.md\n\n    ./task.md\n</code></pre>\nThese aren't just prompts. Claude Code has tool use, so a markdown file can run shell commands, write scripts, read files, make API calls. The prompt orchestrates everything.<p>A script that runs your tests and reports results (`run_tests.md`):<p><pre><code>    #!/usr/bin/env claude-run --permission-mode bypassPermissions\n\n    Run ./test/run_tests.sh and summarize what passed and failed.\n</code></pre>\nBecause stdin/stdout work like any Unix program, you can chain them:<p><pre><code>    cat data.json | ./analyze.md > results.txt\n\n    git log -10 | ./summarize.md\n\n    ./generate.md | ./review.md > final.txt\n</code></pre>\nOr mix them with traditional shell scripts:<p><pre><code>    for f in logs/\\*.txt; do\n\n        cat \"$f\" | ./analyze.md >> summary.txt\n\n    done\n</code></pre>\nThis replaced a lot of Python glue code for us. Tasks that needed LLM orchestration libraries are now markdown files composed with standard Unix tools. Composable as building blocks, runnable as cron jobs, etc.<p>One thing we didn't expect is that these are more auditable (and shareable) than shell scripts. Install scripts like `curl -fsSL <a href=\"https://bun.com/install\" rel=\"nofollow\">https://bun.com/install</a> | bash` could become:<p><pre><code>    `curl -fsSL https://bun.com/install.md | claude-run`\n</code></pre>\nWhere install.md says something like \"Detect my OS and architecture, download the right binary from GitHub releases, extract to ~/.local/bin, update my shell config.\" A normal human can actually read and verify that.<p>The (really cool) executable markdown idea and auditability examples are from Pete Koomen (@koomen on X). As Pete says: \"Markdown feels increasingly important in a way I'm not sure most people have wrapped their heads around yet.\"<p>We implemented it and added Unix pipe semantics. Currently works with Claude Code - hoping to support other AI coding tools too. You can also route scripts through different cloud providers (AWS Bedrock, etc.) if you want separate billing for automated jobs.<p>GitHub: <a href=\"https://github.com/andisearch/claude-switcher\" rel=\"nofollow\">https://github.com/andisearch/claude-switcher</a><p>What workflows would you use this for?</p>\n<hr>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46549444\">https://news.ycombinator.com/item?id=46549444</a></p>\n<p>Points: 39</p>\n<p># Comments: 31</p>\n"}, :excerpts [{:text "... that lets you use a shebang to pipe them through Claude Code with full stdin/stdout...", :matched-terms ["claude"], :source :content} {:text "...    #!/usr/bin/env claude-run\n\n    Analyze this codebase and summarize the...", :matched-terms ["claude"], :source :content} {:text "... aren't just prompts. Claude Code has tool use, so a markdown file can run...", :matched-terms ["claude"], :source :content}]}]