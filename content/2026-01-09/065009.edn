[{:rule-id "rule-ai", :item {:feed-id "hn", :item-id "https://github.com/anomalyco/opencode/issues/7410", :title "Anthropic blocks third-party use of Claude Code subscriptions", :link "https://github.com/anomalyco/opencode/issues/7410", :published-at #inst "2026-01-09T03:44:35.000-00:00", :content "Comments"}, :excerpts [{:text "Anthropic blocks third-party use of Claude Code subscriptions", :matched-terms ["claude"], :source :title}]} {:rule-id "rule-ai", :item {:feed-id "hn-frontpage", :item-id "https://news.ycombinator.com/item?id=46549444", :title "Show HN: Executable Markdown files with Unix pipes", :link "https://news.ycombinator.com/item?id=46549444", :published-at #inst "2026-01-09T02:29:12.000-00:00", :content "I wanted to run markdown files like shell scripts. So I built an open source tool that lets you use a shebang to pipe them through Claude Code with full stdin/stdout support. task.md: #!/usr/bin/env claude-run Analyze this codebase and summarize the architecture. Then: chmod +x task.md ./task.md These aren't just prompts. Claude Code has tool use, so a markdown file can run shell commands, write scripts, read files, make API calls. The prompt orchestrates everything. A script that runs your tests and reports results (`run_tests.md`): #!/usr/bin/env claude-run --permission-mode bypassPermissions Run ./test/run_tests.sh and summarize what passed and failed. Because stdin/stdout work like any Unix program, you can chain them: cat data.json | ./analyze.md > results.txt git log -10 | ./summarize.md ./generate.md | ./review.md > final.txt Or mix them with traditional shell scripts: for f in logs/\\*.txt; do cat \"$f\" | ./analyze.md >> summary.txt done This replaced a lot of Python glue code for us. Tasks that needed LLM orchestration libraries are now markdown files composed with standard Unix tools. Composable as building blocks, runnable as cron jobs, etc. One thing we didn't expect is that these are more auditable (and shareable) than shell scripts. Install scripts like `curl -fsSL https://bun.com/install | bash` could become: `curl -fsSL https://bun.com/install.md | claude-run` Where install.md says something like \"Detect my OS and architecture, download the right binary from GitHub releases, extract to ~/.local/bin, update my shell config.\" A normal human can actually read and verify that. The (really cool) executable markdown idea and auditability examples are from Pete Koomen (@koomen on X). As Pete says: \"Markdown feels increasingly important in a way I'm not sure most people have wrapped their heads around yet.\" We implemented it and added Unix pipe semantics. Currently works with Claude Code - hoping to support other AI coding tools too. You can also route scripts through different cloud providers (AWS Bedrock, etc.) if you want separate billing for automated jobs. GitHub: https://github.com/andisearch/claude-switcher What workflows would you use this for? Comments URL: https://news.ycombinator.com/item?id=46549444 Points: 39 # Comments: 31"}, :excerpts [{:text "... that lets you use a shebang to pipe them through Claude Code with full stdin/stdout...", :matched-terms ["claude"], :source :content} {:text "... #!/usr/bin/env claude-run Analyze this codebase and summarize the...", :matched-terms ["claude"], :source :content} {:text "... aren't just prompts. Claude Code has tool use, so a markdown file can run...", :matched-terms ["claude"], :source :content}]}]