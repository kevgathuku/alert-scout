[{:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://tengstrand.github.io/blog/2026-02-17-tetris-playing-ai-the-polylith-way-3.html", :title "Tetris-playing AI the Polylith way - Part 3", :link "https://tengstrand.github.io/blog/2026-02-17-tetris-playing-ai-the-polylith-way-3.html", :published-at #inst "2026-02-17T23:59:59.000-00:00", :content "The focus in this third part of the blog series is to implement an algorithm that computes all valid moves for a piece (Tetromino) in its starting position. We are refining our domain model and improving the readability of parts of the codebase, while continuing to implement the code in Clojure and Python using the component-based Polylith architecture. Earlier parts: Part 1 - Places a piece on a board. Shows the differences between Clojure and Python and creates the piece and board components. Part 2 - Implements clearing of completed rows. Shows how to get fast feedback when working REPL-driven. The resulting source code from this post: The Clojure workspace The Python workspace Tetris Variants Tetris has been made in several different variants, such as the handheld Game Boy, the Nintendo NES console, and this Atari arcade game, which I played an unhealthy amount of in my younger days at a pool hall that no longer exists! Each variant behaves slightly differently when it comes to colours, starting positions, rotation behaviour, and so on. In most Tetris variants, the pieces start in these rotation states (lying flat) before they start falling: Where on the board the pieces start also varies. For instance, on Nintendo NES and Atari Arcade they start in the fifth x-position, while on Game Boy they start in the fourth: In these older versions of Tetris, the pieces rotate only counterclockwise, unlike in some newer games where you can rotate both clockwise and counterclockwise. The following table compares how pieces rotate across the three mentioned variants: On Atari, pieces are oriented toward the top-left corner (except the vertical I), while on the other two they mostly rotate around their centre. In our code, we represent a piece as four [x y] cells: [[0 1] [1 1] [2 1] [1 2]]\n This representation is easy for the code to work with, but poorly communicates the shape of a piece to a human. The main rule is that code should be written to be easy to understand for the people who read and change it (humans and AI agents). Let us therefore define a piece like this instead: (def T0 [&apos---\n         &aposxxx\n         &apos-x-])\n Python: T0 = [\n    \"---\",\n    \"xxx\",\n    \"-x-\"]\n Now we can define all seven pieces and their rotation states for Game Boy (Python code is almost identical): (ns tetrisanalyzer.piece.settings.game-boy\n  (:require [tetrisanalyzer.piece.shape :as shape]))\n\n\n(def O0 [&apos----\n         &apos-xx-\n         &apos-xx-\n         &apos----])\n\n(def I0 [&apos----\n         &apos----\n         &aposxxxx\n         &apos----])\n\n(def I1 [&apos-x--\n         &apos-x--\n         &apos-x--\n         &apos-x--])\n\n(def Z0 [&apos---\n         &aposxx-\n         &apos-xx])\n\n(def Z1 [&apos-x-\n         &aposxx-\n         &aposx--])\n\n(def S0 [&apos---\n         &apos-xx\n         &aposxx-])\n\n(def S1 [&aposx--\n         &aposxx-\n         &apos-x-])\n\n(def J0 [&apos---\n         &aposxxx\n         &apos--x])\n\n(def J1 [&apos-xx\n         &apos-x-\n         &apos-x-])\n\n(def J2 [&aposx--\n         &aposxxx\n         &apos---])\n\n(def J3 [&apos-x-\n         &apos-x-\n         &aposxx-])\n\n(def L0 [&apos---\n         &aposxxx\n         &aposx--])\n\n(def L1 [&apos-x-\n         &apos-x-\n         &apos-xx])\n\n(def L2 [&apos--x\n         &aposxxx\n         &apos---])\n\n(def L3 [&aposxx-\n         &apos-x-\n         &apos-x-])\n\n(def T0 [&apos---\n         &aposxxx\n         &apos-x-])\n\n(def T1 [&apos-x-\n         &apos-xx\n         &apos-x-])\n\n(def T2 [&apos-x-\n         &aposxxx\n         &apos---])\n\n(def T3 [&apos-x-\n         &aposxx-\n         &apos-x-])\n\n(def pieces [[O0]\n             [I0 I1]\n             [Z0 Z1]\n             [S0 S1]\n             [J0 J1 J2 J3]\n             [L0 L1 L2 L3]\n             [T0 T1 T2 T3]])\n\n(def shapes (shape/shapes pieces))\n The shapes function at the end converts the pieces into the format the code uses: [;; O\n [[[1 1] [2 1] [1 2] [2 2]]]\n ;; I\n [[[0 2] [1 2] [2 2] [3 2]]\n  [[1 0] [1 1] [1 2] [1 3]]]\n ;; Z\n [[[0 1] [1 1] [1 2] [2 2]]\n  [[1 0] [0 1] [1 1] [0 2]]]\n ;; S\n [[[1 1] [2 1] [0 2] [1 2]]\n  [[0 0] [0 1] [1 1] [1 2]]]\n ;; J\n [[[0 1] [1 1] [2 1] [2 2]]\n  [[1 0] [2 0] [1 1] [1 2]]\n  [[0 0] [0 1] [1 1] [2 1]]\n  [[1 0] [1 1] [0 2] [1 2]]]\n ;; L\n [[[0 1] [1 1] [2 1] [0 2]]\n  [[1 0] [1 1] [1 2] [2 2]]\n  [[2 0] [0 1] [1 1] [2 1]]\n  [[0 0] [1 0] [1 1] [1 2]]]\n ;; T\n [[[0 1] [1 1] [2 1] [1 2]]\n  [[1 0] [1 1] [2 1] [1 2]]\n  [[1 0] [0 1] [1 1] [2 1]]\n  [[1 0] [0 1] [1 1] [1 2]]]]\n The test for the shape function looks like this: (ns tetrisanalyzer.piece.shape-test\n  (:require [clojure.test :refer :all]\n            [tetrisanalyzer.piece.shape :as shape]))\n\n(deftest converts-a-piece-shape-grid-to-a-vector-of-xy-cells\n  (is (= [[2 0]\n          [1 1]\n          [2 1]\n          [1 2]]\n         (shape/shape [&apos--x-\n                       &apos-xx-\n                       &apos-x--\n                       &apos----]))))\n Python: from tetrisanalyzer.piece.shape import shape\n\n\ndef test_converts_a_piece_shape_grid_to_a_list_of_xy_cells():\n    assert [[2, 0],\n            [1, 1],\n            [2, 1],\n            [1, 2]] == shape([\"--x-\",\n                              \"-xx-\",\n                              \"-x--\",\n                              \"----\"]\n    )\n Implementation in Clojure: (ns tetrisanalyzer.piece.shape)\n\n(defn cell [x character y]\n  (when (= \\x character)\n    [x y]))\n\n(defn row-cells [y row]\n  (keep-indexed #(cell %1 %2 y)\n                (str row)))\n\n(defn shape [piece-grid]\n  (vec (mapcat identity\n               (map-indexed row-cells piece-grid))))\n\n(defn shapes [piece-grids]\n  (mapv #(mapv shape %)\n        piece-grids))\n If you are new to Clojure, here are some explanatory examples of a couple of the functions: (map-indexed vector [\"I\" \"love\" \"Tetris\"])\n\n;; ([0 \"I\"] [1 \"love\"] [2 \"Tetris\"])\n The map-indexed function iterates over \"I\", \"love\", and \"Tetris\", and builds a new list where each element is created by calling vector with the index, which is equivalent to: (list (vector 0 \"I\")\n      (vector 1 \"love\")\n      (vector 2 \"tetris\"))\n\n;; ([0 \"I\"] [1 \"love\"] [2 \"Tetris\"])\n The function keep-indexed works in the same way, but only keeps values that aren&apost nil, hence the use of when: ;; %1 = first argument (index)\n;; %2 = second argument (value)\n(keep-indexed #(when %2 [%1 %2]) \n              [\"I\" nil \"Tetris\"])\n\n;; ([0 \"I\"] [2 \"Tetris\"])\n Implementation in Python: def shape(piece_grid):\n    return [\n        [x, y]\n        for y, row in enumerate(piece_grid)\n        for x, ch in enumerate(row)\n        if ch == \"x\"]\n\ndef shapes(pieces_grids):\n    return [\n        [shape(piece_grid) for piece_grid in piece_grids]\n        for piece_grids in pieces_grids]\n Here we use list comprehension to convert the data into [x, y] cells. The enumerate function is equivalent to Clojureâ€™s map-indexed, in that it adds an index (0, 1, 2, â€¦) to each element. Domain Modelling The new code that calculates the valid moves for a piece in its starting position has to live somewhere. We need to be able to move and rotate a piece, and check whether the target position on the board is free. In object-oriented programming we have several options. We could write piece.set(board), board.set(piece), or maybe move.set(piece, board), while making every effort not to expose the internal representation. In functional programming, we have more freedom and don&apost try to hide how we represent our data. The fact that the board is stored as a two-dimensional vector is no secret, and it isnâ€™t just board that can create updated copies of this two-dimensional vector. Code usually belongs where we expect to find it. We have the function set-piece, which, according to this reasoning, should live in piece, so I moved it from board where I&aposd put it earlier. The new placements function also goes in piece, since it&aposs about finding valid moves for a piece. Our domain model now looks like this: Inside each component we list what belongs to its interface (what&aposs public), and the arrow shows that piece calls functions in board. We split the implementation across the namespaces move, placement, and visit, which we put in the move package: â–¾ tetris-polylith\n  â–¸ bases\n  â–¾ components\n    â–¸ board\n    â–¾ piece\n      â–¾ src\n        â–¸ settings\n        â–¾ move\n          move.clj\n          placement.clj\n          visit.clj\n        bitmask.clj\n        interface.clj\n        piece.clj\n        shape.clj\n      â–¾ test\n        â–¾ move\n          move_test.clj\n          placement_test.clj\n          visit_test.clj\n        piece_test.clj\n        shape_test.clj\n  â–¸ development\n  â–¸ projects\n The move-test looks like this: (ns tetrisanalyzer.piece.move.move-test\n  (:require [clojure.test :refer :all]\n            [tetrisanalyzer.piece.piece :as piece]\n            [tetrisanalyzer.piece.move.move :as move]\n            [tetrisanalyzer.piece.bitmask :as bitmask]\n            [tetrisanalyzer.board.interface :as board]\n            [tetrisanalyzer.piece.settings.atari-arcade :as atari-arcade]))\n\n(def x 2)\n(def y 1)\n(def rotation 0)\n(def S piece/S)\n(def shapes atari-arcade/shapes)\n(def bitmask (bitmask/rotation-bitmask shapes S))\n(def piece (piece/piece S rotation shapes))\n\n(def board (board/board [&aposxxxxxxxx\n                         &aposxxx--xxx\n                         &aposxx--xxxx\n                         &aposxxxxxxxx]))\n\n(deftest valid-move\n  (is (= true\n         (move/valid-move? board x y S rotation shapes))))\n\n(deftest valid-left-move\n  (is (= [2 1 0]\n         (move/left board (inc x) y S rotation nil shapes))))\n\n(deftest invalid-left-move\n  (is (= nil\n         (move/left board x y S rotation nil shapes))))\n\n(deftest valid-right-move\n  (is (= [2 1 0]\n         (move/right board (dec x) y S rotation nil shapes))))\n\n(deftest invalid-right-move\n  (is (= nil\n         (move/right board x (dec y) S rotation nil shapes))))\n\n(deftest unoccupied-down-move\n  (is (= [[2 1 0] nil]\n         (move/down board x (dec y) S rotation nil shapes))))\n\n(deftest down-move-hits-ground\n  (is (= [nil [[2 1 0]]]\n         (move/down board x y S rotation nil shapes))))\n\n(deftest valid-rotation\n  (is (= [2 1 0]\n         (move/rotate board x y S (dec rotation) bitmask shapes))))\n\n(deftest invalid-rotation-without-kick\n  (is (= nil\n         (move/rotate board (inc x) y S (inc rotation) bitmask shapes))))\n\n(deftest valid-rotation-with-kick\n  (is (= [2 1 0]\n         (move/rotate-with-kick board (inc x) y S (inc rotation) bitmask shapes))))\n\n(deftest invalid-move-outside-board\n  (is (= false\n         (move/valid-move? board 10 -10 S rotation shapes))))\n The first test, valid-move, checks that the S piece: [&apos-xx\n &aposxx-]\n Can be placed at position x=2, y=1, on the board: [&aposxxxxxxxx\n &aposxxx--xxx\n &aposxx--xxxx\n &aposxxxxxxxx]\n Beyond that, we test various valid moves and rotations into the empty area, plus invalid moves outside the board. In Tetris there&aposs something called kick, or wall kick. When you rotate a piece and that position is occupied on the board, one step left is also tried (x-1). On Nintendo NES this is turned off, while it&aposs enabled in the other two variants we support here. In newer Tetris games, other placements besides x-1 are sometimes tested as well. The implementation looks like this: (ns tetrisanalyzer.piece.move.move\n  (:require [tetrisanalyzer.piece.piece :as piece]))\n\n(defn cell [board x y [cx cy]]\n  (or (get-in board [(+ y cy) (+ x cx)])\n      piece/X))\n\n(defn valid-move? [board x y p rotation shapes]\n  (every? zero?\n          (map #(cell board x y %)\n               (piece/piece p rotation shapes))))\n\n(defn left [board x y p rotation _ shapes]\n  (when (valid-move? board (dec x) y p rotation shapes)\n    [(dec x) y rotation]))\n\n(defn right [board x y p rotation _ shapes]\n  (when (valid-move? board (inc x) y p rotation shapes)\n    [(inc x) y rotation]))\n\n(defn down\n  \"Returns [down-move placement] where:\n   - down-move: next move when moving down or nil if blocked\n   - placement: final placement if blocked, or nil if can move down\"\n  [board x y p rotation _ shapes]\n  (if (valid-move? board x (inc y) p rotation shapes)\n    [[x (inc y) rotation] nil]\n    [nil [[x y rotation]]]))\n\n(defn rotate [board x y p rotation bitmask shapes]\n  (let [new-rotation (bit-and (inc rotation) bitmask)]\n    (when (valid-move? board x y p new-rotation shapes)\n      [x y new-rotation])))\n\n(defn rotate-with-kick [board x y p rotation bitmask shapes]\n  (or (rotate board x y p rotation bitmask shapes)\n      (rotate board (dec x) y p rotation bitmask shapes)))\n\n(defn rotation-fn [rotation-kick?]\n  (if rotation-kick?\n    rotate-with-kick\n    rotate))\n The functions are fairly straightforward, so let us instead look at the code that helps us keep track of which moves have already been visited: (ns tetrisanalyzer.piece.move.visit)\n\n(defn visited? [visited-moves x y rotation]\n  (if-let [visited-rotations (get-in visited-moves [y x])]\n    (not (zero? (bit-and visited-rotations\n                         (bit-shift-left 1 rotation))))\n    true)) ;; Cells outside the board are treated as visited\n\n(defn visit [visited-moves x y rotation]\n  (assoc-in visited-moves [y x] (bit-or (get-in visited-moves [y x])\n                                        (bit-shift-left 1 rotation))))\n Calling the standard bit-shift-left function returns a set bit in one of the four lowest bits: rotation bit 0 0001 1 0010 2 0100 3 1000 These \"flags\" are used to mark that we&aposve visited a given [x y rotation] move on the board. Note that we pass a \"visited board\" (visited-moves) into visit and get back a copy where the [x y] cell has a bit set for the given rotation. This â€œcopyingâ€ is very fast and memory-efficient, see â€œstructural sharingâ€ under Data Structures. The tests look like the following: (ns tetrisanalyzer.piece.move.visit-test\n  (:require [clojure.test :refer :all]\n            [tetrisanalyzer.piece.move.visit :as visit]))\n\n(def x 2)\n(def y 1)\n(def rotation 3)\n(def unvisited [[0 0 0 0]\n                [0 0 0 0]])\n\n(deftest move-is-not-visited\n  (is (= false\n         (visit/visited? unvisited x y rotation))))\n\n(deftest move-is-visited\n  (let [visited (visit/visit unvisited x y rotation)]\n    (is (= true\n           (visit/visited? visited x y rotation)))))\n Python: from tetrisanalyzer.piece.move.visit import is_visited, visit\n\nX = 2\nY = 1\nROTATION = 3\nUNVISITED = [\n    [0, 0, 0, 0],\n    [0, 0, 0, 0]]\n\n\ndef test_move_is_not_visited():\n    assert is_visited(UNVISITED, X, Y, ROTATION) is False\n\n\ndef test_move_is_visited():\n    visited = [row[:] for row in UNVISITED]\n    visit(visited, X, Y, ROTATION)\n    assert is_visited(visited, X, Y, ROTATION) is True\n We have now laid the groundwork to implement the placements function that computes all valid moves for a piece in its starting position. We start with the test: (ns tetrisanalyzer.piece.move.placement-test\n  (:require [clojure.test :refer :all]\n            [tetrisanalyzer.piece.piece :as piece]\n            [tetrisanalyzer.piece.move.placement :as placement]\n            [tetrisanalyzer.piece.settings.atari-arcade :as atari-arcade]))\n\n(def start-x 2)\n(def sorter (juxt second first last))\n\n(def board [[0 0 0 0 0 0]\n            [0 0 1 1 0 0]\n            [0 0 1 0 0 1]\n            [0 0 1 1 1 1]])\n\n(def shapes atari-arcade/shapes)\n\n;; Start position of the J piece:\n;; --JJJ-\n;; --xxJ-\n;; --x--x\n;; --xxxx\n(deftest placements--without-rotation-kick\n  (is (= [[2 0 0]\n          [3 0 0]]\n         (sort-by sorter (placement/placements board piece/J start-x false shapes)))))\n\n;; With rotation kick, checking if x-1 fits:\n;; -JJ---\n;; -Jxx--\n;; -Jx--x\n;; --xxxx\n(deftest placements--with-rotation-kick\n  (is (= [[1 0 1]\n          [2 0 0]\n          [3 0 0]\n          [0 1 1]]\n         (sort-by sorter (placement/placements board piece/J start-x true shapes)))))\n This tests that we get back the valid [x y rotation] positions where a piece can be placed on the board from its starting position. The implementation: (ns tetrisanalyzer.piece.move.placement\n  (:require [tetrisanalyzer.piece.move.move :as move]\n            [tetrisanalyzer.piece.move.visit :as visit]\n            [tetrisanalyzer.board.interface :as board]\n            [tetrisanalyzer.piece.bitmask :as bitmask]))\n\n(defn ->placements [board x y p rotation bitmask valid-moves visited-moves rotation-fn shapes]\n  (loop [next-moves (list [x y rotation])\n         placements []\n         valid-moves valid-moves\n         visited-moves visited-moves]\n    (if-let [[x y rotation] (first next-moves)]\n      (let [next-moves (rest next-moves)]\n        (if (visit/visited? visited-moves x y rotation)\n          (recur next-moves placements valid-moves visited-moves)\n          (let [[down placement] (move/down board x y p rotation bitmask shapes)\n                moves (keep #(% board x y p rotation bitmask shapes)\n                            [move/left\n                             move/right\n                             rotation-fn\n                             (constantly down)])]\n            (recur (into next-moves moves)\n                   (concat placements placement)\n                   (conj valid-moves [x y rotation])\n                   (visit/visit visited-moves x y rotation)))))\n      placements)))\n\n(defn placements [board p x kick? shapes]\n  (let [y 0\n        rotation 0\n        bitmask (bitmask/rotation-bitmask shapes p)\n        visited-moves (board/empty-board board)\n        rotation-fn (move/rotation-fn kick?)]\n    (if (move/valid-move? board x y p rotation shapes)\n      (->placements board x y p rotation bitmask [] visited-moves rotation-fn shapes)\n      [])))\n Let us walk through the following section in ->placements: (loop [next-moves (list [x y rotation])\n       placements []\n       valid-moves valid-moves\n       visited-moves visited-moves]\n These four lines initialise the data we&aposre looping over: next-moves is the list of moves we need to process (it grows and shrinks as we go), and placements accumulates valid moves. Since Clojure doesnâ€™t support tail recursion, we use loop instead, to avoid stack overflow on boards larger than 10Ã—20. (if-let [[x y rotation] (first next-moves)]\n Retrieves the next move from next-moves and continues with the code immediately after, or returns placements (the last line in the function, representing all valid moves) if next-moves is empty. (let [next-moves (rest next-moves)]\n Drops the first element from next-moves, the one we just picked. (if (visit/visited? visited-moves x y rotation)\n If we&aposve already visited this move, continue with: (recur next-moves placements valid-moves visited-moves)\n Which continues our search for valid moves (the line after (loop [...]) by moving on to the next move to evaluate. Otherwise, if the move hasn&apost been visited, we do: (let [[down placement] (move/down board x y p rotation bitmask shapes)\n     ...]\n This sets down to the next downward move (if free) or placement if we can&apost move down, which happens when we hit the bottom or when part of the \"stack\" is in the way. For these lines: (keep #(% board x y p rotation bitmask shapes)\n      [move/left\n       move/right\n       rotation-fn\n       (constantly down)])\n The % gets replaced with each function in the vector, which is equivalent to: [(move/left board x y p rotation bitmask shapes)\n (move/right board x y p rotation bitmask shapes)\n (rotation-fn board x y p rotation bitmask shapes)\n (down board x y p rotation bitmask shapes)]\n These function calls generate all possible moves (including rotations), returning [x y rotation] for positions that are free on the board, or nil if occupied. The keep function filters out nil values, leaving only valid moves in moves. Finally we execute: (recur (into next-moves moves)\n       (concat placements placement)\n       (conj valid-moves [x y rotation])\n       (visit/visit visited-moves x y rotation))\n Which calls loop again with: next-moves updated with any new moves placements updated with any valid placement valid-moves updated with the current move visited-moves with the current move marked as visited This keeps going until next-moves is empty, and then we return placements. The function that kicks everything off and returns valid moves for a piece in its starting position: (defn placements [board p x kick? shapes]\n  (let [y 0\n        rotation 0\n        bitmask (bitmask/rotation-bitmask shapes p)\n        visited-moves (board/empty-board board)\n        rotation-fn (move/rotation-fn kick?)]\n    (if (move/valid-move? board x y p rotation shapes)\n      (->placements board x y p rotation bitmask [] visited-moves rotation-fn shapes)\n      [])))\n board: a two-dimensional vector representing the board, usually 10x20. p: piece index (0, 1, 2, 3, 4, 5, or 6). x: which column the 4x4 grid starts in (where the piece sits). First column is 0. y: set to 0 (top row for the 4x4 grid). rotation: set to 0 (starting rotation). bitmask: used when iterating over rotations so that it wraps back to 0 after reaching the maximum number of rotations it can perform. visited-moves: has the same structure as a board, a two-dimensional array, usually 10x20. rotation-fn: returns the right rotation function depending on whether kick is enabled. Also tries position x-1 if kick? is true. shapes: the shapes for all pieces and their rotation states, stored as [x y] cells. (if (move/valid-move? board x y p rotation shapes): we need to check whether the initial position is free; if not, return an empty vector. (->placements board x y p rotation bitmask [] visited-moves rotation-fn shapes) computes the valid moves. Implementation in Python: from collections import deque\n\nfrom tetrisanalyzer import board as board_ifc\nfrom tetrisanalyzer.piece import piece\nfrom tetrisanalyzer.piece.bitmask import rotation_bitmask\nfrom tetrisanalyzer.piece.move import move\nfrom tetrisanalyzer.piece.move import visit\n\ndef _placements(board, x, y, p, rotation, bitmask, valid_moves, visited_moves, rotation_move_fn, shapes):\n    next_moves = deque([[x, y, rotation]])\n    valid_placements = []\n\n    while next_moves:\n        x, y, rotation = next_moves.popleft()\n\n        if visit.is_visited(visited_moves, x, y, rotation):\n            continue\n\n        down_move, placement = move.down(board, x, y, p, rotation, bitmask, shapes)\n\n        moves = [\n            move.left(board, x, y, p, rotation, bitmask, shapes),\n            move.right(board, x, y, p, rotation, bitmask, shapes),\n            rotation_move_fn(board, x, y, p, rotation, bitmask, shapes),\n            down_move]\n\n        moves = [m for m in moves if m is not None]\n\n        next_moves.extend(moves)\n\n        if placement is not None:\n            valid_placements.extend(placement)\n\n        valid_moves.append([x, y, rotation])\n        visit.visit(visited_moves, x, y, rotation)\n\n    return valid_placements\n\n\ndef placements(board, p, start_x, kick, shapes):\n    y = 0\n    rotation = 0\n    bitmask = rotation_bitmask(shapes, p)\n    visited_moves = board_ifc.empty_board(board_ifc.width(board), board_ifc.height(board))\n    rotation_move_fn = move.rotation_fn(kick)\n\n    if not move.is_valid_move(board, start_x, y, p, rotation, shapes):\n        return []\n\n    return _placements(board, start_x, y, p, rotation, bitmask, [], visited_moves, rotation_move_fn, shapes)\n The code follows the same algorithm as in Clojure. We use deque because it&aposs slightly faster than a list when performing both popleft and extend. Testing Finally, we run our tests: $> cd ~/source/tetrisanalyzer/langs/clojure/tetris-polylith\n$> poly test :dev\nProjects to run tests from: development\n\nRunning tests for the development project using test runner: Polylith built-in clojure.test runner...\nRunning tests from the development project, including 2 bricks: board, piece\n\nTesting tetrisanalyzer.board.core-test\n\nRan 1 tests containing 1 assertions.\n0 failures, 0 errors.\n\nTest results: 1 passes, 0 failures, 0 errors.\n\nTesting tetrisanalyzer.board.clear-rows-test\n\nRan 1 tests containing 1 assertions.\n0 failures, 0 errors.\n\nTest results: 1 passes, 0 failures, 0 errors.\n\nTesting tetrisanalyzer.board.grid-test\n\nRan 2 tests containing 2 assertions.\n0 failures, 0 errors.\n\nTest results: 2 passes, 0 failures, 0 errors.\n\nTesting tetrisanalyzer.piece.shape-test\n\nRan 1 tests containing 1 assertions.\n0 failures, 0 errors.\n\nTest results: 1 passes, 0 failures, 0 errors.\n\nTesting tetrisanalyzer.piece.move.placement-test\n\nRan 2 tests containing 2 assertions.\n0 failures, 0 errors.\n\nTest results: 2 passes, 0 failures, 0 errors.\n\nTesting tetrisanalyzer.piece.move.move-test\n\nRan 11 tests containing 11 assertions.\n0 failures, 0 errors.\n\nTest results: 11 passes, 0 failures, 0 errors.\n\nTesting tetrisanalyzer.piece.move.visit-test\n\nRan 2 tests containing 2 assertions.\n0 failures, 0 errors.\n\nTest results: 2 passes, 0 failures, 0 errors.\n\nTesting tetrisanalyzer.piece.piece-test\n\nRan 1 tests containing 1 assertions.\n0 failures, 0 errors.\n\nTest results: 1 passes, 0 failures, 0 errors.\n\nExecution time: 0 seconds\n Python: $> cd ~/source/tetrisanalyzer/langs/python/tetris-polylith-uv\n$> uv run pytest\n======================================================================================================= test session starts ========================================================================================================\nplatform darwin -- Python 3.13.11, pytest-9.0.2, pluggy-1.6.0\nrootdir: /Users/tengstrand/source/tetrisanalyzer/langs/python/tetris-polylith-uv\nconfigfile: pyproject.toml\ncollected 21 items\n\ntest/components/tetrisanalyzer/board/test_clear_rows.py .                                                                                                                                                                    [  4%]\ntest/components/tetrisanalyzer/board/test_core.py ..                                                                                                                                                                         [ 14%]\ntest/components/tetrisanalyzer/board/test_grid.py ..                                                                                                                                                                         [ 23%]\ntest/components/tetrisanalyzer/piece/move/test_move.py ...........                                                                                                                                                           [ 76%]\ntest/components/tetrisanalyzer/piece/move/test_placement.py ..                                                                                                                                                               [ 85%]\ntest/components/tetrisanalyzer/piece/move/test_visit.py ..                                                                                                                                                                   [ 95%]\ntest/components/tetrisanalyzer/piece/test_shape.py .                                                                                                                                                                         [100%]\n\n======================================================================================================== 21 passed in 0.02s ========================================================================================================\n Nice, all tests passed! Summary In this third post, I took on the not entirely trivial task of computing all valid moves for a piece in its starting position. I avoided implementing it as a recursive algorithm, since that would limit how large our boards can get. We reminded ourselves that code should live where we expect to find it. We also took the opportunity to make the code easier to work with, by specifying pieces in a more readable way, and with that change we could easily support three different Tetris variants. Hope you had just as much fun as I did ðŸ˜ƒ Happy Coding!"}, :excerpts [{:text "... while continuing to implement the code in Clojure and Python using the component-based Polylith...", :matched-terms ["clojure"], :source :content} {:text "... piece on a board. Shows the differences between Clojure and Python and creates the piece and board...", :matched-terms ["clojure"], :source :content} {:text "... Shows how to get fast feedback when working REPL-driven. The resulting source code from this post: The Clojure workspace The Python workspace Tetris Variants...", :matched-terms ["repl" "clojure"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://blog.michielborkent.nl/babashka-1.12.215.html", :title "Babashka 1.12.215: Revenge of the TUIs", :link "https://blog.michielborkent.nl/babashka-1.12.215.html", :published-at #inst "2026-02-17T23:59:59.000-00:00", :content "Babashka is a fast-starting native Clojure scripting runtime. It uses SCI to interpret Clojure and compiles to a native binary via GraalVM, giving you Clojure&aposs power with near-instant startup. It&aposs commonly used for shell scripting, build tooling, and small CLI applications. If you don&apost yet have bb installed, you can with brew: brew install borkdude/brew/babashka\n or bash: bash <(curl -s https://raw.githubusercontent.com/babashka/babashka/master/install)\n This release is, in my opinion, a game changer. With JLine3 bundled, you can now build full terminal user interfaces in babashka. The bb repl has been completely overhauled with multi-line editing, completions, and eldoc. deftype now supports map interfaces, making bb more compatible with existing libraries like core.cache. SCI has had many small improvements, making riddley compatible too. Riddley is used in Cloverage, a code coverage library for Clojure, which now also works with babashka (Cloverage PR pending). Babashka conf 2026 But first, let me mention an exciting upcoming event! Babashka conf is happening again for the second time! The first time was 2023 in Berlin. This time it&aposs in Amsterdam. The Call for Proposals is open until the end of February, so there is still time to submit your talk or workshop. We are also looking for one last gold sponsor (500 euros) to cover all costs. Highlights JLine3 and TUI support Babashka now bundles JLine3, a Java library for building interactive terminal applications. You get terminals, line readers with history and tab completion, styled output, keyboard bindings, and the ability to reify custom completers, parsers, and widgets â€” all from bb scripts. JLine3 works on all platforms, including Windows PowerShell and cmd.exe. Here&aposs a simple interactive prompt that reads lines from the user until EOF (Ctrl+D): (import &apos[org.jline.terminal TerminalBuilder]\n        &apos[org.jline.reader LineReaderBuilder])\n\n(let [terminal (-> (TerminalBuilder/builder) (.build))\n      reader   (-> (LineReaderBuilder/builder)\n                   (.terminal terminal)\n                   (.build))]\n  (try\n    (loop []\n      (when-let [line (.readLine reader \"prompt> \")]\n        (println \"You typed:\" line)\n        (recur)))\n    (catch org.jline.reader.EndOfFileException _\n      (println \"Goodbye!\"))\n    (finally\n      (.close terminal))))\n babashka.terminal namespace A new babashka.terminal namespace exposes a tty? function to detect whether stdin, stdout, or stderr is connected to a terminal: (require &apos[babashka.terminal :refer [tty?]])\n\n(when (tty? :stdout)\n  (println \"Interactive terminal detected, enabling colors\"))\n This accepts :stdin, :stdout, or :stderr as argument. It uses JLine3&aposs terminal provider under the hood. This is useful for scripts that want to behave differently when piped vs. run interactively, for example enabling colored output or progress bars only in a terminal. charm.clj compatibility charm.clj is a new Clojure library for building terminal user interfaces using the Elm architecture (Model-Update-View). It provides components like spinners, text inputs, lists, paginators, and progress bars, with support for ANSI/256/true color styling and keyboard/mouse input handling. charm.clj is now compatible with babashka (or rather, babashka is now compatible with charm.clj), enabled by the combination of JLine3 support and other interpreter improvements in this release. This means you can build rich TUI applications that start instantly as native binaries. Here&aposs a complete counter example you can save as a single file and run with bb: #!/usr/bin/env bb\n\n(babashka.deps/add-deps\n &apos{:deps {io.github.TimoKramer/charm.clj {:git/sha \"cf7a6c2fcfcccc44fcf04996e264183aa49a70d6\"}}})\n\n(require &apos[charm.core :as charm])\n\n(def title-style\n  (charm/style :fg charm/magenta :bold true))\n\n(def count-style\n  (charm/style :fg charm/cyan\n               :padding [0 1]\n               :border charm/rounded-border))\n\n(defn update-fn [state msg]\n  (cond\n    (or (charm/key-match? msg \"q\")\n        (charm/key-match? msg \"ctrl+c\"))\n    [state charm/quit-cmd]\n\n    (or (charm/key-match? msg \"k\")\n        (charm/key-match? msg :up))\n    [(update state :count inc) nil]\n\n    (or (charm/key-match? msg \"j\")\n        (charm/key-match? msg :down))\n    [(update state :count dec) nil]\n\n    :else\n    [state nil]))\n\n(defn view [state]\n  (str (charm/render title-style \"Counter App\") \"\\n\\n\"\n       (charm/render count-style (str (:count state))) \"\\n\\n\"\n       \"j/k or arrows to change\\n\"\n       \"q to quit\"))\n\n(charm/run {:init {:count 0}\n            :update update-fn\n            :view view\n            :alt-screen true})\n Deftype with map interfaces Until now, deftype in babashka couldn&apost implement JVM interfaces like IPersistentMap, ILookup, or Associative. This meant libraries that define custom map-like types, a very common Clojure pattern, couldn&apost work in babashka. Starting with this release, deftype supports map interfaces. Your deftype must declare IPersistentMap to signal that you want a full map type. Other map-related interfaces like ILookup, Associative, Counted, Seqable, and Iterable are accepted freely since the underlying class already implements them. This unlocks several libraries that were previously incompatible: core.cache: all cache types (BasicCache, FIFOCache, LRUCache, TTLCache, LUCache) work unmodified linked: insertion-ordered maps and sets Riddley and Cloverage compatibility Riddley is a Clojure library for code walking that many other libraries depend on. Previously, SCI&aposs deftype and case did not macroexpand to the same special forms as JVM Clojure, which broke riddley&aposs walker. Several changes now align SCI&aposs behavior with Clojure: deftype macroexpands to deftype*, case to case*, and macroexpand-1 now accepts an optional env map as second argument (inspired by how the CLJS analyzer API works). Together these changes enable riddley and tools built on it, like cloverage and Specter, to work with bb. Riddley has moved to clj-commons, thanks to Zach Tellman for transferring it. I&aposd like to thank Zach for all his contributions to the Clojure community over the years. Version 0.2.2 includes bb compatibility, which was one of the first PRs merged after the transfer. Cloverage compatibility has been submitted upstream, all 75 cloverage tests pass on both JVM and babashka. Console REPL improvements The bb repl experience has been significantly improved with JLine3 integration. You no longer need rlwrap to get a comfortable console REPL: Multi-line editing: the REPL detects incomplete forms and continues reading on the next line with a #_=> continuation prompt Tab completion: Clojure-aware completions powered by SCI, including keywords (:foo, ::foo, ::alias/foo) Ghost text: as you type, the common completion prefix appears as faint inline text after the cursor. Press TAB to accept. Eldoc: automatic argument help â€” when your cursor is inside a function call like (map |), the arglists are displayed below the prompt Doc-at-point: press Ctrl+X Ctrl+D to show full documentation for the symbol at the cursor Persistent history: command history saved across sessions in ~/.bb_repl_history Ctrl+C handling: first press on an empty prompt warns, second press exits Many of these features were inspired by rebel-readline, Leiningen&aposs REPL, and Node.js&aposs REPL. SCI improvements Under the hood, SCI (the interpreter powering babashka) received many improvements in this cycle: Functional interface adaptation for instance targets: you can now write (let [^Predicate p even?] (.test p 42)) and SCI will adapt the Clojure function to the functional interface automatically. Type tag inference: SCI now infers type tags from let binding values to binding names, reducing the need for explicit type hints in interop-heavy code. Several bug fixes: read with nil/false as eof-value, letfn with duplicate function names, ns-map not reflecting shadowed vars, NPE in resolve, and .method on class objects routing incorrectly. Other improvements Support multiple catch clauses in combination with ^:sci/error Fix satisfies? on protocols with proxy Support reify with java.time.temporal.TemporalQuery Fix reify with methods returning int/short/byte/float primitives nREPL server now uses non-daemon threads so the process stays alive without @(promise) Add clojure.test.junit as built-in source namespace Add cp437 (IBM437) charset support in native binary via selective GraalVM charset Feature, avoiding the ~5MB binary size increase from AddAllCharsets. More charsets can be added on request. For the full list of changes including new Java classes and library bumps, see the changelog. Thanks Thank you to all the contributors who helped make this release possible. Special thanks to everyone who reported issues, tested pre-release builds from babashka-dev-builds, and provided feedback. Thanks to Clojurists Together and all babashka sponsors and contributors for their ongoing support. Your sponsorship makes it possible to keep developing babashka. And thanks to all babashka users: you make this project what it is. Happy scripting!"}, :excerpts [{:text "Babashka is a fast-starting native Clojure scripting runtime. It uses SCI to interpret Clojure and compiles to a native binary via GraalVM, giving you Clojure&aposs power with near-instant startup. It&aposs...", :matched-terms ["clojure"], :source :content} {:text "... terminal user interfaces in babashka. The bb repl has been completely overhauled with multi-line...", :matched-terms ["repl"], :source :content} {:text "... used in Cloverage, a code coverage library for Clojure, which now also works with babashka (Cloverage PR...", :matched-terms ["clojure"], :source :content}]}]