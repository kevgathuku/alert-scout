[{:rule-id "rails-deploy", :item {:feed-id "planet-clojure", :item-id "https://flexiana.com/?p=17858", :title "Building web services with Duct", :link "https://flexiana.com/news/2026/01/building-web-services-with-duct-1-part-2", :published-at #inst "2026-01-20T16:39:36.000-00:00", :content "<blockquote class=\"wp-block-quote is-layout-flow wp-block-quote-is-layout-flow\">\n<p>This article describes how to build a web service based on Clojure and the Duct framework. It covers all the necessary details of every part of Duct needed for this task. On completion, the reader should be able to write a web service from scratch with tests, configurations, and components calling 3rd party services.</p>\n\n\n\n<p>The article is for intermediate programmers with a basic knowledge of web services and Clojure.</p>\n</blockquote>\n\n\n\n<p>Clojure is a really different programming language compared to conventional languages like Java, Kotlin, Javascript, or functional languages like F#. The very first thing that everybody spots are its parenthesized prefix notation. The notation may look odd, but it has a lot of advantages compared to C-like syntax:</p>\n\n\n\n<ul class=\"wp-block-list\">\n<li>Compact syntax </li>\n\n\n\n<li>Simple syntax parser and highlighter</li>\n\n\n\n<li>No priority of operators struggle</li>\n\n\n\n<li>No breaking changes for new versions, due to new keyword/core function</li>\n\n\n\n<li>Easy to read any code, <em>everything</em> is a function</li>\n</ul>\n\n\n\n<p>The second special thing about Clojure’s environment is that there is no standard framework like Django, Ruby On Rails, Spring in other languages. Clojure lets a programmer compose a framework from small libraries. I guess that this decision is based on the idea that there is no one hammer for all problems. This comes with a lot of consequences.</p>\n\n\n\n<h3 class=\"wp-block-heading\">Pros</h3>\n\n\n\n<ul class=\"wp-block-list\">\n<li>A perfectly tailored framework to fit the problem.</li>\n\n\n\n<li>No limitation to replace marshalling, HTTP, DB, routing and other libraries.</li>\n\n\n\n<li>No overweight framework, only the parts used are in a project.</li>\n\n\n\n<li>Great for microservices.</li>\n</ul>\n\n\n\n<h3 class=\"wp-block-heading\">Cons</h3>\n\n\n\n<ul class=\"wp-block-list\">\n<li>Hard at the beginning, experience with libraries needed.</li>\n\n\n\n<li>Very hard for beginners without architecture skills.</li>\n\n\n\n<li>Boilerplate code.</li>\n\n\n\n<li>No scaffolding (like in Ruby On Rails)</li>\n</ul>\n\n\n\n<p>This post is about <a href=\"https://github.com/duct-framework/duct\" rel=\"noreferrer noopener\" target=\"_blank\">Duct</a>. The framework is light and composed from other (well-known in the Clojure world) small libraries (as is almost everything in Clojure). These are the main parts that are covered by Duct:</p>\n\n\n\n<ul class=\"wp-block-list\">\n<li>Configuration – local, production env., env. variables, …</li>\n\n\n\n<li>HTTP handler with an application server</li>\n\n\n\n<li>Database layer – a connection poll</li>\n\n\n\n<li>Prepared middlewares for common security, HTTP headers, Content negotiation, …</li>\n\n\n\n<li>Logging</li>\n\n\n\n<li>Error handling</li>\n\n\n\n<li>REPL – a code hot-swap</li>\n</ul>\n\n\n\n<h2 class=\"wp-block-heading\">Architecture</h2>\n\n\n\n<h3 class=\"wp-block-heading\">The code</h3>\n\n\n\n<p>Let’s create a new project where we can see how to do general stuff with Duct. We are going to create a service for sending SMS messages.</p>\n\n\n\n<p>We start by creating a project structure from Leiningen template by calling:</p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_861b3e3267076964c3f7933c68af05d8\">\n    <pre><code class=\"language-clojure\">lein new duct sms +api +examplern[lukas@hel:~/dev/flexiana]$ lein new duct sms +api +examplernGenerating a new Duct project named sms...rnRun 'lein duct setup' in the project directory to create local config files.rn[lukas@hel:~/dev/flexiana]$</code></pre>\n</div>\n\n\n<p>Let’s describe the command and what was created:</p>\n\n\n\n<ul class=\"wp-block-list\">\n<li><strong>lein new</strong> generates a new Clojure project with Leiningen template</li>\n\n\n\n<li><strong>duct</strong> is a name of a template</li>\n\n\n\n<li><strong>sms</strong> is a name of a new project</li>\n\n\n\n<li><strong>+api</strong> is an option that adds middleware for APIs</li>\n\n\n\n<li><strong>+example</strong> is an option that adds some  example code</li>\n</ul>\n\n\n\n<p>You can find more options in Duct’s README file <a href=\"https://github.com/duct-framework/duct#quick-start\" rel=\"noreferrer noopener\" target=\"_blank\">https://github.com/duct-framework/duct#quick-start</a></p>\n\n\n\n<p>Leiningen created a folder called sms. As we can see in the result above, the command</p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_f72785eebca909a7de36bfba26a78eeb\">\n    <pre><code class=\"language-clojure\">lein duct setup</code></pre>\n</div>\n\n\n<p>will create configuration files for a local development and these files should not be watched by a version control system. The command prints out what files have been created:</p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_60daa16e3226e8887e1321b9771ba93b\">\n    <pre><code class=\"language-clojure\">[lukas@hel:~/dev/flexiana/sms]$ lein duct setuprnCreated profiles.cljrnCreated .dir-locals.elrnCreated dev/resources/local.ednrnCreated dev/src/local.cljrn[lukas@hel:~/dev/flexiana/sms]$</code></pre>\n</div>\n\n\n<p>The template also generates the .gitignore file so you don’t have to alter the file manually.</p>\n\n\n\n<h2 class=\"wp-block-heading\">The project structure</h2>\n\n\n\n<p>Leiningen generated a project from a template, let’s describe a project structure.</p>\n\n\n\n<ul class=\"wp-block-list\">\n<li>README.md: This is the obvious one, this file describes a project, contains installation and other useful notes.</li>\n\n\n\n<li>dev: This folder contains files only for development mode. These files will not be part of a production JAR. It contains a configuration for the development and local environment (dev/resources/local.edn)</li>\n\n\n\n<li>profiles.clj: Allows to override profiles.</li>\n\n\n\n<li>project.clj: This is an important one. It contains project dependencies and plugins, build profiles, etc.</li>\n\n\n\n<li>resources: contains static files like: project configuration, images, Javascripts, CSS, SQL, etc. These files will be a part of the production JAR.</li>\n\n\n\n<li>src: contains all files that would be compiled: clj, cljc, cljs, cljx or java files</li>\n\n\n\n<li>test: All the tests. These files will not be part of the production JAR.</li>\n</ul>\n\n\n\n<p>We should be able to run the project as it is right now, because we passed +example option when we were generating the project. Let’s check it if it’s working. We can start the REPL as usual (lein repl), load a development profile (call (dev) in the repl) and start the server (we can call (go) or (reset)). Both of these functions start the server, in the following steps we will use reset, because it refreshes the code and restarts the server.</p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_392ffcd3ba2c6ba6134ea264c1addf6d\">\n    <pre><code class=\"language-\"></code></pre>\n</div>\n\n\n<p>If everything went well, the output should be almost the same. The interesting information in the output is that the server started on port 3000 (we can change this in <em>resources/sms/config.edn</em>). The leiningen’s template created the example handler, so we can hit this URL http://localhost:3000/example.</p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_392ffcd3ba2c6ba6134ea264c1addf6d\">\n    <pre><code class=\"language-\"></code></pre>\n</div>\n\n\n<p>As we can see, it works.</p>\n\n\n\n<h2 class=\"wp-block-heading\">The routes</h2>\n\n\n\n<p>By default the project template generates routes to <em>&lt;project-name&gt;.handler/example</em>. This is just a convention, technically you can put the routes anywhere you want. Our example route is in <em>sms.handler.example</em> namespace, when you open a file you should see something like:</p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_392ffcd3ba2c6ba6134ea264c1addf6d\">\n    <pre><code class=\"language-\"></code></pre>\n</div>\n\n\n<p>The code is pretty small, but there are a few new things. Let’s describe them.</p>\n\n\n\n<p>First, there is <a href=\"https://github.com/weavejester/integrant#initializing-and-halting\" rel=\"noreferrer noopener\" target=\"_blank\">an Integrant component</a> defined by defmethod ig/init-key. Integrant is a micro-framework that allows you to create components and their configuration, and compose them together (you can think about it as a small <a href=\"https://en.wikipedia.org/wiki/Dependency_injection\" rel=\"noreferrer noopener\" target=\"_blank\">DI</a> framework). A component has a life-cycle, but for now <em>init-key</em> would be enough for us. As we can see from its name, init-key is called when the component is being initialized. The name of the component is a namespaced keyword <em>:sms.handler/example</em> and it should follow the code namespace. Integrant tries to load both variants of namespaces: sms.handler.example and <em>sms.handler</em> you can find more about it in <a href=\"https://github.com/weavejester/integrant#loading-namespaces\" rel=\"noreferrer noopener\" target=\"_blank\">the documentation</a>. The last thing for the component is its configuration/options (this is a Clojure map, it could contain other components), but this is not important for now.</p>\n\n\n\n<p>Second thing is the route itself. The route is defined by the <a href=\"https://github.com/weavejester/compojure\" rel=\"noreferrer noopener\" target=\"_blank\">Compojure</a> library. The usage of the library is pretty simple and probably the simplest for beginners. The route is defined by the macros context and GET. Both macros are imported from compojure.core namespace (A side note :using :all is probably not a good idea, it’s hard to say if a function is from the same namespace, imported by <em>:refer</em> or <em>:all</em>, <a href=\"https://stuartsierra.com/2016/clojure-how-to-ns.html#main-clauses\" rel=\"noreferrer noopener\" target=\"_blank\">see more</a>).</p>\n\n\n\n<p>The <a href=\"https://github.com/weavejester/compojure/wiki/Nesting-routes\" rel=\"noreferrer noopener\" target=\"_blank\">Context</a> macro allows you to wrap more routes with the same prefix to remove a path redundancy. The GET macro simply takes a path segment to match (in our example just /example), <a href=\"https://github.com/weavejester/compojure/wiki/Destructuring-Syntax#compojure-specific-destructuring\" rel=\"noreferrer noopener\" target=\"_blank\">a parameters vector</a> (we take none currently), and a response body or function. The response must be a valid <a href=\"https://github.com/ring-clojure/ring/wiki/Creating-responses\" rel=\"noreferrer noopener\" target=\"_blank\">Ring response</a> (the simplest example is a map with <em>:body</em> and <em>:status</em> keys).</p>\n\n\n\n<p>Now we know how the routes are defined, but how does the framework know that there are any routes? Let’s open the project’s configuration <em>resources/sms/config.edn</em>.</p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_392ffcd3ba2c6ba6134ea264c1addf6d\">\n    <pre><code class=\"language-\"></code></pre>\n</div>\n\n\n<p>As we said above <em>:sms.handler/example</em> is the route component. As you can see the component takes a Clojure map. We can pass another dependency to the component by referencing it (e.g. <em>#ig/ref :duct.database/sql</em>). <em>#ig/ref</em> is  syntax sugar for referencing other components. In case you are curious about the details see the <a href=\"https://github.com/edn-format/edn#tagged-elements\" rel=\"noreferrer noopener\" target=\"_blank\">EDN documentation</a>. If you want to see more details about it you can check <a href=\"https://github.com/duct-framework/database.sql\" rel=\"noreferrer noopener\" target=\"_blank\">the repository</a>, but in short, it uses Hikari Connection Pool. We will not use a database in this article, so let’s move on.</p>\n\n\n\n<p>On line 4 we can see a configuration for <em>:duct.router/cascading</em>, this component is a default router from the template and it takes a vector of references to other components. These components are route components. So the router component handles a connection between a request (Ring object) and the router itself.</p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"api\"><span style=\"font-weight: 400;\">The API</span></h2>\n\n\n\n<p><span style=\"font-weight: 400;\">In the previous chapter, we described routes and their configuration. Let’s do some real work and add a resource for creating messages. Our resource handler will accept a message with the following keys:</span></p>\n\n\n\n<ul class=\"wp-block-list\">\n<li><span style=\"font-weight: 400;\">receiver: a phone number as a String</span></li>\n\n\n\n<li><span style=\"font-weight: 400;\">text: a message text as a String</span></li>\n</ul>\n\n\n\n<p><span style=\"font-weight: 400;\">Let’s start with renaming the namespace <em>sms.handler.example</em> to <em>sms.handler.api</em>. We also need to rename the <em>:sms.handler/example</em> component in config.edn and remove the test namespace <em>sms.handler.example-test</em>. You can directly remove the namespace file because we will cover it later.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">The handler file should be like:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_f630fb4075564153a6d2d1a2156b07cf\">\n    <pre><code class=\"language-clojure\">(ns sms.handler.api\n  (:require [compojure.core :refer compojure]\n            [integrant.core :as ig]))\n\n(defmethod ig/init-key :sms.handler/api [_ options]\n  (compojure/context \"/messages\" []\n    (compojure/GET \"/\" []\n      {:body {:example \"data\"}})))\n﻿</code></pre>\n</div>\n\n\n<p>The configuration file should be like:</p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_955848772005544fc17e8716b8af4602\">\n    <pre><code class=\"language-clojure\">{:duct.profile/base\n {:duct.core/project-ns sms\n  :duct.router/cascading\n  [#ig/ref [:sms.handler/api]]\n  :sms.handler/api\n  {:db #ig/ref :duct.database/sql}}\n :duct.profile/dev #duct/include \"dev\"\n :duct.profile/local #duct/include \"local\"\n :duct.profile/prod {}\n :duct.module/logging {}\n :duct.module.web/api\n {}\n :duct.module/sql\n {}}</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">We can test the changes by calling curl http://localhost:3000/messages. If you have already started the REPL, you need to refresh the code in the JVM by calling (reset) from the REPL. Otherwise, it should work when you start the server.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">The resource handler would accept a message with keys (receiver, text) and return the same message with the new key id (as String). Sending a message is not </span><a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods\" rel=\"noreferrer noopener\" target=\"_blank\"><span style=\"font-weight: 400;\">an idempotent process so we also need to change the HTTP method to post</span></a><span style=\"font-weight: 400;\">.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">Let’s use </span><a href=\"https://en.wikipedia.org/wiki/Test-driven_development\" rel=\"noreferrer noopener\" target=\"_blank\"><span style=\"font-weight: 400;\">TDD</span></a><span style=\"font-weight: 400;\"> and start with defining the test. Create a file <em>sms.domain.message.impl_test.clj</em> with these contents:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_fbd2961948e942e36174b0ee7bc5e9c3\">\n    <pre><code class=\"language-clojure\">(ns sms.domain.message.impl-test  \n  (:require [clojure.test :as t]\n            [sms.domain.message.impl :refer\n             [map-&gt;MessageServiceImpl]]\n            [sms.domain.message.sender :refer [Sender]]\n            [sms.domain.message.service :as service])\n  (:import [java.util UUID]))\n\n(t/deftest send!-test\n  (t/testing \"should successfully send a message\"\n    (let [id (UUID/randomUUID)\n          expected-message {:id id\n                            :receiver \"+420700000000\"\n                            :text \"Hej Clojure!\"}\n          conf {:sender\n                (reify Sender\n                  (send! [_ message]\n                    (t/is (= expected-message message))))}\n          request (select-keys expected-message [:receiver :text])\n          result (service/send! (map-&gt;MessageServiceImpl conf)\n                                request)]\n      (t/is (= expected-message result)))))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">To be able to compile a test we need to also define the protocols and the implementation file. Let’s define <em>sms.domain.message.sender</em> namespace like:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_a8385b1518ae396a8a117c40fc5dafa9\">\n    <pre><code class=\"language-clojure\">(ns sms.domain.message.sender)\n\n(defprotocol Sender\n  (send! [this message]))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">And the service itself </span><span style=\"font-weight: 400;\">sms.domain.message.service:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_20e7a6eb3218e49cc7786d1e5d03ad27\">\n    <pre><code class=\"language-clojure\">(ns sms.domain.message.service)\n\n(defprotocol MessageService\n  (send! [this message]))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">And the implementation namespace </span><span style=\"font-weight: 400;\">sms.domain.message.impl</span><span style=\"font-weight: 400;\">:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_8ea5519c68797405109ff3dc48781260\">\n    <pre><code class=\"language-clojure\">(ns sms.domain.message.impl\n  (:require [sms.domain.message.service :refer [MessageService]]))\n\n(defrecord MessageServiceImpl []\n  MessageService\n  (send! [_ message]))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">We did several things here. Let’s describe them to make them clear. First, we created a domain folder with a message subfolder. By that step, we made an explicit sign that the domain folder only contains our domain logic. </span><span style=\"font-weight: 400;\"><b>A message</b></span><span style=\"font-weight: 400;\"> is a domain object so everything related to it should be placed in sms.</span><span style=\"font-weight: 400;\">domain.message</span><span style=\"font-weight: 400;\"> namespace. This structure increases the code cohesion because the functions that operate on the same data structures are together [BobCC]. When we would like to add another domain model, we just add another namespace or subfolder to the </span><b>domain</b><span style=\"font-weight: 400;\"> folder. Everybody who looks into the </span><b>domain</b><span style=\"font-weight: 400;\"> folder will see what the domain objects are, and where the functions that operate on them are.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">We created a </span><em>MessageSender</em><span style=\"font-weight: 400;\"> protocol to separate behavior from implementation. The protocol provides several benefits:</span></p>\n\n\n\n<ul class=\"wp-block-list\">\n<li><span style=\"font-weight: 400;\">The domain behavior is not tightly coupled with the sender’s implementation.</span></li>\n\n\n\n<li><span style=\"font-weight: 400;\">The protocol provides an explicit boundary between the domain logic and the rest of the system.</span></li>\n\n\n\n<li><span style=\"font-weight: 400;\">It’s easy to test domain objects and their behavior.</span></li>\n\n\n\n<li><span style=\"font-weight: 400;\">It’s possible to replace a sender at runtime. </span></li>\n</ul>\n\n\n\n<p><span style=\"font-weight: 400;\">Now we should be able to run tests via REPL by calling (test) or from your editor or IDE. Don’t forget to (reset) the code after every change when you run the tests from the REPL. In one of our previous articles, we described </span><a href=\"https://flexiana.com/2020/01/clojure-repl\" rel=\"noreferrer noopener\" target=\"_blank\"><span style=\"font-weight: 400;\">how to work with REPL</span></a><span style=\"font-weight: 400;\">.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">No matter how you call the tests, they should fail and the output should look like this:</span></p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter\"><img alt=\"Code overview with Duct n.1\" class=\"wp-image-1360\" height=\"381\" src=\"https://flexiana.com/app/uploads/2020/06/duct1-1024x381.png\" width=\"1024\" /></figure>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">And that’s good! Because we see that our code works and it fails in the expected state. As you can see the results says that a message map was expected but the function returned </span><b>nil</b><span style=\"font-weight: 400;\">.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">Now we can implement the resource handler of course we will not be implementing real message sending. Rather we would delegate sending messages to the </span><em>Sender</em><span style=\"font-weight: 400;\"> protocol, but before that we need to talk about </span><a href=\"https://github.com/duct-framework/duct/wiki/Boundaries\" rel=\"noreferrer noopener\" target=\"_blank\"><span style=\"font-weight: 400;\">boundaries</span></a><span style=\"font-weight: 400;\">.</span></p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"boundaries\"><span style=\"font-weight: 400;\">Boundaries</span></h2>\n\n\n\n<p><span style=\"font-weight: 400;\">When a system is being designed it’s a good practice to put the domain logic into the core of the system (ideally as pure functions) and move all communication with the outside world to the edges or boundaries of that system <a href=\"https://flexiana.com/2020/07/building-web-services-with-duct-3-part#bobcc\" rel=\"noreferrer noopener\" target=\"_blank\">[BobCC]</a>. This design approach has many advantages:</span></p>\n\n\n\n<ul class=\"wp-block-list\">\n<li><span style=\"font-weight: 400;\">It makes explicit what is a part of the core and what is not.</span></li>\n\n\n\n<li><span style=\"font-weight: 400;\">It allows us to test the system components independently.</span></li>\n\n\n\n<li><span style=\"font-weight: 400;\">These boundaries can be replaced at runtime.</span></li>\n\n\n\n<li><span style=\"font-weight: 400;\">It allows us to develop the system even if we don’t know the boundary’s details.</span></li>\n\n\n\n<li><span style=\"font-weight: 400;\">This separation is done on the architecture and structure layer (project’s layout, files, …) of the system.</span></li>\n</ul>\n\n\n\n<p><span style=\"font-weight: 400;\">This may sound too abstract or theoretical, so let’s show it in an example. The </span><em>Sender</em><span style=\"font-weight: 400;\"> protocol defines a boundary. This boundary is shaped at the core of the system. But its implementation is shifted outside of the core of the system. E.g. an implementation could be placed in </span><em>sms.boundaries.gateway</em><span style=\"font-weight: 400;\"> namespace.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">Another example of a boundary is the repository pattern <a href=\"https://flexiana.com/2020/07/building-web-services-with-duct-3-part#fowlerpeaa\" rel=\"noreferrer noopener\" target=\"_blank\">[FowlerPEAA]</a>. The repository provides a collection-like interface for accessing domain objects. Its implementation typically connects to a database.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">The </span><em>Sender</em><span style=\"font-weight: 400;\"> with one method send! takes a configuration and message for sending. Now we can continue with implementing the system even if we don’t know the real API for sending messages.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">Now we can define the expected </span><em>Sender</em><span style=\"font-weight: 400;\"> behavior in the test. The Only thing we know is that the API returns an ID of a sent message and we want to add this ID to the message and return it to the caller. In case of an error, it would return an error result. The updated test could look like this:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_2aae2486687615be6f91bd7f2be94e0c\">\n    <pre><code class=\"language-clojure\">(ns sms.domain.message.impl-test\n  (:require [clojure.test :as t]\n            [sms.domain.message.impl :refer\n             [map-&gt;MessageServiceImpl]]\n            [sms.domain.message.sender :as sender]\n            [sms.domain.message.service :as service])\n  (:import [java.util UUID]))\n\n(def ^:private id (UUID/randomUUID))\n\n(def ^:private expected-message\n  {:id id\n   :receiver \"+420700000000\"\n   :text \"Hej Clojure!\"})\n\n(t/deftest send!-test\n  (t/testing \"should successfully send a message\"\n    (let [conf {:sender\n                (reify sender/Sender\n                  (send! [_ message]\n                    (t/is (= (dissoc expected-message :id)\n                             message))\n                    (assoc message :id id)))}\n          request (select-keys expected-message [:receiver :text])\n          result (service/send! (map-&gt;MessageServiceImpl conf)\n                                request)]\n      (t/is (= expected-message result))))\n\n  (t/testing \"should return an error\"\n    (let [conf {:sender\n                (reify sender/Sender\n                  (send! [_ message]\n                    {:error :unexpected-error}))}\n          request (select-keys expected-message [:receiver :text])\n          result (service/send! (map-&gt;MessageServiceImpl conf)\n                                request)]\n      (t/is (= {:error :unexpected-error} result)))))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">We have defined the configuration for the API component with a boundary </span><em>Sender</em><span style=\"font-weight: 400;\">. Actually we have reified the protocol (an anonymous implementation) in place just to simulate a response from the service and also a given message is asserted to the expected one (line 18).</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">If we run the tests again, nothing would change! Because we haven’t changed the handler’s implementation. So let’s update the implementation to use the </span><em>Sender</em><span style=\"font-weight: 400;\">’s function send!.</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_1849867c68f1c44df15e07ecdc8a0f57\">\n    <pre><code class=\"language-clojure\">(ns sms.domain.message.impl\n  (:require [sms.domain.message.sender :as sender]\n            [sms.domain.message.service :refer [MessageService]]))\n\n(defrecord MessageServiceImpl [sender]\n  MessageService\n  (send! [_ request]\n    (sender/send! sender request)))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">There are a few new things. First, the function uses the </span><em>Sender</em><span style=\"font-weight: 400;\">’s send! function. Second, a sender field was added to  </span><em>MessageServiceImpl</em><span style=\"font-weight: 400;\"> record.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">If we run the tests now they should work.</span></p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter\"><img alt=\"Code overview with Duct n.2\" class=\"wp-image-1361\" height=\"595\" src=\"https://flexiana.com/app/uploads/2020/06/duct2-1024x595.png\" width=\"1024\" /></figure>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">Now we have finished the domain logic. The architecture may look too complicated for that simple task. But real systems are more complex and too complicated for the presentation.</span></p>\n\n\n\n<h2 class=\"wp-block-heading\"><span style=\"font-weight: 400;\">Handling the HTTP requests</span></h2>\n\n\n\n<p><span style=\"font-weight: 400;\">At this point, we have implemented the domain logic, but we don’t have any entry points to access the code. We are going to create an HTTP handler (or you can call it a controller). As in the previous section, we start with tests.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">The test may look like this:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_b79b580fc6d67ff5f2b274d9c8349025\">\n    <pre><code class=\"language-clojure\">(ns sms.services.messages-test\n  (:require [clojure.test :as t]\n            [integrant.core :as ig]\n            [ring.mock.request :as mock]\n            [sms.domain.message.service :refer [MessageService]]\n            [sms.handler.api])\n  (:import [java.util UUID]))\n\n(defn- send-message-api\n  [conf params]\n  (let [handler (ig/init-key :sms.handler/api conf)]\n    (-&gt; :post\n        (mock/request \"/messages\")\n        (assoc :body-params params)\n        handler)))\n\n(def ^:private expected-message\n  {:id (UUID/randomUUID)\n   :receiver \"+420700000000\"\n   :text \"Hej Clojure!\"})\n\n(t/deftest send-message-test\n  (t/testing \"should successfully send a message\"\n    (let [conf {:message-service\n                (reify MessageService\n                  (send! [_ message]\n                    (t/is (= (select-keys expected-message\n                                          [:receiver :text])\n                             message))\n                    expected-message))}\n          params (select-keys expected-message [:receiver :text])\n          {:keys [body status]} (send-message-api conf params)]\n      (t/is (= expected-message body))\n      (t/is (= 201 status))))\n\n  (t/testing \"should return 503, Sender failed\"\n    (let [conf {:message-service\n                (reify MessageService\n                  (send! [_ message]\n                    {:error :unexpected-error}))}\n          params (select-keys expected-message [:receiver :text])\n          {:keys [status]} (send-message-api conf params)]\n      (t/is (= 503 status)))))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">Let’s also add the handler function, then we can compile the code:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_7621f5c074356a052aaed7cc2d24613b\">\n    <pre><code class=\"language-clojure\">(ns sms.handler.api.message)\n\n(defn send! [message-service req])</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">When we run the tests, they should fail.</span></p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter\"><img alt=\"Code overview with Duct n.3\" class=\"wp-image-1362\" height=\"550\" src=\"https://flexiana.com/app/uploads/2020/06/duct3.png\" width=\"942\" /></figure>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">We should probably describe the test file and some of its interesting parts. We have defined the send-message-api function that wraps the API call. It calls <em>ig/init-key</em> on the API components with some configuration (the same thing happens when the application’s server starts), the application calls a </span><b>post</b><span style=\"font-weight: 400;\"> request with the given params.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">The test itself is pretty simple, we have defined the component’s configuration as </span><span style=\"font-weight: 400;\">conf</span><span style=\"font-weight: 400;\"> with one key called </span><span style=\"font-weight: 400;\">message-service</span><span style=\"font-weight: 400;\">. Under that key, we reified (mocked) the service protocol to expected behavior. We have made actual calls of the API and assert the result (body and status in this case).</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">The second test is almost the same as the first one, except the service returns an error result.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">The very simple implementation of the handler may look like:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_b00d6ef814c7b9268418cb1137ac77cd\">\n    <pre><code class=\"language-clojure\">(ns sms.handler.api.message\n  (:require [ring.util.response :as response]\n            [sms.domain.message.service :as service]))\n\n(defn send! [message-service req]\n  (let [result (service/send! message-service\n                              (select-keys req\n                                           [:receiver :text]))]\n    (if (= {:error :unexpected-error} result)\n      (response/status {} 503)\n      (response/created (format \"/messages/%s\" (:id result))\n                        result))))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">Now tests should be green.</span></p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter\"><img alt=\"Code overview with Duct n.4\" class=\"wp-image-1363\" height=\"547\" src=\"https://flexiana.com/app/uploads/2020/06/duct4.png\" width=\"943\" /></figure>\n</div>\n\n\n<h2 class=\"wp-block-heading\"><span style=\"font-weight: 400;\">Production implementation</span></h2>\n\n\n\n<p><span style=\"font-weight: 400;\">Well, we have implemented the HTTP handler and also added tests. But if we call the handler e.g. via curl</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_b295191f12ed0506f9aa6f2e90656063\">\n    <pre><code class=\"language-clojure\">curl localhost:3000/messages -X POST -H 'Content-Type: application/json' -d '{\"receiver\": \"+4207000000000\", \"text\": \"Hej Clojure!\"}'</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">We would get something like this:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_da70db4ce53f5c171304d5c04a72b412\">\n    <pre><code class=\"language-clojure\">java.lang.IllegalArgumentException: No implementation of method: :send! of protocol: #'sms.domain.message.service/MessageService found for class: nil</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">The Message Service needs production implementation. Don’t be afraid we are not going to implement a real SMS sender. Instead, we will forward the message to another service via HTTP. First, let’s add a new dependency to the project </span><a href=\"https://github.com/http-kit/http-kit\" rel=\"noreferrer noopener\" target=\"_blank\"><span style=\"font-weight: 400;\">HTTP-Kit</span></a><span style=\"font-weight: 400;\">, the latest stable version is </span><a href=\"https://clojars.org/http-kit\" rel=\"noreferrer noopener\" target=\"_blank\"><span style=\"font-weight: 400;\">2.3.0</span></a><span style=\"font-weight: 400;\">. Update project.clj and restart the REPL, yes this is really needed. Start the REPL and create a file <em>src/sms/boundaries/sms_gateway.clj</em> with the following content:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_0b26468280e31ab8e69be65080a133d4\">\n    <pre><code class=\"language-clojure\">(ns sms.boundaries.sms-gateway\n  (:require [duct.logger :as logger]\n            [integrant.core :as ig]\n            [jsonista.core :as jsonista]\n            [org.httpkit.client :as http]\n            [sms.domain.message.sender :refer [Sender]]))\n\n(def mime-type \"application/json\")\n\n(def default-headers\n  {\"Accept\" mime-type\n   \"Content-Type\" mime-type})\n\n(defrecord SmsGateway [logger url]\n  Sender\n  (send! [_ message]\n    (let [{:keys [body status] :as response}\n          (http/post url\n                     {:as :text\n                      :body (jsonista/write-value-as-string message)\n                      :headers default-headers})]\n      (case status\n        (200 201) (jsonista/read-value body)\n        (do\n          (logger/log logger :error response)\n          {:error :unexpected-error})))))\n\n(defmethod ig/init-key :sms.boundaries/sms-gateway\n  [_ opts]\n  (map-&gt;SmsGateway opts))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">On line 14 the </span><span style=\"font-weight: 400;\">Sender</span><span style=\"font-weight: 400;\"> protocol is implemented. The record takes a logger instance and a url of the remote service. An implementation of send! The method is pretty straightforward, the API is called and if a response is successful (HTTP code 200 or 201) the response is parsed, otherwise, the response is logged and </span><span style=\"font-weight: 400;\">:error</span><span style=\"font-weight: 400;\"> is returned. On line 27 the Integrant component is defined. The component converts a given configuration to a new record </span><span style=\"font-weight: 400;\">Sms Gateway</span><span style=\"font-weight: 400;\">.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">Now we have a component for the Sender, but we also need a component for <em>MessageService</em> to be able to pass the Sender’s implementation. Let’s create a file <em>sms.services.message</em> with the following content:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_a1ab3c3e38c332a4afbe505b99c39a23\">\n    <pre><code class=\"language-clojure\">(ns sms.services.message\n  (:require [integrant.core :as ig]\n            [sms.domain.message.impl :refer\n             [map-&gt;MessageServiceImpl]]))\n\n(defmethod ig/init-key ::service\n  [_ opts]\n  (map-&gt;MessageServiceImpl opts))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">The code is very simple. The Integrant component just creates an implementation of <em>MessageService</em>.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">Let’s initialize the component in the project’s configuration. Let’s update <em>resources/sms/config.edn</em> like this:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_0622d58e1afbfeca8c0fbeddc9e65803\">\n    <pre><code class=\"language-clojure\">{:duct.profile/base\n {:duct.core/project-ns sms\n  :duct.router/cascading\n  [#ig/ref [:sms.handler/api]]\n  :sms.boundaries/sms-gateway\n  {:logger #ig/ref :duct/logger\n   :url #duct/env [\"SMS_GATEWAY_URL\" Str]}\n  :sms.services.message/service\n  {:sender #ig/ref :sms.boundaries/sms-gateway}\n  :sms.handler/api\n  {:message-service #ig/ref :sms.services.message/service}}\n :duct.profile/dev #duct/include \"dev\"\n :duct.profile/local #duct/include \"local\"\n :duct.profile/prod {}\n :duct.module/logging {}\n :duct.module.web/api\n {}\n :duct.module/sql\n {}}</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">On line 7 the SmsGateway component is initialized with the Duct’s logger and the SMS Gateway URL that is taken from an environment variable called <em>SMS_GATEWAY_URL</em> (as String). On line 11 the <em>MessageService</em> component is initialized with a sender.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">This usage of </span><a href=\"https://en.wikipedia.org/wiki/Inversion_of_control\" rel=\"noreferrer noopener\" target=\"_blank\"><span style=\"font-weight: 400;\">Inversion of Control</span></a><span style=\"font-weight: 400;\"> allows us to easily change the Sender’s implementation in tests, when the system starts, and even at runtime.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">Unfortunately in local development we probably aren’t able to connect to the real SMS Gateway. But fortunately, we can fix this problem by creating a mock of the gateway. Let’s create a silly mock of the gateway <em>dev/src/sms_dev/boundaries/sms_gateway_mock.clj</em></span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_a20ad5ef9acb1a54c4df4b3703c97794\">\n    <pre><code class=\"language-clojure\">(ns sms-dev.boundaries.sms-gateway-mock\n  (:require [integrant.core :as ig]\n            [sms.domain.message.sender :refer [Sender]])\n  (:import [java.util UUID]))\n\n(defrecord SmsGatewayMock []\n  Sender\n  (send! [_ message]\n    (assoc message :id (UUID/randomUUID))))\n\n(defmethod ig/init-key :sms-dev.boundaries/sms-gateway-mock\n  [_ opts]\n  (map-&gt;SmsGatewayMock opts))</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">As you can see the silly implementation of </span><span style=\"font-weight: 400;\">Sender</span><span style=\"font-weight: 400;\"> protocol just put an id on a given message to simulate the real behavior.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">Now we have to tell the Duct to use SmsGatewayMock just for local development. Update <em>dev/resources/local.edn</em> file:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_383caba48590071881171939d406e008\">\n    <pre><code class=\"language-clojure\">{:sms-dev.boundaries/sms-gateway-mock {}\n :sms.services.message/service\n {:sender #ig/ref :sms-dev.boundaries/sms-gateway-mock}}</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">On the very first line, a <em>SmsGatewayMock</em> is created and on another line, we tell the <em>:sms.services.message/service</em> to use the <em>SmsGatewayMock</em> as a Sender.</span></p>\n\n\n\n<p><span style=\"font-weight: 400;\">Now if we restart the REPL or call (reset) in the REPL, the code will be refreshed and we should be able to call the API e.g. via curl:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_b295191f12ed0506f9aa6f2e90656063\">\n    <pre><code class=\"language-clojure\">curl localhost:3000/messages -X POST -H 'Content-Type: application/json' -d '{\"receiver\": \"+4207000000000\", \"text\": \"Hej Clojure!\"}'</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">If everything went well the output will  look like this:</span></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_3b80c67ad56962c3f57f98098713a89d\">\n    <pre><code class=\"language-clojure\">{\"receiver\":\"+4207000000000\",\"text\":\"Hej Clojure!\",\"id\":\"097bd803-c3fb-4d4a-beeb-bc381ec4e4d8\"}</code></pre>\n</div>\n\n\n<p><span style=\"font-weight: 400;\">As you can see we have sent the message and a new id has been put into that message. Because we added the <em>SmsGatewayMock</em> to the dev folder the mock will not be part of the production JAR (all files from the dev folder will not be included too).</span></p>\n\n\n\n<h2 class=\"wp-block-heading\">Secret magic</h2>\n\n\n\n<p>You may be wondering how is it possible that a request’s body was parsed to a map. There is one important thing we haven’t described yet. The Duct has got modules with default configurations for common middlewares like <a href=\"https://github.com/ring-clojure/ring-defaults\" rel=\"noreferrer noopener\" target=\"_blank\">Ring defaults</a>. The module is named <a href=\"https://github.com/duct-framework/module.web\" rel=\"noreferrer noopener\" target=\"_blank\">:duct.module.web/api</a> and it’s initialized in the project’s configuration. If you’re curious you can check the internals and see that it uses <a href=\"https://github.com/duct-framework/module.web/blob/6aa5ccb38280a872d45eaddbfab8e9fa1013ca5a/src/duct/middleware/web.clj#L133\" rel=\"noreferrer noopener\" target=\"_blank\">Muuntaja</a> for marshalling.</p>\n\n\n\n<p>The module puts middleware around <em>:duct.core/handler</em> (the main handler called from the HTTP servlet) when the system starts. This is default behaviour and it can be overridden, but we don’t want to go so far in this article.</p>\n\n\n\n<p>When the Muuntaja middleware sees Content-Type in a request’s headers it can try to negotiate and parse the request (in our case to a map). If a request doesn’t have any <a href=\"https://github.com/metosin/muuntaja/blob/cbe438ee66a19e64128a01ccda25f45c2ca854f9/modules/muuntaja/src/muuntaja/core.clj#L117\" rel=\"noreferrer noopener\" target=\"_blank\">known Content-Type</a>, the attribute <em>:body-params</em> on the request object will be nil. </p>\n\n\n\n<p>As you can see now technically there is no hidden magic, but a beginner could be surprised or confused.</p>\n\n\n\n<h2 class=\"wp-block-heading\">Production</h2>\n\n\n\n<p>We have implemented the web service and now we want to run it in a staging or production environment. We need to have a stand-alone file that can be run with <a href=\"https://en.wikipedia.org/wiki/Java_Development_Kit\" rel=\"noreferrer noopener\" target=\"_blank\">JDK</a>. Let’s run the<a href=\"https://www.braveclojure.com/getting-started/#Building_the_Clojure_Project\" rel=\"noreferrer noopener\" target=\"_blank\"> following command</a>: <strong>lein uberjar</strong></p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_c5b866fa1deb94cbec95b3a2c77d44f7\">\n    <pre><code class=\"language-clojure\">[lukas@hel:~/dev/flexiana/sms]$ lein uberjar\nCompiling sms.boundaries.sms-gateway\nCompiling sms.domain.message.impl\nCompiling sms.domain.message.sender\nCompiling sms.domain.message.service\nCompiling sms.handler.api\nCompiling sms.handler.api.message\nCompiling sms.main\nCompiling sms.services.message\nCreated /Users/lukas/dev/flexiana/sms/target/sms-0.1.0-SNAPSHOT.jar\nCreated /Users/lukas/dev/flexiana/sms/target/sms-0.1.0-SNAPSHOT-standalone.jar</code></pre>\n</div>\n\n\n<p>Now we can take the sms-0.1.0-SNAPSHOT-standalone.jar and run it everywhere, where <a href=\"https://en.wikipedia.org/wiki/Java_Development_Kit\">JDK</a> is installed.</p>\n\n\n\n<p>You can simply test it from a command line. Before running it the Gateway URL must be set via an environment variable. Let’s try it:</p>\n\n\n\n<div class=\"wp-block-sourcecode\" id=\"block_65e51a8a74a88d152d56386a337cda96\">\n    <pre><code class=\"language-clojure\">[lukas@hel:~/dev/flexiana/sms]$ export SMS_GATEWAY_URL=\"http://localhost:8080/smsgateway\"\n[lukas@hel:~/dev/flexiana/sms]$ java -jar target/sms-0.1.0-SNAPSHOT-standalone.jar \n20-05-25 10:28:01 hel REPORT [duct.server.http.jetty:13] - :duct.server.http.jetty/starting-server {:port 3000}</code></pre>\n</div>\n\n\n<p>As you can we have set the <em>SMS_GATEWAY_URL</em> variable and run the application. In the command line, we can see that the application has started on port 3000. So if the gateway service was running on port 8080 we would be able to test it by posting a message to http://localhost:3000/messages.</p>\n\n\n\n<p>Duct uses by default <a href=\"https://github.com/ptaoussanis/timbre\" rel=\"noreferrer noopener\" target=\"_blank\">Timbre</a> for logging. In the development profile, all logs go to <em>logs/dev.log</em> file. But in the production, all logs are sent to stdout.</p>\n\n\n\n<h2 class=\"wp-block-heading\">Conclusion</h2>\n\n\n\n<p>This article has introduced a Clojure framework, Duct, that helps programmers with building server-side applications. The Duct parts have been briefly described with the necessary details. All the described Duct’s parts have been presented with practical examples and tests.</p>\n\n\n\n<p>A reader should be able to create a new server-side application, implement HTTP handlers, and call 3rd party APIs. Also, the reader has been taught how to write tests. Optionally run the tests from the favorite editor and at the end how to build a deployable JAR file and configure it.</p>\n\n\n\n<p>This article has not exhausted all of Duct’s possibilities. There are more things that could be explained in future articles like:</p>\n\n\n\n<ul class=\"wp-block-list\">\n<li>Communication with a database</li>\n\n\n\n<li>Data validation</li>\n\n\n\n<li>Schedulers</li>\n\n\n\n<li>etc.</li>\n</ul>\n\n\n\n<hr class=\"wp-block-separator has-css-opacity\" />\n\n\n\n<h2 class=\"wp-block-heading\">Bibliography</h2>\n\n\n\n<p><strong id=\"bobca\">[BobCA]</strong>: Clean Architecture, Robert C. Martin, Prentice Hall, 2017</p>\n\n\n\n<p><strong id=\"bobcc\">[BobCC]</strong>: Clean Code, Robert C. Martin, Prentice Hall, 2009</p>\n\n\n\n<p><strong id=\"fowlerpeaa\">[FowlerPEAA]</strong>: Patterns of Enterprise Application Architecture, Martin Fowler, Addison-Wesley, 2003</p>\n\n\n\n<p><strong id=\"xunit\">[XUnit]</strong>: XUnit Test Patterns: Refactoring Test Code, Gerard Meszaros, Addison-Wesley, 2007</p>\n<p>The post <a href=\"https://flexiana.com/news/2026/01/building-web-services-with-duct-1-part-2\" rel=\"nofollow\">Building web services with Duct</a> appeared first on <a href=\"https://flexiana.com\" rel=\"nofollow\">Flexiana</a>.</p>"}, :excerpts [{:text "... that there is no standard framework like Django, Ruby On Rails, Spring in other languages. Clojure lets a...", :matched-terms ["ruby" "rails"], :source :content} {:text "... code.</li>\n\n\n\n<li>No scaffolding (like in Ruby On Rails)</li>\n</ul>\n\n\n\n<p>This post is about <a...", :matched-terms ["ruby" "rails"], :source :content}]}]