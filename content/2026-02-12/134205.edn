[{:rule-id "rescript", :item {:feed-id "planet-clojure", :item-id "https://dev.to/kovan/python-to-clojure-a-gentle-guide-for-pythonistas-11bn", :title "Python to Clojure: A Gentle Guide for Pythonistas", :link "https://dev.to/kovan/python-to-clojure-a-gentle-guide-for-pythonistas-11bn", :published-at #inst "2026-02-12T08:47:22.000-00:00", :content "Python to Clojure: A Gentle Guide for Pythonistas Python is the world's most popular general-purpose language. Clojure is a quiet powerhouse — a modern Lisp on the JVM that has earned fierce loyalty among developers who discover it. Both languages prize simplicity, but they mean very different things by the word. This article walks through every major topic in the official Python tutorial and shows how Clojure approaches the same idea. Whether you're a Pythonista curious about functional programming or a polyglot looking for a side-by-side reference, this guide is for you. 1. Whetting Your Appetite Python sells itself on readability, rapid prototyping, and \"batteries included.\" It eliminates the compile-link cycle, encourages experimentation in the REPL, and runs everywhere. Clojure shares the same REPL-driven culture, but takes a more opinionated stance: data is the universal interface. Where Python says \"everything is an object,\" Clojure says \"everything is data.\" Clojure runs on the JVM (and in the browser via ClojureScript), giving it access to the entire Java ecosystem — a different kind of \"batteries included.\" Both languages let you sit down and be productive in minutes. The difference is in what they optimize for: Python optimizes for readability of imperative code; Clojure optimizes for simplicity of data transformation. 2. The Interpreter / The REPL Python has an interactive interpreter invoked with python: >>> 2 + 2\n4\n>>> print(\"Hello, world!\")\nHello, world!\n Clojure has the REPL (Read-Eval-Print Loop), which serves the same purpose but is even more central to the workflow. Most Clojure developers keep a REPL connected to their editor at all times: user=> (+ 2 2)\n4\nuser=> (println \"Hello, world!\")\nHello, world!\n The parentheses aren't noise — they're the syntax. Every expression is a list where the first element is the function. This uniformity is what makes Lisp macros possible, and it takes about a day to stop noticing the parens. 3. An Informal Introduction Numbers Python: >>> 17 / 3      # 5.666...\n>>> 17 // 3     # 5 (floor division)\n>>> 17 % 3      # 2\n>>> 5 ** 2      # 25\n Clojure: (/ 17 3)       ;=> 17/3  (a rational! no precision lost)\n(quot 17 3)    ;=> 5\n(rem 17 3)     ;=> 2\n(Math/pow 5 2) ;=> 25.0\n Right away, a philosophical difference appears. Clojure gives you a ratio (17/3) by default rather than silently losing precision. Clojure also has arbitrary-precision integers out of the box — no special int vs long distinction to worry about. Strings Python: word = \"Python\"\nword[0]        # 'P'\nword[0:2]      # 'Py'\nlen(word)      # 6\nf\"Hello, {word}!\"\n Clojure: (def word \"Clojure\")\n(get word 0)          ;=> \\C  (a character)\n(subs word 0 2)       ;=> \"Cl\"\n(count word)          ;=> 7\n(str \"Hello, \" word \"!\")\n Both treat strings as immutable. In Python, strings are sequences of characters; in Clojure, strings are Java strings, but you can also treat them as sequences of characters when needed via seq. Lists Python: squares = [1, 4, 9, 16, 25]\nsquares[0]              # 1\nsquares + [36, 49]      # [1, 4, 9, 16, 25, 36, 49]\nsquares.append(36)      # mutates!\n Clojure: (def squares [1 4 9 16 25])\n(get squares 0)              ;=> 1\n(conj squares 36)            ;=> [1 4 9 16 25 36] (new vector!)\n(into squares [36 49])       ;=> [1 4 9 16 25 36 49]\n This is the first big fork in the road. Python lists are mutable; Clojure vectors are persistent and immutable. conj doesn't change squares — it returns a new vector that efficiently shares structure with the old one. No defensive copying, no \"did someone mutate my list?\" bugs. 4. Control Flow if / cond Python: if x < 0:\n    print(\"Negative\")\nelif x == 0:\n    print(\"Zero\")\nelse:\n    print(\"Positive\")\n Clojure: (cond\n  (neg? x) (println \"Negative\")\n  (zero? x) (println \"Zero\")\n  :else (println \"Positive\"))\n In Clojure, if is an expression that returns a value (no need for a ternary operator). cond handles the multi-branch case. for loops Python: for word in [\"cat\", \"window\", \"defenestrate\"]:\n    print(word, len(word))\n Clojure: (doseq [word [\"cat\" \"window\" \"defenestrate\"]]\n  (println word (count word)))\n But here's the thing — doseq is for side effects. When you want to transform data (which is most of the time), you use map, filter, or for (which is a list comprehension, not a loop): (for [word [\"cat\" \"window\" \"defenestrate\"]]\n  [word (count word)])\n;=> ([\"cat\" 3] [\"window\" 6] [\"defenestrate\" 13])\n range Python: list(range(0, 10, 2))  # [0, 2, 4, 6, 8]\n Clojure: (range 0 10 2)  ;=> (0 2 4 6 8)\n Clojure's range is lazy — it doesn't allocate memory for all elements upfront. Pattern Matching Python 3.10+: match status:\n    case 400:\n        return \"Bad request\"\n    case 401 | 403:\n        return \"Not allowed\"\n    case _:\n        return \"Something's wrong\"\n Clojure (with core.match): (match status\n  400 \"Bad request\"\n  (:or 401 403) \"Not allowed\"\n  :else \"Something's wrong\")\n Clojure's pattern matching via core.match is a library, not built-in syntax — which is itself a philosophical statement. In Lisp, you can add any syntax you want via macros. Functions Python: def fib(n):\n    \"\"\"Return Fibonacci series up to n.\"\"\"\n    a, b = 0, 1\n    result = []\n    while a < n:\n        result.append(a)\n        a, b = b, a + b\n    return result\n Clojure: (defn fib [n]\n  \"Return Fibonacci series up to n.\"\n  (->> [0 1]\n       (iterate (fn [[a b]] [b (+ a b)]))\n       (map first)\n       (take-while #(< % n))))\n The Clojure version reads as a pipeline: start with [0 1], repeatedly produce the next pair, extract the first element, and keep going while it's less than n. No mutation, no accumulator variable, no while loop. Just data flowing through transformations. Default Arguments, *args, **kwargs Python: def greet(name, greeting=\"Hello\"):\n    print(f\"{greeting}, {name}!\")\n\ndef log(*args, **kwargs):\n    print(args, kwargs)\n Clojure: (defn greet\n  ([name] (greet name \"Hello\"))\n  ([name greeting] (println (str greeting \", \" name \"!\"))))\n\n(defn log [& args]\n  (println args))\n Clojure uses multi-arity functions for defaults and & args for variadics. For keyword arguments, the idiomatic approach is to pass a map: (defn create-user [{:keys [name email role] :or {role \"member\"}}]\n  {:name name :email email :role role})\n\n(create-user {:name \"Ada\" :email \"ada@example.com\"})\n Lambda Expressions Python: double = lambda x: x * 2\nsorted(pairs, key=lambda p: p[1])\n Clojure: (def double #(* % 2))        ; reader macro shorthand\n(sort-by second pairs)       ; or: (sort-by #(nth % 1) pairs)\n In Clojure, anonymous functions are so common they have a shorthand: #(...) with % for the argument. Named functions and anonymous functions are treated identically — there's no second-class lambda. 5. Data Structures Lists, Tuples, and Vectors Python Clojure Properties list — [1, 2, 3] vector — [1 2 3] Indexed, ordered tuple — (1, 2, 3) vector — [1 2 3] (Clojure vectors are already immutable) — list — '(1 2 3) Linked list, efficient head access Python needs both lists (mutable) and tuples (immutable). Clojure needs only vectors (immutable, indexed) and lists (immutable, sequential). The mutability question simply doesn't arise. Dictionaries / Maps Python: tel = {\"jack\": 4098, \"sape\": 4139}\ntel[\"guido\"] = 4127\ndel tel[\"sape\"]\n{x: x**2 for x in range(5)}\n Clojure: (def tel {\"jack\" 4098 \"sape\" 4139})\n(assoc tel \"guido\" 4127)       ;=> new map with guido added\n(dissoc tel \"sape\")            ;=> new map without sape\n(into {} (map (fn [x] [x (* x x)]) (range 5)))\n Again: assoc and dissoc return new maps. The original is untouched. Clojure maps can also use keywords as keys (:jack instead of \"jack\"), which double as accessor functions — a small but delightful ergonomic touch: (def person {:name \"Ada\" :age 36})\n(:name person)  ;=> \"Ada\"\n Sets Python: a = {1, 2, 3, 4}\nb = {3, 4, 5, 6}\na - b            # {1, 2}\na | b            # {1, 2, 3, 4, 5, 6}\na & b            # {3, 4}\n Clojure: (require '[clojure.set :as set])\n(def a #{1 2 3 4})\n(def b #{3 4 5 6})\n(set/difference a b)     ;=> #{1 2}\n(set/union a b)          ;=> #{1 2 3 4 5 6}\n(set/intersection a b)   ;=> #{3 4}\n Virtually identical semantics, different syntax. Clojure sets are also immutable and can be used as functions: (a 3) returns 3 (truthy), (a 7) returns nil (falsy). List Comprehensions Python: [x**2 for x in range(10) if x % 2 == 0]\n Clojure: (for [x (range 10) :when (even? x)]\n  (* x x))\n Clojure's for is a list comprehension, not a loop. It supports :when for filtering, :let for local bindings, and multiple binding forms for nested iteration — all lazily evaluated. Looping Techniques Python: for i, v in enumerate([\"tic\", \"tac\", \"toe\"]):\n    print(i, v)\n\nfor q, a in zip(questions, answers):\n    print(q, a)\n Clojure: (doseq [[i v] (map-indexed vector [\"tic\" \"tac\" \"toe\"])]\n  (println i v))\n\n(doseq [[q a] (map vector questions answers)]\n  (println q a))\n Or more idiomatically, just use map to transform and print later: (map-indexed (fn [i v] [i v]) [\"tic\" \"tac\" \"toe\"])\n(map vector questions answers)\n 6. Modules and Namespaces Python: import math\nfrom os.path import join\nimport numpy as np\n Clojure: (require '[clojure.string :as str])\n(require '[clojure.java.io :as io])\n(import '[java.util Date])\n Python organizes code into modules (files) and packages (directories with __init__.py). Clojure organizes code into namespaces — each file declares a namespace with ns, and dependencies are explicit: (ns myapp.core\n  (:require [clojure.string :as str]\n            [cheshire.core :as json])\n  (:import [java.time LocalDate]))\n There's no from X import * equivalent in Clojure, and that's by design. Explicit is better than implicit — a principle Pythonistas already appreciate. The if __name__ == \"__main__\" Pattern Python: if __name__ == \"__main__\":\n    main()\n Clojure doesn't need this pattern because the REPL workflow means you rarely \"run a file.\" When you do need an entry point, you declare a -main function: (defn -main [& args]\n  (println \"Hello from the command line!\"))\n 7. Input and Output String Formatting Python: name = \"World\"\nf\"Hello, {name}!\"\n\"{:.2f}\".format(3.14159)\n Clojure: (str \"Hello, \" name \"!\")            ; simple concatenation\n(format \"Hello, %s!\" name)          ; printf-style\n(format \"%.2f\" 3.14159)             ; \"3.14\"\n Clojure uses Java's String.format under the hood. There's no f-string equivalent, but str for concatenation and format for templates cover the same ground. File I/O Python: with open(\"data.txt\", encoding=\"utf-8\") as f:\n    content = f.read()\n\nwith open(\"output.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"Hello\\n\")\n Clojure: (slurp \"data.txt\")                         ; read entire file\n(spit \"output.txt\" \"Hello\\n\")             ; write entire file\n\n;; For line-by-line processing:\n(with-open [rdr (clojure.java.io/reader \"data.txt\")]\n  (doseq [line (line-seq rdr)]\n    (println line)))\n slurp and spit — arguably the best-named I/O functions in any language. For structured work, with-open mirrors Python's with statement. JSON Python: import json\ndata = json.loads('{\"name\": \"Ada\"}')\njson.dumps(data)\n Clojure (with cheshire or clojure.data.json): (require '[cheshire.core :as json])\n(json/parse-string \"{\\\"name\\\": \\\"Ada\\\"}\" true)  ;=> {:name \"Ada\"}\n(json/generate-string {:name \"Ada\"})             ;=> \"{\\\"name\\\":\\\"Ada\\\"}\"\n The true argument keywordizes the keys — JSON maps become idiomatic Clojure maps instantly. 8. Errors and Exceptions Try / Catch Python: try:\n    x = int(input(\"Number: \"))\nexcept ValueError as e:\n    print(f\"Invalid: {e}\")\nfinally:\n    print(\"Done\")\n Clojure: (try\n  (Integer/parseInt (read-line))\n  (catch NumberFormatException e\n    (println \"Invalid:\" (.getMessage e)))\n  (finally\n    (println \"Done\")))\n Since Clojure runs on the JVM, it catches Java exceptions. The structure is almost identical to Python's try/except/finally. Raising Exceptions Python: raise ValueError(\"something went wrong\")\n Clojure: (throw (ex-info \"something went wrong\" {:type :validation}))\n ex-info is idiomatic Clojure — it creates an exception that carries a data map. Instead of defining custom exception classes, you attach structured data to a generic exception. This is the \"data over classes\" philosophy in action: (try\n  (throw (ex-info \"bad input\" {:field :email :value \"not-an-email\"}))\n  (catch clojure.lang.ExceptionInfo e\n    (println (ex-data e))))\n;=> {:field :email, :value \"not-an-email\"}\n Custom Exceptions Python: class InsufficientFunds(Exception):\n    def __init__(self, balance, amount):\n        self.balance = balance\n        self.amount = amount\n Clojure rarely defines custom exception classes. Instead: (throw (ex-info \"Insufficient funds\"\n         {:type :insufficient-funds\n          :balance 100\n          :amount 150}))\n One generic mechanism, infinite data shapes. No class hierarchy to maintain. 9. Classes and Objects This is where Python and Clojure diverge most dramatically. Python's Object-Oriented Approach class Dog:\n    kind = \"canine\"             # class variable\n\n    def __init__(self, name):\n        self.name = name        # instance variable\n\n    def speak(self):\n        return f\"{self.name} says woof!\"\n\nrex = Dog(\"Rex\")\nrex.speak()  # \"Rex says woof!\"\n Clojure's Data-Oriented Approach (def rex {:kind \"canine\" :name \"Rex\"})\n\n(defn speak [dog]\n  (str (:name dog) \" says woof!\"))\n\n(speak rex)  ;=> \"Rex says woof!\"\n No class. No self. No constructor. Just a map and a function. The dog is its data. Inheritance vs. Composition Python: class Animal:\n    def __init__(self, name):\n        self.name = name\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n Clojure uses multimethods or protocols for polymorphism: ;; Multimethod approach — dispatch on data\n(defmulti speak :type)\n(defmethod speak :dog [animal] \"Woof!\")\n(defmethod speak :cat [animal] \"Meow!\")\n\n(speak {:type :dog :name \"Rex\"})   ;=> \"Woof!\"\n(speak {:type :cat :name \"Whiskers\"}) ;=> \"Meow!\"\n ;; Protocol approach — like interfaces\n(defprotocol Speakable\n  (speak [this]))\n\n(defrecord Dog [name]\n  Speakable\n  (speak [this] (str name \" says Woof!\")))\n\n(speak (->Dog \"Rex\"))  ;=> \"Rex says Woof!\"\n Multimethods dispatch on any function of the arguments (not just type), making them more flexible than traditional OOP dispatch. Iterators and Generators Python: class Reverse:\n    def __init__(self, data):\n        self.data = data\n        self.index = len(data)\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.index == 0:\n            raise StopIteration\n        self.index -= 1\n        return self.data[self.index]\n def reverse(data):\n    for index in range(len(data) - 1, -1, -1):\n        yield data[index]\n Clojure: (reverse \"spam\")  ;=> (\\m \\a \\p \\s)\n(rseq [1 2 3 4])  ;=> (4 3 2 1)\n Clojure's sequences are lazy iterators. There's no iterator protocol to implement — every collection already participates in the sequence abstraction. Need a custom lazy sequence? Use lazy-seq: (defn countdown [n]\n  (when (pos? n)\n    (lazy-seq (cons n (countdown (dec n))))))\n\n(countdown 5)  ;=> (5 4 3 2 1)\n Generator Expressions Python: sum(x*x for x in range(10))\n Clojure: (reduce + (map #(* % %) (range 10)))\n;; or with the threading macro:\n(->> (range 10) (map #(* % %)) (reduce +))\n The threading macro ->> reads like a Unix pipeline and is one of Clojure's most beloved features. 10. The Standard Library Python's \"Batteries Included\" Python ships with modules for OS interaction, file I/O, regex, math, dates, HTTP, email, testing, logging, threading, and much more — all in the standard library. Clojure's Approach Clojure's standard library is smaller but remarkably powerful for data manipulation. For everything else, you tap into: The entire Java ecosystem — need HTTP? Use java.net.http. Need dates? Use java.time. Need crypto? Use javax.crypto. Clojure community libraries — managed via deps.edn or Leiningen. Python Module Clojure Equivalent os, shutil clojure.java.io, Java NIO re re-find, re-matches, re-seq (built-in) math clojure.math (1.11+), java.lang.Math datetime java.time (via tick library for ergonomics) json clojure.data.json or cheshire unittest clojure.test (built-in) logging tools.logging + logback threading core.async, future, pmap, agents collections Built into the core (persistent data structures) argparse tools.cli sqlite3 next.jdbc + any JDBC driver Concurrency — Where Clojure Truly Shines Python's threading story involves the GIL and careful locking. Clojure was designed for concurrency from day one: Atoms — uncoordinated, synchronous state updates Refs — coordinated, transactional state (Software Transactional Memory) Agents — asynchronous state updates core.async — CSP-style channels (like Go's goroutines) (def counter (atom 0))\n(swap! counter inc)      ;=> 1  (thread-safe, no locks)\n@counter                 ;=> 1\n\n;; Process 1000 items in parallel:\n(pmap expensive-fn (range 1000))\n 11. Advanced Standard Library Output Formatting Python: pprint, textwrap, locale Clojure: clojure.pprint/pprint (built-in), Java's Locale (require '[clojure.pprint :refer [pprint]])\n(pprint {:a 1 :b {:c [1 2 3] :d \"hello\"}})\n Templating Python: string.Template Clojure: clojure.core/format, or libraries like Selmer for HTML templating. Multi-threading Python: import threading\nt = threading.Thread(target=worker)\nt.start()\n Clojure: (future (worker))  ; runs in a thread pool, returns a deref-able future\n@(future (+ 1 2))  ;=> 3\n Logging Python: logging.warning(\"Watch out!\") Clojure: (require '[clojure.tools.logging :as log])\n(log/warn \"Watch out!\")\n Decimal Arithmetic Python: decimal.Decimal(\"0.1\") + decimal.Decimal(\"0.2\") Clojure: (+ 0.1M 0.2M)  ;=> 0.3M  (BigDecimal literal with M suffix)\n Clojure has literal syntax for BigDecimals (M suffix) and BigIntegers (N suffix) — no imports needed. 12. Virtual Environments and Packages Python uses venv and pip: python -m venv myenv\nsource myenv/bin/activate\npip install requests\npip freeze > requirements.txt\n Clojure uses deps.edn (official) or project.clj (Leiningen): ;; deps.edn\n{:deps {org.clojure/clojure {:mvn/version \"1.12.0\"}\n        cheshire/cheshire {:mvn/version \"5.13.0\"}}}\n clj -M -m myapp.core  # run with dependencies resolved automatically\n There's no virtual environment concept because dependencies are resolved per-project from the deps.edn file. Maven coordinates ensure reproducibility. No activate/deactivate dance. 13. Floating-Point Arithmetic Both languages sit on top of IEEE 754 doubles: >>> 0.1 + 0.2 == 0.3\nFalse\n (= (+ 0.1 0.2) 0.3)  ;=> false\n Same hardware, same surprise. But Clojure offers escape hatches as first-class citizens: ;; Ratios — exact arithmetic, no precision loss\n(+ 1/10 2/10)      ;=> 3/10\n(= (+ 1/10 2/10) 3/10)  ;=> true\n\n;; BigDecimals\n(+ 0.1M 0.2M)      ;=> 0.3M\n Clojure's ratio type means you can do exact fractional arithmetic without importing anything. This alone has saved countless financial applications from rounding bugs. 14. Interactive Editing Python supports readline-based history and tab completion in its interactive interpreter. Clojure developers typically use nREPL connected to their editor (Emacs + CIDER, VS Code + Calva, IntelliJ + Cursive). The experience goes far beyond line editing — you can evaluate any expression in your source file, inspect results inline, and navigate documentation without leaving your editor. The Big Picture Dimension Python Clojure Paradigm Multi-paradigm (imperative + OOP + functional) Functional-first (with pragmatic escape hatches) Mutability Mutable by default Immutable by default Type System Dynamic, gradual typing via hints Dynamic, with optional specs Concurrency GIL, async/await, multiprocessing STM, atoms, agents, core.async Syntax Indentation-based, keyword-rich S-expressions, minimal syntax OOP Classes, inheritance, dunder methods Protocols, multimethods, plain maps Runtime CPython, PyPy JVM, JavaScript (ClojureScript) Package Manager pip + venv deps.edn / Leiningen + Maven REPL Culture Strong Even stronger Ideal For Scripts, ML/AI, web, automation Data processing, concurrency, web, DSLs Closing Thoughts Python is a phenomenal language. Its readability, ecosystem, and community have earned it the top spot for good reason. But if you've ever felt the friction of debugging shared mutable state, wrestling with class hierarchies, or wishing your data transformations could be simpler — Clojure might be the language that makes you see programming differently. You don't have to abandon Python. Many developers use both: Python for its unmatched ML/AI ecosystem and scripting ergonomics, Clojure for systems where correctness, concurrency, and data transformation matter most. The best way to start is to fire up a REPL. Try Clojure's official getting started guide, or experiment in the browser at repl.it. The parentheses will feel strange for an hour. Then they'll feel like home. This article was written as a companion to the official Python tutorial. Every section maps to a chapter in that tutorial, translated through the lens of Clojure's philosophy: simple, data-driven, and functional."}, :excerpts [{:text "... runs on the JVM (and in the browser via ClojureScript), giving it access to the entire Java ecosystem —...", :matched-terms ["rescript"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://dev.to/kovan/python-to-wisp-the-lisp-that-stole-pythons-indentation-5hdl", :title "Python to Wisp: The Lisp That Stole Python's Indentation", :link "https://dev.to/kovan/python-to-wisp-the-lisp-that-stole-pythons-indentation-5hdl", :published-at #inst "2026-02-12T09:16:10.000-00:00", :content "Python to Wisp: The Lisp That Stole Python's Indentation Every Lisp programmer has heard the complaint: \"too many parentheses.\" Every Python programmer has heard the praise: \"the indentation makes it readable.\" Wisp asks a dangerous question: what if we put them together? Wisp is an indentation-sensitive syntax for Scheme — specifically GNU Guile Scheme — standardized as SRFI-119. It takes the structure of Lisp and expresses it through indentation, the way Python does. The outer parentheses vanish. What remains is code that looks strangely like Python but thinks like Lisp — with macros, tail-call optimization, exact arithmetic, and homoiconicity. This article walks through every major topic in the official Python tutorial and shows how Wisp approaches the same concept. Two languages, both indented, separated by philosophy. 1. Whetting Your Appetite Python sells itself on readability, rapid prototyping, and an enormous ecosystem. It's the default choice for scripts, web backends, data science, and teaching. Wisp sells itself on a different proposition: the readability of Python's visual structure combined with the raw power of Scheme. Scheme is one of the most theoretically clean programming languages ever designed — tail-call optimization, first-class continuations, hygienic macros — but its parenthesized syntax scares newcomers away. Wisp removes that barrier. Wisp runs on GNU Guile, a mature Scheme implementation that ships with many GNU/Linux distributions. It gives you access to Guile's full ecosystem: real OS threads (no GIL), arbitrary-precision arithmetic, a sophisticated module system, and the ability to reshape the language through macros. The trade-off? Python has PyPI. Wisp has the Guile ecosystem and whatever you can call via FFI. This isn't a contest for library count — it's a contest for expressiveness per line. 2. The Interpreter / The REPL Python: >>> 2 + 2\n4\n>>> print(\"Hello, world!\")\nHello, world!\n Wisp: > + 2 2\n4\n> display \"Hello, world!\"\nHello, world!\n To use Wisp interactively, launch guile and switch languages with ,L wisp. Or run scripts directly: guile --language=wisp -s hello.w. The syntax is prefix notation — the function comes first, then its arguments — but without the outer parentheses that traditional Scheme requires. The line display \"Hello, world!\" is equivalent to Scheme's (display \"Hello, world!\"). Indentation replaces the parens. 3. An Informal Introduction Numbers Python: >>> 17 / 3       # 5.666...\n>>> 17 // 3      # 5\n>>> 17 % 3       # 2\n>>> 5 ** 2       # 25\n Wisp: / 17 3            ; 17/3 — an exact rational!\nquotient 17 3     ; 5\nremainder 17 3    ; 2\nexpt 5 2          ; 25\n The first difference is striking. (/ 17 3) in Scheme returns 17/3 — an exact rational number, not a floating-point approximation. Scheme distinguishes exact and inexact numbers at the type level. If you want the float, you ask for it explicitly: (exact->inexact (/ 17 3)) gives 5.666.... Operators take multiple arguments naturally: + 1 2 3 4 5       ; 15\n* 2 3 4            ; 24\n< 1 2 3 4          ; #t (chained comparison)\n And Scheme gives you arbitrary-precision integers for free. No int vs long distinction, no overflow: expt 2 1000        ; a 302-digit number, exactly\n Strings Python: word = \"Python\"\nword[0]        # 'P'\nword[0:2]      # 'Py'\nlen(word)      # 6\nf\"Hello, {word}!\"\n Wisp: define word \"Wisp\"\nstring-ref word 0       ; #\\W (a character)\nsubstring word 0 2      ; \"Wi\"\nstring-length word       ; 4\nformat #f \"Hello, ~a!\" word  ; \"Hello, Wisp!\"\n Scheme strings are mutable (unlike Python's), though idiomatic Scheme treats them as values. The format function uses ~a as a placeholder — #f means \"return a string\" and #t means \"print directly\": format #t \"Hello, ~a!\\n\" word   ; prints: Hello, Wisp!\n Lists Python: squares = [1, 4, 9, 16, 25]\nsquares[0]              # 1\nsquares + [36, 49]      # [1, 4, 9, 16, 25, 36, 49]\nsquares.append(36)      # mutates!\n Wisp: define squares '(1 4 9 16 25)\nlist-ref squares 0              ; 1\nappend squares '(36 49)         ; (1 4 9 16 25 36 49)\n Scheme lists are linked lists — immutable by convention, efficient at the head. append returns a new list without modifying the original. There's no .append mutation. If you want indexed access, Scheme has vectors: define sq #(1 4 9 16 25)\nvector-ref sq 0                 ; 1\n The '(1 4 9 16 25) is a quoted list — the quote ' prevents Scheme from trying to call 1 as a function. 4. Control Flow if / cond Python: if x < 0:\n    print(\"Negative\")\nelif x == 0:\n    print(\"Zero\")\nelse:\n    print(\"Positive\")\n Wisp: cond\n  : < x 0\n    display \"Negative\"\n  : = x 0\n    display \"Zero\"\n  else\n    display \"Positive\"\n In Wisp, cond handles multi-branch conditionals. Each branch starts with a : (which creates the nested parentheses Scheme expects). The else clause catches everything. The simple if takes a condition, a then-branch, and an else-branch: if : < x 0\n  display \"Negative\"\n  display \"Non-negative\"\n And because if is an expression, not a statement, you can use it anywhere: define label\n  if : < x 0\n    . \"negative\"\n    . \"non-negative\"\n The . (dot) prevents the string from being treated as a function call — it marks a bare value rather than an application. for loops Python: for word in [\"cat\", \"window\", \"defenestrate\"]:\n    print(word, len(word))\n Wisp: for-each\n  lambda : word\n    display word\n    display \" \"\n    display : string-length word\n    newline\n  '(\"cat\" \"window\" \"defenestrate\")\n Scheme doesn't have a built-in for loop — iteration is done through for-each (for side effects) or map (for transformation). The lambda defines an anonymous function applied to each element. Or using a named let (Scheme's idiomatic loop): let loop\n  : words '(\"cat\" \"window\" \"defenestrate\")\n  when : not : null? words\n    display : car words\n    display \" \"\n    display : string-length : car words\n    newline\n    loop : cdr words\n This is recursion that looks like a loop. car gets the first element, cdr gets the rest, and loop calls itself with the remaining list. Guile guarantees tail-call optimization, so this uses constant stack space — unlike Python, which would hit a recursion limit. range Python: list(range(0, 10, 2))  # [0, 2, 4, 6, 8]\n Wisp: use-modules : srfi srfi-1\n\niota 5 0 2             ; (0 2 4 6 8)\n Guile's iota from SRFI-1 generates numeric sequences. The arguments are count, start, and step — slightly different from Python's start, stop, step. while Python: a, b = 0, 1\nwhile a < 10:\n    print(a)\n    a, b = b, a + b\n Wisp: let loop : : a 0\n             b 1\n  when : < a 10\n    display a\n    newline\n    loop b {a + b}\n There's no while keyword here — it's a named let that recurses. The {a + b} uses Wisp's curly-brace infix syntax (from SRFI-105), which lets you write math the familiar way. Without it, you'd write (+ a b). Pattern Matching Python 3.10+: match command:\n    case \"quit\":\n        quit_game()\n    case \"help\":\n        show_help()\n    case _:\n        print(\"Unknown\")\n Wisp (using Guile's match): use-modules : ice-9 match\n\nmatch command\n  : \"quit\"\n    quit-game\n  : \"help\"\n    show-help\n  : _\n    display \"Unknown\"\n Guile's match supports destructuring, guards, and nested patterns — similar to Python's structural pattern matching but available since long before Python 3.10. Functions Python: def factorial(n):\n    \"\"\"Return the factorial of n.\"\"\"\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n Wisp: define : factorial n\n  \"Return the factorial of n.\"\n  if : = n 0\n    . 1\n    * n : factorial {n - 1}\n Functions are defined with define. The : factorial n creates (factorial n) — a function named factorial taking one argument. The docstring goes right after the parameter list. The last expression is the return value. The Wisp version also benefits from tail-call optimization if rewritten in tail-recursive style: define : factorial n\n  let loop : : i n\n               acc 1\n    if : = i 0\n      . acc\n      loop {i - 1} {acc * i}\n This handles (factorial 100000) without breaking a sweat. Python would need sys.setrecursionlimit or an iterative rewrite. Default and Keyword Arguments Python: def greet(name, greeting=\"Hello\"):\n    print(f\"{greeting}, {name}!\")\n Wisp: use-modules : ice-9 optargs\n\ndefine* : greet name #:optional (greeting \"Hello\")\n  format #t \"~a, ~a!\\n\" greeting name\n Guile uses define* (from ice-9 optargs) for optional and keyword arguments: define* : connect host #:key (port 8080) (timeout 30)\n  format #t \"Connecting to ~a:~a (timeout ~a)\\n\" host port timeout\n\nconnect \"example.com\" #:port 443\n; => Connecting to example.com:443 (timeout 30)\n #:optional for positional defaults, #:key for keyword arguments. More explicit than Python's unified syntax, but equally capable. Lambda Expressions Python: double = lambda x: x * 2\nsorted(words, key=lambda w: len(w))\n Wisp: define double\n  lambda : x\n    * x 2\n\nsort words\n  lambda : a b\n    < (string-length a) (string-length b)\n In Wisp, lambda is a full block — no single-expression restriction like Python's lambda. The indented body can contain anything. 5. Data Structures Lists (Linked Lists) Scheme lists are cons-cell linked lists — the fundamental data structure of all Lisps: define fruits '(\"apple\" \"banana\" \"cherry\")\ncar fruits                    ; \"apple\" (first)\ncdr fruits                    ; (\"banana\" \"cherry\") (rest)\ncons \"mango\" fruits           ; (\"mango\" \"apple\" \"banana\" \"cherry\")\nlength fruits                 ; 3\nlist-ref fruits 1             ; \"banana\"\n Operation Python Wisp First element lst[0] car lst Rest of list lst[1:] cdr lst Prepend [x] + lst cons x lst Append lst + [x] append lst (list x) Length len(lst) length lst Nth element lst[n] list-ref lst n Vectors (Arrays) For indexed access, Scheme has vectors: define v #(10 20 30 40 50)\nvector-ref v 2               ; 30\nvector-length v               ; 5\n Hash Tables (Dictionaries) Python: tel = {\"jack\": 4098, \"sape\": 4139}\ntel[\"guido\"] = 4127\ndel tel[\"sape\"]\n Wisp: define tel : make-hash-table\n\nhashq-set! tel 'jack 4098\nhashq-set! tel 'sape 4139\nhashq-set! tel 'guido 4127\nhashq-remove! tel 'sape\n\nhashq-ref tel 'jack          ; 4098\n Hash tables in Guile use explicit functions rather than syntax. It's more verbose, but Scheme compensates with association lists for small mappings: define tel\n  ' : (jack . 4098)\n      (sape . 4139)\n\nassoc 'jack tel               ; (jack . 4098)\n Association lists are simple, immutable, and idiomatic for small key-value collections. Sets Guile doesn't have a built-in set type, but SRFI-113 provides them, or you can use sorted lists with lset- operations from SRFI-1: use-modules : srfi srfi-1\n\ndefine a '(1 2 3 4)\ndefine b '(3 4 5 6)\n\nlset-difference equal? a b     ; (1 2)\nlset-union equal? a b          ; (1 2 3 4 5 6)\nlset-intersection equal? a b   ; (3 4)\n List Comprehensions Python: [x**2 for x in range(10) if x % 2 == 0]\n Wisp: use-modules : srfi srfi-42\n\nlist-ec : : i (index 10)\n  if : = 0 : remainder i 2\n  expt i 2\n; => (0 4 16 36 64)\n SRFI-42 provides eager comprehensions. The : lines create the nested structure that Scheme expects. Or idiomatically with map and filter: map\n  lambda : x\n    expt x 2\n  filter even? : iota 10\n Looping Techniques Python: for i, v in enumerate([\"tic\", \"tac\", \"toe\"]):\n    print(i, v)\n Wisp: let loop : : i 0\n             words '(\"tic\" \"tac\" \"toe\")\n  when : not : null? words\n    format #t \"~a ~a\\n\" i : car words\n    loop {i + 1} : cdr words\n Or using SRFI-42: do-ec : : i (index 3)\n  format #t \"~a ~a\\n\" i\n    list-ref '(\"tic\" \"tac\" \"toe\") i\n 6. Modules Importing Python: import math\nfrom os.path import join\nimport json as j\n Wisp: use-modules : ice-9 regex\n\nuse-modules\n  : srfi srfi-1\n    #:select : iota fold\n\nuse-modules\n  : ice-9 popen\n    #:prefix popen-\n Guile's module system uses use-modules. The #:select option imports specific symbols, and #:prefix namespaces them — similar to Python's from X import Y and import X as Y. Defining Modules Python: # mymodule.py\ndef greet(name):\n    return f\"Hello, {name}!\"\n Wisp: define-module : myproject mymodule\n  . #:export : greet\n\ndefine : greet name\n  format #f \"Hello, ~a!\" name\n The #:export clause explicitly lists what the module makes public — like Python's __all__ but mandatory and standard. The Script Entry Point Python: if __name__ == \"__main__\":\n    main()\n Wisp scripts use a shell header that invokes Guile with the right flags: #!/usr/bin/env bash\nexec guile -L . -x .w --language=wisp -e main -s \"$0\" \"$@\"\n!#\n\ndefine : main args\n  display \"Hello from the command line!\\n\"\n The -e main flag tells Guile to call the main function with command-line arguments. 7. Input and Output String Formatting Python: name = \"World\"\nf\"Hello, {name}!\"\n\"{:.2f}\".format(3.14159)\n Wisp: define name \"World\"\nformat #f \"Hello, ~a!\" name           ; \"Hello, World!\"\nformat #f \"~,2f\" 3.14159              ; \"3.14\"\n Guile's format uses tilde-based directives: ~a for display, ~s for write (with quotes), ~d for integer, ~f for float, ~% for newline. It's closer to Common Lisp's format than to Python's f-strings. File I/O Python: with open(\"data.txt\", encoding=\"utf-8\") as f:\n    content = f.read()\n\nwith open(\"output.txt\", \"w\") as f:\n    f.write(\"Hello\\n\")\n Wisp: use-modules : ice-9 textual-ports\n\n; Read entire file\ndefine content\n  call-with-input-file \"data.txt\" get-string-all\n\n; Write to file\ncall-with-output-file \"output.txt\"\n  lambda : port\n    display \"Hello\\n\" port\n Or using with-input-from-file for a more Python-with-like pattern: with-input-from-file \"data.txt\"\n  lambda ()\n    let loop : : line (read-line)\n      when : not : eof-object? line\n        display line\n        newline\n        loop : read-line\n Scheme's port system is lower-level than Python's file objects but equally capable. Every I/O function accepts an optional port argument — display \"hello\" port writes to a specific destination. JSON Guile has a JSON module: use-modules : json\n\ndefine data\n  json-string->scm \"{\\\"name\\\": \\\"Ada\\\"}\"\n; => ((\"name\" . \"Ada\"))\n\nscm->json-string '((name . \"Ada\"))\n; => \"{\\\"name\\\":\\\"Ada\\\"}\"\n 8. Errors and Exceptions Try / Catch Python: try:\n    x = int(input(\"Number: \"))\nexcept ValueError as e:\n    print(f\"Invalid: {e}\")\nfinally:\n    print(\"Done\")\n Wisp: catch #t\n  lambda ()\n    ; try body\n    define x\n      string->number : read-line\n    when : not x\n      error \"Invalid number\"\n  lambda : key . args\n    ; catch handler\n    format #t \"Error: ~a ~a\\n\" key args\n\ndisplay \"Done\\n\"\n Guile uses catch and throw (or the newer with-exception-handler / raise-exception). The handler is a lambda that receives the error key and arguments. The more modern style: use-modules : ice-9 exceptions\n\nwith-exception-handler\n  lambda : exn\n    format #t \"Error: ~a\\n\" : exception-message exn\n  lambda ()\n    string->number \"not-a-number\"\n  . #:unwind? #t\n Raising Exceptions Python: raise ValueError(\"something went wrong\")\n Wisp: error \"something went wrong\"\n Or with structured keys: throw 'value-error \"something went wrong\"\n Custom Error Types Python creates exception classes. Guile uses symbol keys: throw 'insufficient-funds \"Need more money\"\n  . balance amount\n Or with the newer condition system from R7RS: use-modules : ice-9 exceptions\n\ndefine-exception-type &insufficient-funds &error\n  make-insufficient-funds\n  insufficient-funds?\n  : balance insufficient-funds-balance\n    amount insufficient-funds-amount\n More ceremony than Python's class hierarchy, but also more structured — each field is explicitly named and accessible. 9. Classes and Objects This is where the languages diverge most sharply. Python's Object-Oriented Approach class Dog:\n    kind = \"canine\"\n\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        return f\"{self.name} says woof!\"\n\nrex = Dog(\"Rex\")\nrex.speak()\n Wisp's Approach: GOOPS Guile has GOOPS (GNU Object-Oriented Programming System), a powerful CLOS-style object system: use-modules : oop goops\n\ndefine-class <dog> ()\n  kind\n    . #:init-value \"canine\"\n    . #:getter dog-kind\n  name\n    . #:init-keyword #:name\n    . #:getter dog-name\n\ndefine-method : speak (dog <dog>)\n  format #f \"~a says woof!\" : dog-name dog\n\ndefine rex : make <dog> #:name \"Rex\"\nspeak rex                ; \"Rex says woof!\"\n GOOPS supports multiple inheritance, multiple dispatch (methods dispatch on all argument types, not just the first), metaclasses, and method combinations. It's more powerful than Python's object system, but also more verbose. Inheritance Python: class Puppy(Dog):\n    def speak(self):\n        return f\"{self.name} says yip!\"\n Wisp: define-class <puppy> (<dog>)\n\ndefine-method : speak (dog <puppy>)\n  format #f \"~a says yip!\" : dog-name dog\n The Alternative: Just Use Data Many Scheme programmers avoid GOOPS entirely and use plain data structures with functions — similar to Clojure's philosophy: define : make-dog name\n  ' : (kind . \"canine\")\n      (name . ,name)\n\ndefine : dog-speak dog\n  format #f \"~a says woof!\" : assoc-ref dog 'name\n\ndefine rex : make-dog \"Rex\"\ndog-speak rex\n This is simpler and often sufficient. 10. The Standard Library Python's Batteries vs. Guile's Foundations Python ships with modules for everything. Guile ships with fewer but more fundamental tools: Python Module Guile Equivalent os POSIX bindings (built-in) sys (ice-9 command-line) re (ice-9 regex) math Built-in exact arithmetic + (ice-9 math) json (json) threading (ice-9 threads) — real OS threads, no GIL! unittest SRFI-64 datetime SRFI-19 argparse (ice-9 getopt-long) collections SRFIs (1, 69, 113, etc.) http (web client), (web server) sqlite3 Guile-DBI Regex use-modules : ice-9 regex\n\ndefine m : string-match \"[0-9]+\" \"hello 42 world\"\nmatch:substring m              ; \"42\"\n Threading — No GIL This is Guile's secret weapon. Where Python has the GIL limiting true parallelism, Guile has real POSIX threads: use-modules : ice-9 threads\n\ncall-with-new-thread\n  lambda ()\n    display \"Hello from another thread!\\n\"\n\npar-map\n  lambda : x\n    * x x\n  iota 10\n; => (0 1 4 9 16 25 36 49 64 81)\n par-map is parallel map — it distributes work across OS threads. No multiprocessing workaround, no async/await complexity. Just threads. Web Server in 10 Lines use-modules : web server\n\nrun-server\n  lambda : request request-body\n    values\n      ' : (content-type . (text/plain))\n      . \"Hello, World!\"\n Guile ships with a built-in HTTP server and client. No framework needed for basic use. 11. Advanced Standard Library Output Formatting use-modules : ice-9 pretty-print\n\npretty-print\n  ' : (name . \"Ada\")\n      (languages . (\"Python\" \"Wisp\" \"Scheme\"))\n Multi-threading (Continued) use-modules : ice-9 threads\n\ndefine mutex : make-mutex\ndefine counter 0\n\ndefine : increment\n  lock-mutex mutex\n  set! counter {counter + 1}\n  unlock-mutex mutex\n\n; Spawn 100 threads\nlet loop : : i 100\n  when : > i 0\n    call-with-new-thread increment\n    loop {i - 1}\n Exact Decimal Arithmetic Python needs the decimal module. Scheme has exact rationals built-in: + 1/10 2/10               ; 3/10 (exact!)\n= (+ 1/10 2/10) 3/10      ; #t\n* 7/10 105/100             ; 147/200 (exact!)\n No Decimal class, no imports. Exact fractions are a primitive type. 12. Virtual Environments and Packages Python has venv and pip. Guile has a different model. Installation: # Guile is often pre-installed on GNU/Linux\nsudo apt install guile-3.0\n\n# Wisp\nsudo apt install guile-wisp\n# or from source\n Dependencies: Guile uses a load-path model rather than per-project virtual environments: export GUILE_LOAD_PATH=\"/path/to/library:$GUILE_LOAD_PATH\"\nguile --language=wisp -s myapp.w\n For project-specific dependencies, the community uses GNU Guix (a functional package manager) or manual load-path management. It's less ergonomic than pip install, but aligns with the GNU ecosystem's philosophy. There's no PyPI equivalent. Libraries are distributed through GNU Guix, OS packages, or directly as source. This is Wisp's weakest point compared to Python. 13. Floating-Point Arithmetic Python: >>> 0.1 + 0.2 == 0.3\nFalse\n Wisp: = {0.1 + 0.2} 0.3             ; #f (same problem with floats!)\n Same IEEE 754, same surprises. But Scheme has an escape hatch Python doesn't — exact rationals are a first-class type, not a library: = {1/10 + 2/10} 3/10          ; #t (exact!)\nexact->inexact 1/3              ; 0.3333333333333333\ninexact->exact 0.1              ; 3602879701896397/36028797018963968\n That last line reveals the actual value stored for 0.1 — a ratio of two large integers. Scheme lets you move freely between exact and inexact worlds. 14. Interactive Editing Python's REPL supports readline history and tab completion. Guile's REPL offers similar features plus meta-commands: ,help              ; show all REPL commands\n,describe display  ; show documentation\n,time (fib 30)     ; benchmark an expression\n,profile (fib 30)  ; profile an expression\n,L wisp            ; switch to Wisp syntax\n,L scheme          ; switch back to Scheme\n You can switch between Wisp and Scheme syntax in the same session. This is useful for learning — write in Wisp, see what Scheme it corresponds to. 15. The Secret Weapon: Macros Like all Lisps, Wisp supports macros — compile-time code transformations. But because Wisp code looks like indented pseudocode, Wisp macros are unusually readable for Lisp macros. Example: A Python-style for-in loop define-syntax-rule : for-in var lst body ...\n  for-each\n    lambda : var\n      body ...\n    lst\n\n; Now use it:\nfor-in word '(\"cat\" \"window\" \"defenestrate\")\n  display word\n  newline\n You just added a for-in construct to the language. It's not a function that takes a callback — it's real syntax that the compiler expands before execution. Example: Unless define-syntax-rule : unless condition body ...\n  when : not condition\n    body ...\n\nunless : = 1 2\n  display \"Math still works\\n\"\n Example: Time-it define-syntax-rule : time-it body ...\n  let : : start (current-time)\n    body ...\n    format #t \"Elapsed: ~a seconds\\n\"\n      - (current-time) start\n\ntime-it\n  let loop : : i 1000000\n    when : > i 0\n      loop {i - 1}\n Why This Matters In Python, if you need a new control structure, you write a function with callbacks or a context manager — a workaround. In Wisp, you write a macro that generates the exact code you want, with zero runtime overhead. The result is indistinguishable from a built-in language feature. This is the deep reason Lisp syntax exists: when code and data have the same structure, programs that write programs become natural. The Big Picture Dimension Python Wisp Syntax Indentation + keywords Indentation + prefix notation Paradigm Multi-paradigm (imperative-first) Multi-paradigm (functional-first) Type System Dynamic Dynamic Mutability Mutable by default Immutable by convention Tail Calls No optimization (recursion limit) Guaranteed optimization Arithmetic Floats by default Exact rationals by default Threading GIL limits parallelism Real OS threads Macros No Hygienic macros OOP Classes + inheritance GOOPS (multiple dispatch) or plain data Ecosystem Massive (PyPI) Small (Guile + GNU Guix) Runtime CPython GNU Guile (JIT-compiled Scheme) Best For Scripts, ML/AI, web, teaching Systems, DSLs, concurrency, extensible programs Closing Thoughts Wisp is not trying to replace Python. It's trying to answer a question: can Lisp be approachable? The answer is yes. Wisp code reads like indented pseudocode. You can show it to someone who has never programmed and they'll follow the structure. But underneath that gentle surface lies one of the most powerful programming models ever devised — one where functions are data, data is code, and the language reshapes itself to fit your problem. The ecosystem gap is real. You won't find a Wisp equivalent of NumPy or Django. But for systems programming, scripting, language design, concurrent servers, or any domain where you want to think differently about code — Wisp offers something Python cannot: a Lisp you can read at a glance. display \"Welcome to Wisp.\\n\"\ndisplay \"Where indentation meets imagination.\\n\"\n Get started: install Guile, install Wisp, and type ,L wisp in the Guile REPL. The parentheses are gone. The power remains. This article was written as a companion to the official Python tutorial. Every section maps to a chapter in that tutorial, showing the same concepts through Wisp's indentation-sensitive Lisp lens. For more on Wisp, visit draketo.de/software/wisp."}, :excerpts [{:text "... per line. 2. The Interpreter / The REPL Python: >>> 2 + 2\n4\n>>> print(\"Hello,...", :matched-terms ["repl"], :source :content} {:text "... Scheme's (display \"Hello, world!\"). Indentation replaces the parens. 3. An Informal Introduction...", :matched-terms ["repl"], :source :content}]}]